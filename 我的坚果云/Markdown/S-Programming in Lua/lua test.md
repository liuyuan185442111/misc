lua-5.1.4.tar.gz里test目录下有一些测试用例，我看了一遍，令人印象深刻的地方有：
string库的模式匹配，简化的正则，够用不复杂。
协程和闭包，有时可简化编程，但有时也不好理解。
table的__index和__newindex，可用来模拟面向对象，规则虽然简单，但用好真不那么容易。
##部分摘选：
###斐波那契(fibonacci)数列
fibfor.lua
这是正着算的
```
-- example of for with generator functions

function generatefib (n)
  return coroutine.wrap(function ()
    local a,b = 1, 1
    while a <= n do
      coroutine.yield(a)
      a, b = b, a+b
    end
  end)
end

for i in generatefib(1000) do print(i) end
```
fib.lua
这是倒着算的
```
-- fibonacci function with cache

-- very inefficient fibonacci function
function fib(n)
	N=N+1
	if n<2 then
		return n
	else
		return fib(n-1)+fib(n-2)
	end
end

-- a general-purpose value cache
function cache(f)
	local c={}
	return function (x)
		local y=c[x]
		if not y then
			y=f(x)
			c[x]=y
		end
		return y
	end
end

-- run and time it
function test(s,f)
	N=0
	local c=os.clock()
	local v=f(n)
	local t=os.clock()-c
	print(s,n,v,t,N)
end

n=arg[1] or 24		-- for other values, do lua fib.lua XX
n=tonumber(n)
print("","n","value","time","evals")
test("plain",fib)
fib=cache(fib)
test("cached",fib)
```
递归层数过多之后堆栈很快就会溢出，通过cache有效减少递归调用，关键是依赖解释执行这个特性，cache可以做成通用函数，在fib成为一个新函数之后，在原fib函数定义中对fib的调用使用的是新的fib。
###筛选法求质数
sieve.lua
```
-- the sieve of of Eratosthenes programmed with coroutines
-- typical usage: lua -e N=1000 sieve.lua | column

-- generate all the numbers from 2 to n
function gen (n)
  return coroutine.wrap(function ()
    for i=2,n do coroutine.yield(i) end
  end)
end

-- filter the numbers generated by `g', removing multiples of `p'
function filter (p, g)
  return coroutine.wrap(function ()
    while 1 do
      local n = g()
      if n == nil then return end
      if math.mod(n, p) ~= 0 then coroutine.yield(n) end
    end
  end)
end

N=N or 1000		-- from command line
x = gen(N)		-- generate primes up to N
while 1 do
  local n = x()		-- pick a number until done
  if n == nil then break end
  print(n)		-- must be a prime number
  x = filter(n, x)	-- now remove its multiples
end
```
每获得一个新质数n之后，会创建一个协程filter n，它resume filter m(m是n之前的质数)来获取下一个数，filter m resume filter s(s是m之前的质数)，...，直到resume gen产生下一个整数，filter 2判断这个数能否被2整除，如果能整除则继续取下一个数，不能被整除则yield给filter 3，filter 3再判断能否被3整除，如果能则resume filter 2获取下一个数，如果不能则yield给filter 5，......，直到最后交给filter n，最后获得这个数，不能被已获得的质数整除，所以它是新的质数。
这段程序首先不太好理解，其次在运算过程中嵌套层数会越来越多，堆栈很快就会溢出，也就是作为协程的例子看看就好了。
###看不懂的
factorial.lua
```
-- function closures are powerful

-- traditional fixed-point operator from functional programming
Y = function (g)
      local a = function (f) return f(f) end
      return a(function (f)
                 return g(function (x)
                             local c=f(f)
                             return c(x)
                           end)
               end)
end


-- factorial without recursion
F = function (f)
      return function (n)
               if n == 0 then return 1
               else return n*f(n-1) end
             end
    end

factorial = Y(F)   -- factorial is the fixed point of F

-- now test it
function test(x)
	io.write(x,"! = ",factorial(x),"\n")
end

for n=0,16 do
	test(n)
end
```
虽然没看懂，但我试着修改成了下面的代码：
```
function F(f)
        return function (n)
                if n == 0 then return 1
                else return n*f(n-1) end
        end
end

factorial = F(function(n) return factorial(n) end)

print(factorial(4))
```