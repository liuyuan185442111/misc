<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STL之string</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><p>先看string的定义（stringfwd.h）：</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">//char_traits的声明</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _CharT&gt;
<span class="hljs-keyword">struct</span> char_traits;

<span class="hljs-comment">//char_traits的specialization的声明</span>
<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">class</span> char_traits&lt;<span class="hljs-keyword">char</span>&gt;;
<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">class</span> char_traits&lt;<span class="hljs-keyword">wchar_t</span>&gt;;

<span class="hljs-comment">//allocator的声明</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Alloc&gt;
<span class="hljs-keyword">class</span> allocator;

<span class="hljs-comment">//basic_string的声明</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _CharT, <span class="hljs-keyword">typename</span> _Traits = char_traits&lt;_CharT&gt;,
         <span class="hljs-keyword">typename</span> _Alloc = allocator&lt;_CharT&gt; &gt;
<span class="hljs-keyword">class</span> basic_string;

<span class="hljs-comment">//basic_string的typedef</span>
<span class="hljs-keyword">typedef</span> basic_string&lt;<span class="hljs-keyword">char</span>&gt;    <span class="hljs-built_in">string</span>;
<span class="hljs-keyword">typedef</span> basic_string&lt;<span class="hljs-keyword">wchar_t</span>&gt; wstring;</code></pre>

<p>string是basic_string的一个实例。此外还需要char_traits，allocator模板类的支持。allocator的说明见于<a href="http://blog.csdn.net/liuyuan185442111/article/details/45743345" target="_blank">《STL之空间配置器》</a>。</p>



<h2 id="chartraitschartraitsh">char_traits（char_traits.h）</h2>

<p>char_traits是一个模板类，它列出了字符的属性，为字符和字符序列的某些操作提供了定义。其实就是将一些字符的常用操作，如赋值、比较、查找、移动、复制等，封装为函数，以配合STL。 <br>
char_traits是一个struct，它有5个类型定义和若干static函数，它有两个specialization，分别是对char和wchar，char_traits被用于basic_string和input/output stream。</p>

<p>基本上了解<code>template &lt;&gt; struct char_traits&lt;char&gt;;</code>就可以了，因为对wchar的specialization不过是将一些操作由char换成wchar。char_traits将一些操作进行了保守估计，反过来也就是说针对char的specialization进行了一些特别的优化。</p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _CharT&gt; <span class="hljs-keyword">struct</span> char_traits;
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> char_traits&lt;<span class="hljs-keyword">char</span>&gt;;
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> char_traits&lt;<span class="hljs-keyword">wchar_t</span>&gt;;</code></pre>



<h3 id="member-types">member types</h3>

<table>
<thead>
<tr>
  <th>类型</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td>char_type</td>
  <td>模板参数_CharT</td>
</tr>
<tr>
  <td>int_type</td>
  <td>包含所有_CharT类型字符的整型，包括eof()</td>
</tr>
<tr>
  <td>off_type</td>
  <td>A type that behaves like streamoff</td>
</tr>
<tr>
  <td>pos_type</td>
  <td>A type that behaves like streampos</td>
</tr>
<tr>
  <td>state_type</td>
  <td>Multibyte transformation state type, such as mbstate_t</td>
</tr>
</tbody></table>


<h3 id="member-functions">member functions</h3>

<table>
<thead>
<tr>
  <th>函数</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td>eq</td>
  <td>等于操作</td>
</tr>
<tr>
  <td>lt</td>
  <td>小于操作</td>
</tr>
<tr>
  <td>length</td>
  <td>获取字符序列的长度</td>
</tr>
<tr>
  <td>assign</td>
  <td>字符赋值</td>
</tr>
<tr>
  <td>compare</td>
  <td>字符序列比较</td>
</tr>
<tr>
  <td>find</td>
  <td>查找字符第一次出现的位置</td>
</tr>
<tr>
  <td>move</td>
  <td>移动</td>
</tr>
<tr>
  <td>copy</td>
  <td>复制</td>
</tr>
<tr>
  <td>to_char_type</td>
  <td>int_type到char_type</td>
</tr>
<tr>
  <td>to_int_type</td>
  <td>char_type到int_type</td>
</tr>
<tr>
  <td>eq_int_type</td>
  <td>int_type的等于操作</td>
</tr>
<tr>
  <td>eof</td>
  <td>返回End-of-File字符</td>
</tr>
<tr>
  <td>not_eof</td>
  <td>判断是不是End-of-File字符，如果是返回0，如果不是返回本身</td>
</tr>
</tbody></table>




<h3 id="部分源码">部分源码</h3>

<p>下面附上<code>template &lt;&gt; struct char_traits&lt;char&gt;;</code>的源码：</p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-keyword">struct</span> char_traits&lt;<span class="hljs-keyword">char</span>&gt;
{
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span>        char_type;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span>         int_type;
    <span class="hljs-keyword">typedef</span> streampos   pos_type;
    <span class="hljs-keyword">typedef</span> streamoff   off_type;
    <span class="hljs-keyword">typedef</span> mbstate_t   state_type;

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> assign(char_type&amp; c1, <span class="hljs-keyword">const</span> char_type&amp; c2)
    {
        c1 = c2;
    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> eq(<span class="hljs-keyword">const</span> char_type&amp; c1, <span class="hljs-keyword">const</span> char_type&amp; c2)
    {
        <span class="hljs-keyword">return</span> c1 == c2;
    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> lt(<span class="hljs-keyword">const</span> char_type&amp; c1, <span class="hljs-keyword">const</span> char_type&amp; c2)
    {
        <span class="hljs-keyword">return</span> c1 &lt; c2;
    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> compare(<span class="hljs-keyword">const</span> char_type* s1, <span class="hljs-keyword">const</span> char_type* s2, size_t n)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">memcmp</span>(s1, s2, n);
    }

    <span class="hljs-keyword">static</span> size_t length(<span class="hljs-keyword">const</span> char_type* s)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>(s);
    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> char_type *find(<span class="hljs-keyword">const</span> char_type* s, size_t n, <span class="hljs-keyword">const</span> char_type&amp; a)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> char_type*&gt;(<span class="hljs-built_in">memchr</span>(s, a, n));
    }

    <span class="hljs-keyword">static</span> char_type *move(char_type* s1, <span class="hljs-keyword">const</span> char_type* s2, size_t n)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;char_type*&gt;(memmove(s1, s2, n));
    }

    <span class="hljs-keyword">static</span> char_type *copy(char_type* s1, <span class="hljs-keyword">const</span> char_type* s2, size_t n)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;char_type*&gt;(<span class="hljs-built_in">memcpy</span>(s1, s2, n));
    }

    <span class="hljs-keyword">static</span> char_type *assign(char_type* s, size_t n, char_type a)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;char_type*&gt;(<span class="hljs-built_in">memset</span>(s, a, n));
    }

    <span class="hljs-keyword">static</span> char_type to_char_type(<span class="hljs-keyword">const</span> int_type&amp; c)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;char_type&gt;(c);
    }

    <span class="hljs-keyword">static</span> int_type to_int_type(<span class="hljs-keyword">const</span> char_type&amp; c)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;int_type&gt;(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt;(c));
    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> eq_int_type(<span class="hljs-keyword">const</span> int_type&amp; c1, <span class="hljs-keyword">const</span> int_type&amp; c2)
    {
        <span class="hljs-keyword">return</span> c1 == c2;
    }

    <span class="hljs-keyword">static</span> int_type eof()
    {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;int_type&gt;(EOF);
    }

    <span class="hljs-keyword">static</span> int_type not_eof(<span class="hljs-keyword">const</span> int_type&amp; c)
    {
        <span class="hljs-keyword">return</span> (c == eof()) ? <span class="hljs-number">0</span> : c;
    }
};</code></pre>



<h2 id="basicstring">basic_string</h2>

<p>我发现basic_string的实现挺复杂，代码在basic_string.h和basic_string.tcc中。这里就只介绍下basic_string的接口。</p>



<h3 id="成员类型">成员类型</h3>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">public</span>:
<span class="hljs-keyword">typedef</span> _Traits                             traits_type;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> _Traits::char_type         value_type;
<span class="hljs-keyword">typedef</span> _Alloc                              allocator_type;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> _Alloc::size_type          size_type;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> _Alloc::difference_type    difference_type;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> _Alloc::reference          reference;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> _Alloc::const_reference    const_reference;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> _Alloc::pointer            pointer;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> _Alloc::const_pointer      const_pointer;
<span class="hljs-keyword">typedef</span> __normal_iterator&lt;pointer, basic_string&gt;        iterator;
<span class="hljs-keyword">typedef</span> __normal_iterator&lt;const_pointer, basic_string&gt;  const_iterator;
<span class="hljs-keyword">typedef</span> reverse_iterator&lt;const_iterator&gt;    const_reverse_iterator;
<span class="hljs-keyword">typedef</span> reverse_iterator&lt;iterator&gt;          reverse_iterator;</code></pre>



<h3 id="静态常量">静态常量</h3>

<pre><code>public:
static const size_type npos = static_cast&lt;size_type&gt;(-1);
</code></pre>

<p>npos是allocator可以分配的最大字节数。 <br>
当作为basic_string成员函数的长度参数时，表示“直到字符串的结尾”。 <br>
当作为一个返回值时，常表示没有匹配。</p>



<h3 id="成员函数和相关的非成员函数">成员函数和相关的非成员函数</h3>

<p>见这个页面：<a href="http://www.cplusplus.com/reference/string/basic_string/">basic_string</a>。</p></div></body>
</html>