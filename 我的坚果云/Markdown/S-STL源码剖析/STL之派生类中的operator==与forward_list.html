<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STL之派生类中的operator==与forward_list</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><p>list和slist的实现里，节点类型和迭代器类型都使用了分层结构。 <br>
源码剖析189页下方说明operator==()，类比它写出这个例子：</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">struct</span> A
{
    A(<span class="hljs-keyword">int</span> m):a(m) {}
    <span class="hljs-keyword">int</span> a;
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> A&amp; t) <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> (a == t.a);
    }
};

<span class="hljs-keyword">struct</span> B: <span class="hljs-keyword">public</span> A
{
    B(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n):A(m),b(n) {}
    <span class="hljs-keyword">int</span> b;
};

<span class="hljs-keyword">int</span> main()
{
    B b1(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>), b2(<span class="hljs-number">2</span>,<span class="hljs-number">6</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; (b1==b2);
    <span class="hljs-built_in">cout</span> &lt;&lt; b1.<span class="hljs-keyword">operator</span>==(b2);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p>B没有定义operator==()，所以调用的是继承自A的operator==()，参数b2安全转换为A的对象。 <br>
对B的对象执行==，并不会比较B对象里的b，只会比较a。 <br>
某些情况需要这种比较吧。</p>

<p>但是，还是没看到list中迭代器分层的意义，派生类里根本就没有成员变量。</p>



<h2 id="forwardlist">forward_list</h2>

<p>slist是一个单向链表，c++11里提供了forward_list（在&lt;forward_list&gt;中），二者差不多。</p>

<p>forward_list提供了一个特殊节点（并不是指针），这个节点并不用来存储数据，只用来索引。 <br>
begin()返回的是这个节点的next，这样在begin()插入也很容易完成。</p>

<p>对forward_list执行insert和erase会特别耗时，因为二者都是在position之前进行操作，只能从头节点开始遍历到position。 <br>
所以forward_list提供了insert_after()和erase_after()来在position之后进行操作。 <br>
还提供了splice_after()来在position之后进行拼接操作。</p>

<p>为了配合这些after操作，forward_list提供了before_begin()来获得begin()之前的节点：</p>

<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">// forward_list::before_begin</span>
<span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;forward_list&gt;</span>

<span class="hljs-keyword">int</span> main ()
{
  <span class="hljs-built_in">std</span>::forward_list&lt;<span class="hljs-keyword">int</span>&gt; mylist = {<span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>};

  mylist.insert_after ( mylist.before_begin(), <span class="hljs-number">11</span> );  <span class="hljs-comment">// 11 20 30 40 50</span>

  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"mylist contains:"</span>;
  <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span>&amp; x: mylist ) <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; x;
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">'\n'</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p>其他内容请参考：<a href="http://www.cplusplus.com/reference/forward_list/forward_list/" target="_blank">http://www.cplusplus.com/reference/forward_list/forward_list/</a></p></div></body>
</html>