<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STL之模板的知识</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><p>C++标准库是离不开模板的，STL占了C++标准库80%以上，下面有一些模板的知识。</p>

<h2 id="非类型的模板参数的限制">非类型的模板参数的限制</h2>

<p>非类型的模板参数必须是常量表达式或一个具有外部链接属性的变量的地址（根据别人文章和编译器提示做出的推断）。比如：</p>



<pre class="prettyprint"><code class=" hljs vala">template &lt;<span class="hljs-keyword">int</span> inst&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> {</span>};
MyClass&lt;<span class="hljs-number">5</span>&gt; x;</code></pre>



<h2 id="implicit-instantiate隐式实例化">Implicit Instantiate/隐式实例化</h2>

<p>隐式实例化发生在函数模板的调用过程中，或使用类模板实例化对象的过程中。</p>

<p>在编译器可以推断出函数模板的模板参数时，模板参数可以省略。 <br>
编译器是无法推断出类模板的模板参数的，所以不能省略模板参数。 <br>
后面的显示实例化和具体化也是这样。</p>



<h2 id="explicit-instantiate显式实例化">Explicit Instantiate/显式实例化</h2>

<p>要显式实例化函数模板，请在 template 关键字后接函数的声明（不是定义），且函数标识符后接模板参数：</p>

<pre><code>template float twice&lt;float&gt;(float original);
</code></pre>

<p>在编译器可以推断出模板参数时，模板参数可以省略：</p>

<pre><code>template float twice(float original);
</code></pre>

<p>要显式实例化类模板，请在 template 关键字后接类的声明（不是定义），且在类标识符后接模板参数：</p>

<pre><code>template class Array&lt;char&gt;;
</code></pre>

<p>显式实例化类时，所有的类成员也必须实例化。</p>



<h2 id="specialize特殊化具体化">Specialize/特殊化/具体化</h2>

<p>要特殊化函数模板，请在 template&lt;&gt; 关键字后接函数的定义，且在函数标识符后接模板参数：</p>

<pre><code>template&lt;&gt; void swap&lt;job&gt;(job &amp;a, job &amp;b) {……}
</code></pre>

<p>在编译器可以推断出模板参数时，模板参数可以省略：</p>

<pre><code>template&lt;&gt; void swap(job &amp;a, job &amp;b) {……}
</code></pre>

<p>要特殊化类模板，请在 template&lt;&gt; 关键字后接类的定义，且在类标识符后接模板参数：</p>

<pre><code>template&lt;&gt; class Array&lt;char&gt; {……};
</code></pre>



<h2 id="其他">其他</h2>

<p>不能对函数模板进行局部特化，因为他们认为可以通过函数重载来解决。</p>

<p>c++必知必会 item 48 <br>
可以只特化主模板成员函数的一个子集，这样在实例化时，类还是选用的主模板，但类的成员函数却可以选用特化版本。 <br>
但是，特化成员函数的接口必须和主模板提供的接口精确匹配。</p>

<p>c++必知必会 item 55 模板的模板参数 <br>
模板的参数不仅可以是普通类型、类，还可以是模板 <br>
stl中list的声明是这样的：</p>

<pre><code>template &lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt; &gt;
class list;
</code></pre>

<p>定义一个list得是这样：</p>

<pre><code>list &lt;int, std::allocator&lt;int&gt; &gt; m;
</code></pre>

<p>得手动协调元素和容器的类型，如果换成下面的方式：</p>

<pre><code>template &lt;typename T, template &lt;typename&gt; class Alloc=std::allocator&gt;
struct List
{
};
</code></pre>

<p>Alloc是需要一个模板参数的模板类，定义简单了一些：</p>

<pre><code>List&lt;int, std::allocator&gt; n;
</code></pre>

<hr>

<p>学习STL（c++ 98）的主要参考： <br>
- <a href="http://ftp.gnu.org/gnu/gcc/gcc-3.0/">gcc 3.0源码</a> <br>
- 部分gcc 4.7.1源码 <br>
- <a href="http://www.cplusplus.com/reference/">cplusplus</a> <br>
- 《STL源码剖析》 <br>
- Internet，搜索引擎，他人博客</p>

<p>虽然本系列名为STL，但也涉及标准库的其他内容。 <br>
<code>&lt;limits&gt;</code>内容与c标准库中的<code>&lt;limits.h&gt;和&lt;float.h&gt;</code>相似，<code>&lt;locale&gt;</code>内容与c标准库中的<code>&lt;locale.h&gt;</code>相似，感觉用的也不多，先放一边。</p>

<p>IO库使用也不频繁，这里粗略说一下，与输入输出相关的头文件有：</p>

<table>
<thead>
<tr>
  <th>文件名</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td>iosfwd</td>
  <td>I/O功能的前导声明</td>
</tr>
<tr>
  <td>iostream</td>
  <td>标准iostream对象和操作</td>
</tr>
<tr>
  <td>sstream</td>
  <td>以串作为I/O对象的流</td>
</tr>
<tr>
  <td>fstream</td>
  <td>以文件作为I/O对象的流</td>
</tr>
<tr>
  <td>ios</td>
  <td>iostream基类</td>
</tr>
<tr>
  <td>streambuf</td>
  <td>流缓冲区</td>
</tr>
<tr>
  <td>istream</td>
  <td>输入流模板</td>
</tr>
<tr>
  <td>ostream</td>
  <td>输出流模板</td>
</tr>
<tr>
  <td>iomanip</td>
  <td>操控符</td>
</tr>
</tbody></table>


<p>附一篇文章<a href="http://www.cppblog.com/Solstice/archive/2011/07/17/151224.html">《C++ 工程实践(7)：iostream 的用途与局限》</a>作参考。</p></div></body>
</html>