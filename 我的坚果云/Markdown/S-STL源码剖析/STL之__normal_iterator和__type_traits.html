<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STL之__normal_iterator和__type_traits</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><p>__normal_iterator和__type_traits都是模板类，它们不属于c++标准里，而是sgi自己扩展的。</p>



<h2 id="normaliterator">__normal_iterator</h2>

<p>__normal_iterator的主要目的是将指针, 转化为类型是class的迭代器。做的事情也就是把指针的各种操作封装为函数。basic_string中就使用了它：</p>

<pre><code>typedef __normal_iterator&lt;pointer, basic_string&gt;        iterator;
typedef __normal_iterator&lt;const_pointer, basic_string&gt;  const_iterator;
</code></pre>

<p>源代码在stl_iterator.h中：</p>

<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Iterator, <span class="hljs-keyword">typename</span> _Container&gt;
<span class="hljs-keyword">class</span> __normal_iterator
    : <span class="hljs-keyword">public</span> iterator&lt;iterator_traits&lt;_Iterator&gt;::iterator_category,
      iterator_traits&lt;_Iterator&gt;::value_type,
      iterator_traits&lt;_Iterator&gt;::difference_type,
      iterator_traits&lt;_Iterator&gt;::pointer,
      iterator_traits&lt;_Iterator&gt;::reference&gt;
{
<span class="hljs-keyword">protected</span>:
    _Iterator _M_current;

<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> __normal_iterator&lt;_Iterator, _Container&gt; normal_iterator_type;
    <span class="hljs-keyword">typedef</span> iterator_traits&lt;_Iterator&gt;              __traits_type;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> __traits_type::iterator_category   iterator_category;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> __traits_type::value_type      value_type;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> __traits_type::difference_type     difference_type;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> __traits_type::pointer             pointer;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> __traits_type::reference       reference;

    __normal_iterator() : _M_current(_Iterator()) { }

    <span class="hljs-keyword">explicit</span> __normal_iterator(<span class="hljs-keyword">const</span> _Iterator&amp; __i) : _M_current(__i) { }

    <span class="hljs-comment">// Allow iterator to const_iterator conversion</span>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Iter&gt;
    <span class="hljs-keyword">inline</span> __normal_iterator(<span class="hljs-keyword">const</span> __normal_iterator&lt;_Iter, _Container&gt;&amp; __i)
        : _M_current(__i.base()) { }

    <span class="hljs-comment">// Forward iterator requirements</span>
    reference
    <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> *_M_current;
    }

    pointer
    <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> _M_current;
    }

    normal_iterator_type&amp;
    <span class="hljs-keyword">operator</span>++()
    {
        ++_M_current;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }

    normal_iterator_type
    <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>)
    {
        <span class="hljs-keyword">return</span> __normal_iterator(_M_current++);
    }

    <span class="hljs-comment">// Bidirectional iterator requirements</span>
    normal_iterator_type&amp;
    <span class="hljs-keyword">operator</span>--()
    {
        --_M_current;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }

    normal_iterator_type
    <span class="hljs-keyword">operator</span>--(<span class="hljs-keyword">int</span>)
    {
        <span class="hljs-keyword">return</span> __normal_iterator(_M_current--);
    }

    <span class="hljs-comment">// Random access iterator requirements</span>
    reference
    <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">const</span> difference_type&amp; __n) <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> _M_current[__n];
    }

    normal_iterator_type&amp;
    <span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> difference_type&amp; __n)
    {
        _M_current += __n;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }

    normal_iterator_type
    <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> difference_type&amp; __n) <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> __normal_iterator(_M_current + __n);
    }

    normal_iterator_type&amp;
    <span class="hljs-keyword">operator</span>-=(<span class="hljs-keyword">const</span> difference_type&amp; __n)
    {
        _M_current -= __n;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }

    normal_iterator_type
    <span class="hljs-keyword">operator</span>-(<span class="hljs-keyword">const</span> difference_type&amp; __n) <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> __normal_iterator(_M_current - __n);
    }

    difference_type
    <span class="hljs-keyword">operator</span>-(<span class="hljs-keyword">const</span> normal_iterator_type&amp; __i) <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> _M_current - __i._M_current;
    }

    <span class="hljs-keyword">const</span> _Iterator&amp;
    base() <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> _M_current;
    }
};

<span class="hljs-comment">// forward iterator requirements</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _IteratorL, <span class="hljs-keyword">typename</span> _IteratorR, <span class="hljs-keyword">typename</span> _Container&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span>
<span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> __normal_iterator&lt;_IteratorL, _Container&gt;&amp; __lhs,
           <span class="hljs-keyword">const</span> __normal_iterator&lt;_IteratorR, _Container&gt;&amp; __rhs)
{
    <span class="hljs-keyword">return</span> __lhs.base() == __rhs.base();
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _IteratorL, <span class="hljs-keyword">typename</span> _IteratorR, <span class="hljs-keyword">typename</span> _Container&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span>
<span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> __normal_iterator&lt;_IteratorL, _Container&gt;&amp; __lhs,
           <span class="hljs-keyword">const</span> __normal_iterator&lt;_IteratorR, _Container&gt;&amp; __rhs)
{
    <span class="hljs-keyword">return</span> !(__lhs == __rhs);
}

<span class="hljs-comment">// random access iterator requirements</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _IteratorL, <span class="hljs-keyword">typename</span> _IteratorR, <span class="hljs-keyword">typename</span> _Container&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span>
<span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> __normal_iterator&lt;_IteratorL, _Container&gt;&amp; __lhs,
          <span class="hljs-keyword">const</span> __normal_iterator&lt;_IteratorR, _Container&gt;&amp; __rhs)
{
    <span class="hljs-keyword">return</span> __lhs.base() &lt; __rhs.base();
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _IteratorL, <span class="hljs-keyword">typename</span> _IteratorR, <span class="hljs-keyword">typename</span> _Container&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span>
<span class="hljs-keyword">operator</span>&gt;(<span class="hljs-keyword">const</span> __normal_iterator&lt;_IteratorL, _Container&gt;&amp; __lhs,
          <span class="hljs-keyword">const</span> __normal_iterator&lt;_IteratorR, _Container&gt;&amp; __rhs)
{
    <span class="hljs-keyword">return</span> __rhs &lt; __lhs;
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _IteratorL, <span class="hljs-keyword">typename</span> _IteratorR, <span class="hljs-keyword">typename</span> _Container&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span>
<span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-keyword">const</span> __normal_iterator&lt;_IteratorL, _Container&gt;&amp; __lhs,
           <span class="hljs-keyword">const</span> __normal_iterator&lt;_IteratorR, _Container&gt;&amp; __rhs)
{
    <span class="hljs-keyword">return</span> !(__rhs &lt; __lhs);
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _IteratorL, <span class="hljs-keyword">typename</span> _IteratorR, <span class="hljs-keyword">typename</span> _Container&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span>
<span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-keyword">const</span> __normal_iterator&lt;_IteratorL, _Container&gt;&amp; __lhs,
           <span class="hljs-keyword">const</span> __normal_iterator&lt;_IteratorR, _Container&gt;&amp; __rhs)
{
    <span class="hljs-keyword">return</span> !(__lhs &lt; __rhs);
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Iterator, <span class="hljs-keyword">typename</span> _Container&gt;
<span class="hljs-keyword">inline</span> __normal_iterator&lt;_Iterator, _Container&gt;
<span class="hljs-keyword">operator</span>+(__normal_iterator&lt;_Iterator, _Container&gt;::difference_type __n,
          <span class="hljs-keyword">const</span> __normal_iterator&lt;_Iterator, _Container&gt;&amp; __i)
{
    <span class="hljs-keyword">return</span> __normal_iterator&lt;_Iterator, _Container&gt;(__i.base() + __n);
}</code></pre>



<h2 id="typetraits">type_traits</h2>

<p>sgi将之定义在type_traits.h中。 <br>
type_traits用来提取type的特性：是否具备non-trivial默认构造函数，是否具备non-trivial拷贝构造函数，是否具备non-trivial赋值操作符，是否具备non-trivial析构函数。所谓trivial，是指不发生获取和释放内存的操作或操作其他数据的操作，这样对于构造和赋值就可以使用快速的memcpy()或memmove()，对于析构就可以直接忽略。 <br>
在uninitialized_copy()等内存基本处理工具里用到了type_traits。 <br>
POD：Plain Old Data，基本的数据类型都是POD，比如int，struct，指针等。POD的默认构造，拷贝构造，赋值，析构都是trivial的。 <br>
模板类的5个类型都被定义为__false_type，假定这几个函数都是non-trivial，然后针对常见的基本数据类型做了特化，我省略了很多，因为都是类似的。</p>

<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">bool</span> _Truth&gt; <span class="hljs-keyword">struct</span> <span class="hljs-keyword">_Bool</span> {};
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">_Bool</span>&lt;<span class="hljs-keyword">true</span>&gt;  __true_type;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">_Bool</span>&lt;<span class="hljs-keyword">false</span>&gt; __false_type;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _Tp&gt;
<span class="hljs-keyword">struct</span> __type_traits
{
    <span class="hljs-keyword">typedef</span> __true_type     this_dummy_member_must_be_first;
    <span class="hljs-comment">/* Do not remove this member. It informs a compiler which
       automatically specializes __type_traits that this
       __type_traits template is special. It just makes sure that
       things work if an implementation is using a template
       called __type_traits for something unrelated. */</span>

    <span class="hljs-comment">/* The following restrictions should be observed for the sake of
       compilers which automatically produce type specific specializations
       of this class:
           - You may reorder the members below if you wish
           - You may remove any of the members below if you wish
           - You must not rename members without making the corresponding
             name change in the compiler
           - Members you add will be treated like regular members unless
             you add the appropriate support in the compiler. */</span>


    <span class="hljs-keyword">typedef</span> __false_type    has_trivial_default_constructor;
    <span class="hljs-keyword">typedef</span> __false_type    has_trivial_copy_constructor;
    <span class="hljs-keyword">typedef</span> __false_type    has_trivial_assignment_operator;
    <span class="hljs-keyword">typedef</span> __false_type    has_trivial_destructor;
    <span class="hljs-keyword">typedef</span> __false_type    is_POD_type;
};


<span class="hljs-comment">// Provide some specializations.</span>
<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> __type_traits&lt;<span class="hljs-keyword">bool</span>&gt;
{
    <span class="hljs-keyword">typedef</span> __true_type    has_trivial_default_constructor;
    <span class="hljs-keyword">typedef</span> __true_type    has_trivial_copy_constructor;
    <span class="hljs-keyword">typedef</span> __true_type    has_trivial_assignment_operator;
    <span class="hljs-keyword">typedef</span> __true_type    has_trivial_destructor;
    <span class="hljs-keyword">typedef</span> __true_type    is_POD_type;
};

<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> __type_traits&lt;<span class="hljs-keyword">char</span>&gt;
{
    <span class="hljs-keyword">typedef</span> __true_type    has_trivial_default_constructor;
    <span class="hljs-keyword">typedef</span> __true_type    has_trivial_copy_constructor;
    <span class="hljs-keyword">typedef</span> __true_type    has_trivial_assignment_operator;
    <span class="hljs-keyword">typedef</span> __true_type    has_trivial_destructor;
    <span class="hljs-keyword">typedef</span> __true_type    is_POD_type;
};

<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> __type_traits&lt;<span class="hljs-keyword">int</span>&gt;
{
    <span class="hljs-keyword">typedef</span> __true_type    has_trivial_default_constructor;
    <span class="hljs-keyword">typedef</span> __true_type    has_trivial_copy_constructor;
    <span class="hljs-keyword">typedef</span> __true_type    has_trivial_assignment_operator;
    <span class="hljs-keyword">typedef</span> __true_type    has_trivial_destructor;
    <span class="hljs-keyword">typedef</span> __true_type    is_POD_type;
};

<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> __type_traits&lt;<span class="hljs-keyword">float</span>&gt;
{
    <span class="hljs-keyword">typedef</span> __true_type    has_trivial_default_constructor;
    <span class="hljs-keyword">typedef</span> __true_type    has_trivial_copy_constructor;
    <span class="hljs-keyword">typedef</span> __true_type    has_trivial_assignment_operator;
    <span class="hljs-keyword">typedef</span> __true_type    has_trivial_destructor;
    <span class="hljs-keyword">typedef</span> __true_type    is_POD_type;
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _Tp&gt;
<span class="hljs-keyword">struct</span> __type_traits&lt;_Tp*&gt;
{
    <span class="hljs-keyword">typedef</span> __true_type    has_trivial_default_constructor;
    <span class="hljs-keyword">typedef</span> __true_type    has_trivial_copy_constructor;
    <span class="hljs-keyword">typedef</span> __true_type    has_trivial_assignment_operator;
    <span class="hljs-keyword">typedef</span> __true_type    has_trivial_destructor;
    <span class="hljs-keyword">typedef</span> __true_type    is_POD_type;
};</code></pre></div></body>
</html>