<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STL容器之bitset</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><p>bitset用来方便地管理一系列的bit位，它并不是一个标准的容器。 <br>
bitset定义于&lt;bitset&gt;中：</p>

<pre><code>template &lt;size_t N&gt; class bitset;
</code></pre>



<h2 id="bitset的接口">bitset的接口</h2>

<p>构造函数</p>

<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">// 默认构造函数, 初始化为全0</span>
<span class="hljs-built_in">bitset</span>();
<span class="hljs-comment">// 以val初始化各比特位</span>
<span class="hljs-built_in">bitset</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> val);
<span class="hljs-comment">// 用str从pos开始的n个字符初始化bitset的前n个比特, 这n个字符必须是0或1,</span>
<span class="hljs-comment">// 如果含有其他字符, 抛出invalid_argument异常,</span>
<span class="hljs-comment">// pos如果超出str范围抛出out_of_range异常</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> charT, <span class="hljs-keyword">class</span> traits, <span class="hljs-keyword">class</span> Alloc&gt;
  <span class="hljs-keyword">explicit</span> <span class="hljs-built_in">bitset</span> (<span class="hljs-keyword">const</span> basic_string&lt;charT,traits,Alloc&gt;&amp; str,
    <span class="hljs-keyword">typename</span> basic_string&lt;charT,traits,Alloc&gt;::size_type pos = <span class="hljs-number">0</span>,
    <span class="hljs-keyword">typename</span> basic_string&lt;charT,traits,Alloc&gt;::size_type n =
      basic_string&lt;charT,traits,Alloc&gt;::npos);
<span class="hljs-comment">//没有显式的复制构造函数和赋值运算符，因为默认的就足够了</span></code></pre>

<p>运算符</p>

<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">// 成员函数</span>
<span class="hljs-built_in">bitset</span>&amp; <span class="hljs-keyword">operator</span>&amp;=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">bitset</span>&amp; rhs);
<span class="hljs-built_in">bitset</span>&amp; <span class="hljs-keyword">operator</span>|=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">bitset</span>&amp; rhs);
<span class="hljs-built_in">bitset</span>&amp; <span class="hljs-keyword">operator</span>^=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">bitset</span>&amp; rhs);
<span class="hljs-built_in">bitset</span>&amp; <span class="hljs-keyword">operator</span>&lt;&lt;=(size_t pos);
<span class="hljs-built_in">bitset</span>&amp; <span class="hljs-keyword">operator</span>&gt;&gt;=(size_t pos);
<span class="hljs-built_in">bitset</span> <span class="hljs-keyword">operator</span>~() <span class="hljs-keyword">const</span>;
<span class="hljs-built_in">bitset</span> <span class="hljs-keyword">operator</span>&lt;&lt;(size_t pos) <span class="hljs-keyword">const</span>;
<span class="hljs-built_in">bitset</span> <span class="hljs-keyword">operator</span>&gt;&gt;(size_t pos) <span class="hljs-keyword">const</span>;
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> <span class="hljs-built_in">bitset</span>&amp; rhs) <span class="hljs-keyword">const</span>;
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">bitset</span>&amp; rhs) <span class="hljs-keyword">const</span>;
<span class="hljs-comment">// 非成员函数</span>
<span class="hljs-keyword">template</span> &lt;size_t N&gt;
  <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;N&gt;</span> <span class="hljs-keyword">operator</span>&amp;(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;N&gt;</span>&amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;N&gt;</span>&amp; rhs);
<span class="hljs-keyword">template</span> &lt;size_t N&gt;
  <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;N&gt;</span> <span class="hljs-keyword">operator</span>|(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;N&gt;</span>&amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;N&gt;</span>&amp; rhs);
<span class="hljs-keyword">template</span> &lt;size_t N&gt;
  <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;N&gt;</span> <span class="hljs-keyword">operator</span>^(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;N&gt;</span>&amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;N&gt;</span>&amp; rhs);
<span class="hljs-comment">// 输入输出</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> charT, <span class="hljs-keyword">class</span> traits, size_t N&gt;
  basic_istream&lt;charT, traits&gt;&amp;
    <span class="hljs-keyword">operator</span>&gt;&gt; (basic_istream&lt;charT,traits&gt;&amp; is, <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;N&gt;</span>&amp; rhs);
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> charT, <span class="hljs-keyword">class</span> traits, size_t N&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
    <span class="hljs-keyword">operator</span>&lt;&lt; (basic_ostream&lt;charT,traits&gt;&amp; os, <span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;N&gt;</span>&amp; rhs);</code></pre>

<p>成员访问</p>

<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">// 除了不进行越界检查, 与test()行为相同</span>
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>[](size_t pos) <span class="hljs-keyword">const</span>;
<span class="hljs-comment">// 返回一个引用, 可进行赋值操作</span>
reference <span class="hljs-keyword">operator</span>[](size_t pos);
<span class="hljs-comment">// 返回bitset中1的个数</span>
size_t count() <span class="hljs-keyword">const</span>;
<span class="hljs-comment">// 返回bitset的大小</span>
size_t size() <span class="hljs-keyword">const</span>;
<span class="hljs-comment">// 检测是否为1, 可能会抛出out_of_range异常</span>
<span class="hljs-keyword">bool</span> test(size_t pos) <span class="hljs-keyword">const</span>;
<span class="hljs-comment">// 如存在任意一个为1的位则返回true</span>
<span class="hljs-keyword">bool</span> any() <span class="hljs-keyword">const</span>;
<span class="hljs-comment">// 全零返回true, 等价于!any();</span>
<span class="hljs-keyword">bool</span> none() <span class="hljs-keyword">const</span>;</code></pre>

<p>位操作</p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">// 将所有位置为1</span>
<span class="hljs-built_in">bitset</span>&amp; <span class="hljs-built_in">set</span>();
<span class="hljs-comment">// 将相应位置为val, 可能会抛出out_of_range异常</span>
<span class="hljs-built_in">bitset</span>&amp; <span class="hljs-built_in">set</span>(size_t pos, <span class="hljs-keyword">bool</span> val = <span class="hljs-keyword">true</span>);
<span class="hljs-comment">// 将所有位清零</span>
<span class="hljs-built_in">bitset</span>&amp; reset();
<span class="hljs-comment">// 将相应位清零, 可能会抛出out_of_range异常</span>
<span class="hljs-built_in">bitset</span>&amp; reset(size_t pos);
<span class="hljs-comment">// 翻转所有位</span>
<span class="hljs-built_in">bitset</span>&amp; flip();
<span class="hljs-comment">// 翻转相应位, 可能会抛出out_of_range异常</span>
<span class="hljs-built_in">bitset</span>&amp; flip(size_t pos);</code></pre>

<p>转换</p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">// 返回一个01字符串, 与&lt;&lt;运算符产生的输出相同</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> charT, <span class="hljs-keyword">class</span> traits, <span class="hljs-keyword">class</span> Alloc&gt;
  basic_string&lt;charT,traits,Alloc&gt; to_string() <span class="hljs-keyword">const</span>;
<span class="hljs-comment">// 返回一个unsigned long, 如果bitset太大以至于无法转换, 抛出overflow_error异常</span>
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> to_ulong() <span class="hljs-keyword">const</span>;</code></pre>



<h2 id="解析">解析</h2>

<h3 id="内部数据结构">内部数据结构</h3>

<p>bitset内部以unsigned long数组来存储各比特位，所以如果unsigned long占4字节的话，sizeof(bitset对象)的值总是4的整数倍。哦，sizeof(bitset&lt;0&gt;)除外，此时unsigned long数组长度为0，bitset&lt;0&gt;就是一个没有数据成员的类，其大小是1。 <br>
在sgi的实现里，定义了_Base_bitset的模板类，bitset私有继承此类，bitset的大部分操作都在_Base_bitset里完成，unsigned long数组也定义在_Base_bitset里：</p>

<pre><code>unsigned long M_w[Nw];
</code></pre>

<p>其中Nw是所需unsigned long的数目，可由(n+31)/32算得。 <br>
M_w数组的下标越大，所表示比特序列的位数越高。 <br>
_Base_bitset还针对只有一个unsigned long的情况进行了特殊化，提高了效率。</p>

<h3 id="查表法">查表法</h3>

<p>count()内部使用了查表法。先定义了一个256长度的unsigned char数组，用来存储所有unsigned char对应的1的个数。将每个unsigned long分成4个unsigned char，然后以unsigned char为数组下标直接可获得1的个数，依次累加即可获得最终结果。</p>



<h3 id="未使用部分">未使用部分</h3>

<p>由于unsigned long数组不一定恰好用完，未使用部分由一个内部函数进行清零操作。在构造对象，或进行有可能更改未使用部分的操作时，都调用了此函数。所以，未使用的部分始终是0。</p>



<h2 id="reference类型">reference类型</h2>

<p>bitset内部定义了一个reference类，它是operator[]其中一个版本的返回值，operator[]有两个版本：</p>

<pre><code>bool operator[] (size_t pos) const;
reference operator[] (size_t pos);
</code></pre>

<p>第一个版本只读，第二个版本可以写。reference就是为了实现operator[]写的功能。</p>

<pre><code>reference operator[](size_t pos) { return reference(*this, pos); }
</code></pre>

<p>reference有一个unsigned long *M_wp的数据成员，通过</p>

<pre><code>reference( bitset&amp; b, size_t pos );
</code></pre>

<p>进行构造时，M_wp会指向pos对应的那个unsigned long，这样就可以通过M_wp来对b进行操作了。 <br>
除了可以对b[i]进行赋值操作，还可以对它进行<code>~b[i]和b[i].flip()</code>。</p>

<h2 id="完整源码摘自stdbitseth有修改">完整源码（摘自std_bitset.h，有修改）</h2>

<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">// 内部以unsigned long来存储比特位, 所以占用字节数是sizeof(unsigned long)的整数倍</span>
<span class="hljs-comment">// 大小为n的bitset占用的unsigned long的数量为__BITSET_WORDS(n)</span>
<span class="hljs-comment">// 在unsigned long占4字节的机器, bitset&lt;0&gt;占1字节, bitset&lt;1&gt;占4字节, bitset&lt;32&gt;占4字节, bitset&lt;33&gt;占8字节</span>
<span class="hljs-comment">// 未使用比特始终是0</span>
<span class="hljs-preprocessor">#define _GLIBCPP_BITSET_BITS_PER_WORD (CHAR_BIT*sizeof(unsigned long))</span>
<span class="hljs-preprocessor">#define __BITSET_WORDS(__n) \</span>
 ((__n) &lt; <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : ((__n) + _GLIBCPP_BITSET_BITS_PER_WORD - <span class="hljs-number">1</span>)/_GLIBCPP_BITSET_BITS_PER_WORD)
<span class="hljs-comment">/**
// gcc 4.7.1里是这样的
#define _GLIBCXX_BITSET_WORDS(__n) \
  ((__n) / _GLIBCXX_BITSET_BITS_PER_WORD + \
   ((__n) % _GLIBCXX_BITSET_BITS_PER_WORD == 0 ? 0 : 1))

   区别在于当n为0的时候, 前者是1, 后者是0
   实际上, 当n为0的时, _Base_bitset的_M_w数组大小为0即可, 此时对象占用空间为1
   不做n&lt;1的判断即等价:
   #define __BITSET_WORDS(__n) \
 (((__n) + _GLIBCPP_BITSET_BITS_PER_WORD - 1)/_GLIBCPP_BITSET_BITS_PER_WORD)
*/</span>

<span class="hljs-comment">// 查表法获得unsigned char中1的个数, 可在哪初始化的, 我咋没找着</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">bool</span> __dummy&gt;
<span class="hljs-keyword">struct</span> _Bit_count {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> _S_bit_count[<span class="hljs-number">256</span>];
};

<span class="hljs-comment">// Mapping from 8 bit unsigned integers to the index of the first one bit</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">bool</span> __dummy&gt;
<span class="hljs-keyword">struct</span> _First_one {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> _S_first_one[<span class="hljs-number">256</span>];
};


<span class="hljs-comment">// _Nw是bitset占用Word的个数</span>
<span class="hljs-keyword">template</span>&lt;size_t _Nw&gt;
<span class="hljs-keyword">struct</span> _Base_bitset {
  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> _WordT;

  _WordT _M_w[_Nw]; <span class="hljs-comment">// 实际的存储位置, 从低位到高位</span>

  _Base_bitset( <span class="hljs-keyword">void</span> ) { _M_do_reset(); }
  _Base_bitset(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> __val) {
    _M_do_reset();
    _M_w[<span class="hljs-number">0</span>] = __val;
  }
  <span class="hljs-keyword">void</span> _M_do_reset() { <span class="hljs-built_in">memset</span>(_M_w, <span class="hljs-number">0</span>, _Nw * <span class="hljs-keyword">sizeof</span>(_WordT)); }


  <span class="hljs-keyword">static</span> size_t _S_whichword( size_t __pos )
    { <span class="hljs-keyword">return</span> __pos / _GLIBCPP_BITSET_BITS_PER_WORD; }
  <span class="hljs-keyword">static</span> size_t _S_whichbyte( size_t __pos )
    { <span class="hljs-keyword">return</span> (__pos % _GLIBCPP_BITSET_BITS_PER_WORD) / CHAR_BIT; }
  <span class="hljs-keyword">static</span> size_t _S_whichbit( size_t __pos )
    { <span class="hljs-keyword">return</span> __pos % _GLIBCPP_BITSET_BITS_PER_WORD; }
    <span class="hljs-comment">// 获得掩码, 以Word为单位操作</span>
  <span class="hljs-keyword">static</span> _WordT _S_maskbit( size_t __pos )
    { <span class="hljs-keyword">return</span> (<span class="hljs-keyword">static_cast</span>&lt;_WordT&gt;(<span class="hljs-number">1</span>)) &lt;&lt; _S_whichbit(__pos); }

  _WordT&amp; _M_getword(size_t __pos)       { <span class="hljs-keyword">return</span> _M_w[_S_whichword(__pos)]; }
  _WordT  _M_getword(size_t __pos) <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> _M_w[_S_whichword(__pos)]; }

  <span class="hljs-comment">// 最高位Word</span>
  _WordT&amp; _M_hiword()       { <span class="hljs-keyword">return</span> _M_w[_Nw - <span class="hljs-number">1</span>]; }
  _WordT  _M_hiword() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> _M_w[_Nw - <span class="hljs-number">1</span>]; }

  <span class="hljs-keyword">void</span> _M_do_and(<span class="hljs-keyword">const</span> _Base_bitset&lt;_Nw&gt;&amp; __x) {
    <span class="hljs-keyword">for</span> ( size_t __i = <span class="hljs-number">0</span>; __i &lt; _Nw; __i++ ) {
      _M_w[__i] &amp;= __x._M_w[__i];
    }
  }

  <span class="hljs-keyword">void</span> _M_do_or(<span class="hljs-keyword">const</span> _Base_bitset&lt;_Nw&gt;&amp; __x) {
    <span class="hljs-keyword">for</span> ( size_t __i = <span class="hljs-number">0</span>; __i &lt; _Nw; __i++ ) {
      _M_w[__i] |= __x._M_w[__i];
    }
  }

  <span class="hljs-keyword">void</span> _M_do_xor(<span class="hljs-keyword">const</span> _Base_bitset&lt;_Nw&gt;&amp; __x) {
    <span class="hljs-keyword">for</span> ( size_t __i = <span class="hljs-number">0</span>; __i &lt; _Nw; __i++ ) {
      _M_w[__i] ^= __x._M_w[__i];
    }
  }

  <span class="hljs-keyword">void</span> _M_do_left_shift(size_t __shift);
  <span class="hljs-keyword">void</span> _M_do_right_shift(size_t __shift);

  <span class="hljs-keyword">void</span> _M_do_flip() {
    <span class="hljs-keyword">for</span> ( size_t __i = <span class="hljs-number">0</span>; __i &lt; _Nw; __i++ ) {
      _M_w[__i] = ~_M_w[__i];
    }
  }

  <span class="hljs-keyword">void</span> _M_do_set() {
    <span class="hljs-keyword">for</span> ( size_t __i = <span class="hljs-number">0</span>; __i &lt; _Nw; __i++ ) {
      _M_w[__i] = ~<span class="hljs-keyword">static_cast</span>&lt;_WordT&gt;(<span class="hljs-number">0</span>);
    }
  }

  <span class="hljs-keyword">bool</span> _M_is_equal(<span class="hljs-keyword">const</span> _Base_bitset&lt;_Nw&gt;&amp; __x) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">for</span> (size_t __i = <span class="hljs-number">0</span>; __i &lt; _Nw; ++__i) {
      <span class="hljs-keyword">if</span> (_M_w[__i] != __x._M_w[__i])
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
  }

  <span class="hljs-keyword">bool</span> _M_is_any() <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">for</span> ( size_t __i = <span class="hljs-number">0</span>; __i &lt; _Nw; __i++ ) {
      <span class="hljs-keyword">if</span> ( _M_w[__i] != <span class="hljs-keyword">static_cast</span>&lt;_WordT&gt;(<span class="hljs-number">0</span>) )
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
  }

  <span class="hljs-comment">// 统计1的个数, 直接强转成char*, 灵活极了</span>
  size_t _M_do_count() <span class="hljs-keyword">const</span> {
    size_t __result = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>* __byte_ptr = (<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)_M_w;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>* __end_ptr = (<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)(_M_w+_Nw);

    <span class="hljs-keyword">while</span> ( __byte_ptr &lt; __end_ptr ) {
      <span class="hljs-comment">// 用查表法得到unsigned char中1的个数</span>
      __result += _Bit_count&lt;<span class="hljs-keyword">true</span>&gt;::_S_bit_count[*__byte_ptr];
      __byte_ptr++;
    }
    <span class="hljs-keyword">return</span> __result;
  }

  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> _M_do_to_ulong() <span class="hljs-keyword">const</span>;

  <span class="hljs-comment">// find first "on" bit</span>
  size_t _M_do_find_first(size_t __not_found) <span class="hljs-keyword">const</span>;

  <span class="hljs-comment">// find the next "on" bit that follows "prev"</span>
  size_t _M_do_find_next(size_t __prev, size_t __not_found) <span class="hljs-keyword">const</span>;
};


<span class="hljs-comment">// _Base_bitset的非内联函数定义</span>
<span class="hljs-keyword">template</span>&lt;size_t _Nw&gt;
<span class="hljs-keyword">void</span> _Base_bitset&lt;_Nw&gt;::_M_do_left_shift(size_t __shift)
{
  <span class="hljs-keyword">if</span> (__shift != <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">const</span> size_t __wshift = __shift / _GLIBCPP_BITSET_BITS_PER_WORD;
    <span class="hljs-keyword">const</span> size_t __offset = __shift % _GLIBCPP_BITSET_BITS_PER_WORD;

    <span class="hljs-keyword">if</span> (__offset == <span class="hljs-number">0</span>)
      <span class="hljs-keyword">for</span> (size_t __n = _Nw - <span class="hljs-number">1</span>; __n &gt;= __wshift; --__n)
        _M_w[__n] = _M_w[__n - __wshift];

    <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">const</span> size_t __sub_offset = _GLIBCPP_BITSET_BITS_PER_WORD - __offset;
      <span class="hljs-keyword">for</span> (size_t __n = _Nw - <span class="hljs-number">1</span>; __n &gt; __wshift; --__n)
        _M_w[__n] = (_M_w[__n - __wshift] &lt;&lt; __offset) |
                    (_M_w[__n - __wshift - <span class="hljs-number">1</span>] &gt;&gt; __sub_offset);
      _M_w[__wshift] = _M_w[<span class="hljs-number">0</span>] &lt;&lt; __offset;
    }

    fill(_M_w + <span class="hljs-number">0</span>, _M_w + __wshift, <span class="hljs-keyword">static_cast</span>&lt;_WordT&gt;(<span class="hljs-number">0</span>));
  }
}

<span class="hljs-keyword">template</span>&lt;size_t _Nw&gt;
<span class="hljs-keyword">void</span> _Base_bitset&lt;_Nw&gt;::_M_do_right_shift(size_t __shift)
{
  <span class="hljs-keyword">if</span> (__shift != <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">const</span> size_t __wshift = __shift / _GLIBCPP_BITSET_BITS_PER_WORD;
    <span class="hljs-keyword">const</span> size_t __offset = __shift % _GLIBCPP_BITSET_BITS_PER_WORD;
    <span class="hljs-keyword">const</span> size_t __limit = _Nw - __wshift - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">if</span> (__offset == <span class="hljs-number">0</span>)
      <span class="hljs-keyword">for</span> (size_t __n = <span class="hljs-number">0</span>; __n &lt;= __limit; ++__n)
        _M_w[__n] = _M_w[__n + __wshift];

    <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">const</span> size_t __sub_offset = _GLIBCPP_BITSET_BITS_PER_WORD - __offset;
      <span class="hljs-keyword">for</span> (size_t __n = <span class="hljs-number">0</span>; __n &lt; __limit; ++__n)
        _M_w[__n] = (_M_w[__n + __wshift] &gt;&gt; __offset) |
                    (_M_w[__n + __wshift + <span class="hljs-number">1</span>] &lt;&lt; __sub_offset);
      _M_w[__limit] = _M_w[_Nw-<span class="hljs-number">1</span>] &gt;&gt; __offset;
    }

    fill(_M_w + __limit + <span class="hljs-number">1</span>, _M_w + _Nw, <span class="hljs-keyword">static_cast</span>&lt;_WordT&gt;(<span class="hljs-number">0</span>));
  }
}

<span class="hljs-comment">// 仅返回最低字, 如高位有数据, 抛出overflow_error异常</span>
<span class="hljs-keyword">template</span>&lt;size_t _Nw&gt;
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> _Base_bitset&lt;_Nw&gt;::_M_do_to_ulong() <span class="hljs-keyword">const</span>
{
  <span class="hljs-keyword">for</span> (size_t __i = <span class="hljs-number">1</span>; __i &lt; _Nw; ++__i)
    <span class="hljs-keyword">if</span> (_M_w[__i])
      __STL_THROW(overflow_error(<span class="hljs-string">"bitset"</span>));

  <span class="hljs-keyword">return</span> _M_w[<span class="hljs-number">0</span>];
}

<span class="hljs-comment">// 同样使用了查表法</span>
<span class="hljs-keyword">template</span>&lt;size_t _Nw&gt;
size_t _Base_bitset&lt;_Nw&gt;::_M_do_find_first(size_t __not_found) <span class="hljs-keyword">const</span>
{
  <span class="hljs-keyword">for</span> ( size_t __i = <span class="hljs-number">0</span>; __i &lt; _Nw; __i++ ) {
    _WordT __thisword = _M_w[__i];
    <span class="hljs-keyword">if</span> ( __thisword != <span class="hljs-keyword">static_cast</span>&lt;_WordT&gt;(<span class="hljs-number">0</span>) ) {
      <span class="hljs-comment">// find byte within word</span>
      <span class="hljs-keyword">for</span> ( size_t __j = <span class="hljs-number">0</span>; __j &lt; <span class="hljs-keyword">sizeof</span>(_WordT); __j++ ) {
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> __this_byte
          = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt;(__thisword &amp; (~(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)<span class="hljs-number">0</span>));
        <span class="hljs-keyword">if</span> ( __this_byte )
          <span class="hljs-keyword">return</span> __i*_GLIBCPP_BITSET_BITS_PER_WORD + __j*CHAR_BIT +
            _First_one&lt;<span class="hljs-keyword">true</span>&gt;::_S_first_one[__this_byte];

        __thisword &gt;&gt;= CHAR_BIT;
      }
    }
  }
  <span class="hljs-comment">// not found, so return an indication of failure.</span>
  <span class="hljs-keyword">return</span> __not_found;
}

<span class="hljs-keyword">template</span>&lt;size_t _Nw&gt;
size_t
_Base_bitset&lt;_Nw&gt;::_M_do_find_next(size_t __prev, size_t __not_found) <span class="hljs-keyword">const</span>
{
  <span class="hljs-comment">// make bound inclusive</span>
  ++__prev;

  <span class="hljs-comment">// check out of bounds</span>
  <span class="hljs-keyword">if</span> ( __prev &gt;= _Nw * _GLIBCPP_BITSET_BITS_PER_WORD )
    <span class="hljs-keyword">return</span> __not_found;

    <span class="hljs-comment">// search first word</span>
  size_t __i = _S_whichword(__prev);
  _WordT __thisword = _M_w[__i];

    <span class="hljs-comment">// mask off bits below bound</span>
  __thisword &amp;= (~<span class="hljs-keyword">static_cast</span>&lt;_WordT&gt;(<span class="hljs-number">0</span>)) &lt;&lt; _S_whichbit(__prev);

  <span class="hljs-keyword">if</span> ( __thisword != <span class="hljs-keyword">static_cast</span>&lt;_WordT&gt;(<span class="hljs-number">0</span>) ) {
    <span class="hljs-comment">// find byte within word</span>
    <span class="hljs-comment">// get first byte into place</span>
    __thisword &gt;&gt;= _S_whichbyte(__prev) * CHAR_BIT;
    <span class="hljs-keyword">for</span> ( size_t __j = _S_whichbyte(__prev); __j &lt; <span class="hljs-keyword">sizeof</span>(_WordT); __j++ ) {
      <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> __this_byte
        = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt;(__thisword &amp; (~(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)<span class="hljs-number">0</span>));
      <span class="hljs-keyword">if</span> ( __this_byte )
        <span class="hljs-keyword">return</span> __i*_GLIBCPP_BITSET_BITS_PER_WORD + __j*CHAR_BIT +
          _First_one&lt;<span class="hljs-keyword">true</span>&gt;::_S_first_one[__this_byte];

      __thisword &gt;&gt;= CHAR_BIT;
    }
  }

  <span class="hljs-comment">// check subsequent words</span>
  __i++;
  <span class="hljs-keyword">for</span> ( ; __i &lt; _Nw; __i++ ) {
    __thisword = _M_w[__i];
    <span class="hljs-keyword">if</span> ( __thisword != <span class="hljs-keyword">static_cast</span>&lt;_WordT&gt;(<span class="hljs-number">0</span>) ) {
      <span class="hljs-comment">// find byte within word</span>
      <span class="hljs-keyword">for</span> ( size_t __j = <span class="hljs-number">0</span>; __j &lt; <span class="hljs-keyword">sizeof</span>(_WordT); __j++ ) {
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> __this_byte
          = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt;(__thisword &amp; (~(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)<span class="hljs-number">0</span>));
        <span class="hljs-keyword">if</span> ( __this_byte )
          <span class="hljs-keyword">return</span> __i*_GLIBCPP_BITSET_BITS_PER_WORD + __j*CHAR_BIT +
            _First_one&lt;<span class="hljs-keyword">true</span>&gt;::_S_first_one[__this_byte];

        __thisword &gt;&gt;= CHAR_BIT;
      }
    }
  }

  <span class="hljs-comment">// not found, so return an indication of failure.</span>
  <span class="hljs-keyword">return</span> __not_found;
}


<span class="hljs-comment">// 只有一个word时的特化</span>
<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> _Base_bitset&lt;<span class="hljs-number">1</span>&gt; {
  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> _WordT;
  _WordT _M_w;

  _Base_bitset( <span class="hljs-keyword">void</span> ) : _M_w(<span class="hljs-number">0</span>) {}
  _Base_bitset(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> __val) : _M_w(__val) {}

  <span class="hljs-keyword">static</span> size_t _S_whichword( size_t __pos )
    { <span class="hljs-keyword">return</span> __pos / _GLIBCPP_BITSET_BITS_PER_WORD; }
  <span class="hljs-keyword">static</span> size_t _S_whichbyte( size_t __pos )
    { <span class="hljs-keyword">return</span> (__pos % _GLIBCPP_BITSET_BITS_PER_WORD) / CHAR_BIT; }
  <span class="hljs-keyword">static</span> size_t _S_whichbit( size_t __pos )
    {  <span class="hljs-keyword">return</span> __pos % _GLIBCPP_BITSET_BITS_PER_WORD; }
  <span class="hljs-keyword">static</span> _WordT _S_maskbit( size_t __pos )
    { <span class="hljs-keyword">return</span> (<span class="hljs-keyword">static_cast</span>&lt;_WordT&gt;(<span class="hljs-number">1</span>)) &lt;&lt; _S_whichbit(__pos); }

  _WordT&amp; _M_getword(size_t)       { <span class="hljs-keyword">return</span> _M_w; }
  _WordT  _M_getword(size_t) <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> _M_w; }

  _WordT&amp; _M_hiword()       { <span class="hljs-keyword">return</span> _M_w; }
  _WordT  _M_hiword() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> _M_w; }

  <span class="hljs-keyword">void</span> _M_do_and(<span class="hljs-keyword">const</span> _Base_bitset&lt;<span class="hljs-number">1</span>&gt;&amp; __x) { _M_w &amp;= __x._M_w; }
  <span class="hljs-keyword">void</span> _M_do_or(<span class="hljs-keyword">const</span> _Base_bitset&lt;<span class="hljs-number">1</span>&gt;&amp; __x)  { _M_w |= __x._M_w; }
  <span class="hljs-keyword">void</span> _M_do_xor(<span class="hljs-keyword">const</span> _Base_bitset&lt;<span class="hljs-number">1</span>&gt;&amp; __x) { _M_w ^= __x._M_w; }
  <span class="hljs-keyword">void</span> _M_do_left_shift(size_t __shift)     { _M_w &lt;&lt;= __shift; }
  <span class="hljs-keyword">void</span> _M_do_right_shift(size_t __shift)    { _M_w &gt;&gt;= __shift; }
  <span class="hljs-keyword">void</span> _M_do_flip()                       { _M_w = ~_M_w; }
  <span class="hljs-keyword">void</span> _M_do_set()                        { _M_w = ~<span class="hljs-keyword">static_cast</span>&lt;_WordT&gt;(<span class="hljs-number">0</span>); }
  <span class="hljs-keyword">void</span> _M_do_reset()                      { _M_w = <span class="hljs-number">0</span>; }

  <span class="hljs-keyword">bool</span> _M_is_equal(<span class="hljs-keyword">const</span> _Base_bitset&lt;<span class="hljs-number">1</span>&gt;&amp; __x) <span class="hljs-keyword">const</span>
    { <span class="hljs-keyword">return</span> _M_w == __x._M_w; }
  <span class="hljs-keyword">bool</span> _M_is_any() <span class="hljs-keyword">const</span>
    { <span class="hljs-keyword">return</span> _M_w != <span class="hljs-number">0</span>; }

  size_t _M_do_count() <span class="hljs-keyword">const</span> {
    size_t __result = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>* __byte_ptr = (<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)&amp;_M_w;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>* __end_ptr
      = ((<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)&amp;_M_w)+<span class="hljs-keyword">sizeof</span>(_M_w);
    <span class="hljs-keyword">while</span> ( __byte_ptr &lt; __end_ptr ) {
      __result += _Bit_count&lt;<span class="hljs-keyword">true</span>&gt;::_S_bit_count[*__byte_ptr];
      __byte_ptr++;
    }
    <span class="hljs-keyword">return</span> __result;
  }

  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> _M_do_to_ulong() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> _M_w; }

  size_t _M_do_find_first(size_t __not_found) <span class="hljs-keyword">const</span>;

  <span class="hljs-comment">// find the next "on" bit that follows "prev"</span>
  size_t _M_do_find_next(size_t __prev, size_t __not_found) <span class="hljs-keyword">const</span>;

};


<span class="hljs-comment">// 辅助类, 用来将最高word没有用到的比特清零</span>
<span class="hljs-keyword">template</span> &lt;size_t _Extrabits&gt; <span class="hljs-keyword">struct</span> _Sanitize {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _M_do_sanitize(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>&amp; __val)
    { __val &amp;= ~((~<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>&gt;(<span class="hljs-number">0</span>)) &lt;&lt; _Extrabits); }
};

<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> _Sanitize&lt;<span class="hljs-number">0</span>&gt; {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _M_do_sanitize(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) {}
};


<span class="hljs-comment">// Class bitset</span>
<span class="hljs-keyword">template</span>&lt;size_t _Nb&gt;
<span class="hljs-keyword">class</span> <span class="hljs-built_in">bitset</span> : <span class="hljs-keyword">private</span> _Base_bitset&lt;__BITSET_WORDS(_Nb)&gt;
{
<span class="hljs-keyword">private</span>:
  <span class="hljs-keyword">typedef</span> _Base_bitset&lt;__BITSET_WORDS(_Nb)&gt; _Base;
  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> _WordT;

<span class="hljs-keyword">private</span>:
  <span class="hljs-comment">// 将最高word没有用到的比特清零</span>
  <span class="hljs-keyword">void</span> _M_do_sanitize() {
    _Sanitize&lt;_Nb%_GLIBCPP_BITSET_BITS_PER_WORD&gt;::_M_do_sanitize(<span class="hljs-keyword">this</span>-&gt;_M_hiword());
  }

<span class="hljs-keyword">public</span>:

  <span class="hljs-comment">// bit reference:</span>
  <span class="hljs-keyword">class</span> reference;
  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> reference;

  <span class="hljs-keyword">class</span> reference {
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-built_in">bitset</span>;

    _WordT *_M_wp;
    size_t _M_bpos;

    <span class="hljs-comment">// left undefined</span>
    reference();

  <span class="hljs-keyword">public</span>:
    reference( <span class="hljs-built_in">bitset</span>&amp; __b, size_t __pos ) {
      _M_wp = &amp;__b._M_getword(__pos);
      _M_bpos = _Base::_S_whichbit(__pos);
    }

    ~reference() {}

    <span class="hljs-comment">// for b[i] = __x;</span>
    reference&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">bool</span> __x) {
      <span class="hljs-keyword">if</span> ( __x )
        *_M_wp |= _Base::_S_maskbit(_M_bpos);
      <span class="hljs-keyword">else</span>
        *_M_wp &amp;= ~_Base::_S_maskbit(_M_bpos);

      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }

    <span class="hljs-comment">// for b[i] = b[__j];</span>
    reference&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> reference&amp; __j) {
      <span class="hljs-keyword">if</span> ( (*(__j._M_wp) &amp; _Base::_S_maskbit(__j._M_bpos)) )
        *_M_wp |= _Base::_S_maskbit(_M_bpos);
      <span class="hljs-keyword">else</span>
        *_M_wp &amp;= ~_Base::_S_maskbit(_M_bpos);

      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }

    <span class="hljs-comment">// flips the bit</span>
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>~() <span class="hljs-keyword">const</span>
      { <span class="hljs-keyword">return</span> (*(_M_wp) &amp; _Base::_S_maskbit(_M_bpos)) == <span class="hljs-number">0</span>; }

    <span class="hljs-comment">// for __x = b[i];</span>
    <span class="hljs-keyword">operator</span> <span class="hljs-keyword">bool</span>() <span class="hljs-keyword">const</span>
      { <span class="hljs-keyword">return</span> (*(_M_wp) &amp; _Base::_S_maskbit(_M_bpos)) != <span class="hljs-number">0</span>; }

    <span class="hljs-comment">// for b[i].flip();</span>
    reference&amp; flip() {
      *_M_wp ^= _Base::_S_maskbit(_M_bpos);
      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
  };

  <span class="hljs-comment">// constructors:</span>
  <span class="hljs-built_in">bitset</span>() {}
  <span class="hljs-built_in">bitset</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> __val) : _Base_bitset&lt;__BITSET_WORDS(_Nb)&gt;(__val)
    { _M_do_sanitize(); }

  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> _CharT, <span class="hljs-keyword">class</span> _Traits, <span class="hljs-keyword">class</span> _Alloc&gt;
  <span class="hljs-keyword">explicit</span> <span class="hljs-built_in">bitset</span>(<span class="hljs-keyword">const</span> basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __s,
                  size_t __pos = <span class="hljs-number">0</span>)
    : _Base()
  {
    <span class="hljs-keyword">if</span> (__pos &gt; __s.size())
      __STL_THROW(out_of_range(<span class="hljs-string">"bitset"</span>));
    _M_copy_from_string(__s, __pos,
                        basic_string&lt;_CharT, _Traits, _Alloc&gt;::npos);
  }
  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> _CharT, <span class="hljs-keyword">class</span> _Traits, <span class="hljs-keyword">class</span> _Alloc&gt;
  <span class="hljs-built_in">bitset</span>(<span class="hljs-keyword">const</span> basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __s,
         size_t __pos,
         size_t __n)
    : _Base()
  {
    <span class="hljs-keyword">if</span> (__pos &gt; __s.size())
      __STL_THROW(out_of_range(<span class="hljs-string">"bitset"</span>));
    _M_copy_from_string(__s, __pos, __n);
  }

  <span class="hljs-comment">// bitset operations:</span>
  <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; <span class="hljs-keyword">operator</span>&amp;=(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; __rhs) {
    <span class="hljs-keyword">this</span>-&gt;_M_do_and(__rhs);
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
  }

  <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; <span class="hljs-keyword">operator</span>|=(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; __rhs) {
    <span class="hljs-keyword">this</span>-&gt;_M_do_or(__rhs);
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
  }

  <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; <span class="hljs-keyword">operator</span>^=(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; __rhs) {
    <span class="hljs-keyword">this</span>-&gt;_M_do_xor(__rhs);
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
  }

  <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; <span class="hljs-keyword">operator</span>&lt;&lt;=(size_t __pos) {
    <span class="hljs-keyword">this</span>-&gt;_M_do_left_shift(__pos);
    <span class="hljs-keyword">this</span>-&gt;_M_do_sanitize();
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
  }

  <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; <span class="hljs-keyword">operator</span>&gt;&gt;=(size_t __pos) {
    <span class="hljs-keyword">this</span>-&gt;_M_do_right_shift(__pos);
    <span class="hljs-keyword">this</span>-&gt;_M_do_sanitize();
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
  }

  <span class="hljs-comment">// 单比特操作</span>
  <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; _Unchecked_set(size_t __pos) {
    <span class="hljs-keyword">this</span>-&gt;_M_getword(__pos) |= _Base::_S_maskbit(__pos);
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
  }

  <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; _Unchecked_set(size_t __pos, <span class="hljs-keyword">int</span> __val) {
    <span class="hljs-keyword">if</span> (__val)
      <span class="hljs-keyword">this</span>-&gt;_M_getword(__pos) |= _Base::_S_maskbit(__pos);
    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">this</span>-&gt;_M_getword(__pos) &amp;= ~_Base::_S_maskbit(__pos);

    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
  }

  <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; _Unchecked_reset(size_t __pos) {
    <span class="hljs-keyword">this</span>-&gt;_M_getword(__pos) &amp;= ~_Base::_S_maskbit(__pos);
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
  }

  <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; _Unchecked_flip(size_t __pos) {
    <span class="hljs-keyword">this</span>-&gt;_M_getword(__pos) ^= _Base::_S_maskbit(__pos);
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
  }

  <span class="hljs-keyword">bool</span> _Unchecked_test(size_t __pos) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>-&gt;_M_getword(__pos) &amp; _Base::_S_maskbit(__pos))
      != <span class="hljs-keyword">static_cast</span>&lt;_WordT&gt;(<span class="hljs-number">0</span>);
  }

  <span class="hljs-comment">// Set, reset, and flip</span>
  <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; <span class="hljs-built_in">set</span>() {
    <span class="hljs-keyword">this</span>-&gt;_M_do_set();
    <span class="hljs-keyword">this</span>-&gt;_M_do_sanitize();
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
  }

  <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; <span class="hljs-built_in">set</span>(size_t __pos, <span class="hljs-keyword">bool</span> __val = <span class="hljs-keyword">true</span>) {
    <span class="hljs-keyword">if</span> (__pos &gt;= _Nb)
      __STL_THROW(out_of_range(<span class="hljs-string">"bitset"</span>));

    <span class="hljs-keyword">return</span> _Unchecked_set(__pos, __val);
  }

  <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; reset() {
    <span class="hljs-keyword">this</span>-&gt;_M_do_reset();
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
  }

  <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; reset(size_t __pos) {
    <span class="hljs-keyword">if</span> (__pos &gt;= _Nb)
      __STL_THROW(out_of_range(<span class="hljs-string">"bitset"</span>));

    <span class="hljs-keyword">return</span> _Unchecked_reset(__pos);
  }

  <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; flip() {
    <span class="hljs-keyword">this</span>-&gt;_M_do_flip();
    <span class="hljs-keyword">this</span>-&gt;_M_do_sanitize();
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
  }

  <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; flip(size_t __pos) {
    <span class="hljs-keyword">if</span> (__pos &gt;= _Nb)
      __STL_THROW(out_of_range(<span class="hljs-string">"bitset"</span>));

    <span class="hljs-keyword">return</span> _Unchecked_flip(__pos);
  }

  <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span> <span class="hljs-keyword">operator</span>~() <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>(*<span class="hljs-keyword">this</span>).flip();
  }

  <span class="hljs-comment">// element access</span>
  reference <span class="hljs-keyword">operator</span>[](size_t __pos) { <span class="hljs-keyword">return</span> reference(*<span class="hljs-keyword">this</span>,__pos); }
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>[](size_t __pos) <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> _Unchecked_test(__pos); }

  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> to_ulong() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;_M_do_to_ulong(); }

  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _CharT, <span class="hljs-keyword">class</span> _Traits, <span class="hljs-keyword">class</span> _Alloc&gt;
  basic_string&lt;_CharT, _Traits, _Alloc&gt; to_string() <span class="hljs-keyword">const</span> {
    basic_string&lt;_CharT, _Traits, _Alloc&gt; __result;
    _M_copy_to_string(__result);
    <span class="hljs-keyword">return</span> __result;
  }

  <span class="hljs-comment">// Helper functions for string operations.</span>
  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> _CharT, <span class="hljs-keyword">class</span> _Traits, <span class="hljs-keyword">class</span> _Alloc&gt;
  <span class="hljs-keyword">void</span> _M_copy_from_string(<span class="hljs-keyword">const</span> basic_string&lt;_CharT,_Traits,_Alloc&gt;&amp; __s,
                          size_t, size_t);

  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> _CharT, <span class="hljs-keyword">class</span> _Traits, <span class="hljs-keyword">class</span> _Alloc&gt;
  <span class="hljs-keyword">void</span> _M_copy_to_string(basic_string&lt;_CharT,_Traits,_Alloc&gt;&amp;) <span class="hljs-keyword">const</span>;

  size_t count() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;_M_do_count(); }

  size_t size() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> _Nb; }

  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; __rhs) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;_M_is_equal(__rhs);
  }
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; __rhs) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>-&gt;_M_is_equal(__rhs);
  }

  <span class="hljs-keyword">bool</span> test(size_t __pos) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">if</span> (__pos &gt;= _Nb)
      __STL_THROW(out_of_range(<span class="hljs-string">"bitset"</span>));
    <span class="hljs-keyword">return</span> _Unchecked_test(__pos);
  }

  <span class="hljs-keyword">bool</span> any() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;_M_is_any(); }
  <span class="hljs-keyword">bool</span> none() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>-&gt;_M_is_any(); }

  <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span> <span class="hljs-keyword">operator</span>&lt;&lt;(size_t __pos) <span class="hljs-keyword">const</span>
    { <span class="hljs-keyword">return</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>(*<span class="hljs-keyword">this</span>) &lt;&lt;= __pos; }
  <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span> <span class="hljs-keyword">operator</span>&gt;&gt;(size_t __pos) <span class="hljs-keyword">const</span>
    { <span class="hljs-keyword">return</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>(*<span class="hljs-keyword">this</span>) &gt;&gt;= __pos; }

  <span class="hljs-comment">// 扩展部分, 非标准的一部分, 不要依赖这些非标准部分</span>
  <span class="hljs-comment">// find the index of the first "on" bit</span>
  size_t _Find_first() <span class="hljs-keyword">const</span>
    { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;_M_do_find_first(_Nb); }

  <span class="hljs-comment">// find the index of the next "on" bit after prev</span>
  size_t _Find_next( size_t __prev ) <span class="hljs-keyword">const</span>
    { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;_M_do_find_next(__prev, _Nb); }
};

<span class="hljs-comment">// bitset和string的相互转换函数</span>
<span class="hljs-keyword">template</span> &lt;size_t _Nb&gt;
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> _CharT, <span class="hljs-keyword">class</span> _Traits, <span class="hljs-keyword">class</span> _Alloc&gt;
<span class="hljs-keyword">void</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>
  ::_M_copy_from_string(<span class="hljs-keyword">const</span> basic_string&lt;_CharT,_Traits,_Alloc&gt;&amp; __s,
                        size_t __pos, size_t __n)
{
  reset();
  <span class="hljs-keyword">const</span> size_t __nbits = min(_Nb, min(__n, __s.size() - __pos));
  <span class="hljs-keyword">for</span> (size_t __i = <span class="hljs-number">0</span>; __i &lt; __nbits; ++__i) {
    <span class="hljs-keyword">switch</span>(__s[__pos + __nbits - __i - <span class="hljs-number">1</span>]) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'0'</span>:
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'1'</span>:
      <span class="hljs-built_in">set</span>(__i);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      __STL_THROW(invalid_argument(<span class="hljs-string">"bitset"</span>));
    }
  }
}

<span class="hljs-keyword">template</span> &lt;size_t _Nb&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _CharT, <span class="hljs-keyword">class</span> _Traits, <span class="hljs-keyword">class</span> _Alloc&gt;
<span class="hljs-keyword">void</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>
  ::_M_copy_to_string(basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; __s) <span class="hljs-keyword">const</span>
{
  __s.assign(_Nb, <span class="hljs-string">'0'</span>);

  <span class="hljs-keyword">for</span> (size_t __i = <span class="hljs-number">0</span>; __i &lt; _Nb; ++__i)
    <span class="hljs-keyword">if</span> (_Unchecked_test(__i))
      __s[_Nb - <span class="hljs-number">1</span> - __i] = <span class="hljs-string">'1'</span>;
}


<span class="hljs-comment">// 运算符函数:与,或,异或,&lt;&lt;,&gt;&gt;</span>
<span class="hljs-keyword">template</span> &lt;size_t _Nb&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span> <span class="hljs-keyword">operator</span>&amp;(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; __x, <span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; __y) {
  <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span> __result(__x);
  __result &amp;= __y;
  <span class="hljs-keyword">return</span> __result;
}

<span class="hljs-keyword">template</span> &lt;size_t _Nb&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span> <span class="hljs-keyword">operator</span>|(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; __x, <span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; __y) {
  <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span> __result(__x);
  __result |= __y;
  <span class="hljs-keyword">return</span> __result;
}

<span class="hljs-keyword">template</span> &lt;size_t _Nb&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span> <span class="hljs-keyword">operator</span>^(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; __x, <span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; __y) {
  <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span> __result(__x);
  __result ^= __y;
  <span class="hljs-keyword">return</span> __result;
}

<span class="hljs-comment">// 先将输入读入一个临时字符串, 再用字符串初始化bitset, 可能会抛出invalid_argument异常</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _CharT, <span class="hljs-keyword">class</span> _Traits, size_t _Nb&gt;
basic_istream&lt;_CharT, _Traits&gt;&amp;
<span class="hljs-keyword">operator</span>&gt;&gt;(basic_istream&lt;_CharT, _Traits&gt;&amp; __is, <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; __x)
{
  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> _Traits::char_type char_type;
  basic_string&lt;_CharT, _Traits&gt; __tmp;
  __tmp.reserve(_Nb);

  <span class="hljs-comment">// Skip whitespace</span>
  <span class="hljs-keyword">typename</span> basic_istream&lt;_CharT, _Traits&gt;::sentry __sentry(__is);
  <span class="hljs-keyword">if</span> (__sentry) {
    basic_streambuf&lt;_CharT, _Traits&gt;* __buf = __is.rdbuf();
    <span class="hljs-keyword">for</span> (size_t __i = <span class="hljs-number">0</span>; __i &lt; _Nb; ++__i) {
      <span class="hljs-keyword">static</span> <span class="hljs-keyword">typename</span> _Traits::int_type __eof = _Traits::eof();

      <span class="hljs-keyword">typename</span> _Traits::int_type __c1 = __buf-&gt;sbumpc();
      <span class="hljs-keyword">if</span> (_Traits::eq_int_type(__c1, __eof)) {
        __is.setstate(ios_base::eofbit);
        <span class="hljs-keyword">break</span>;
      }
      <span class="hljs-keyword">else</span> {
        char_type __c2 = _Traits::to_char_type(__c1);
        char_type __c  = __is.narrow(__c2, <span class="hljs-string">'*'</span>);

        <span class="hljs-keyword">if</span> (__c == <span class="hljs-string">'0'</span> || __c == <span class="hljs-string">'1'</span>)
          __tmp.push_back(__c);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_Traits::eq_int_type(__buf-&gt;sputbackc(__c2), __eof)) {
          __is.setstate(ios_base::failbit);
          <span class="hljs-keyword">break</span>;
        }
      }
    }

    <span class="hljs-keyword">if</span> (__tmp.empty())
      __is.setstate(ios_base::failbit);
    <span class="hljs-keyword">else</span>
      __x._M_copy_from_string(__tmp, <span class="hljs-keyword">static_cast</span>&lt;size_t&gt;(<span class="hljs-number">0</span>), _Nb);
  }

  <span class="hljs-keyword">return</span> __is;
}

<span class="hljs-comment">// 先得到对应的字符串, 再输出</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _CharT, <span class="hljs-keyword">class</span> _Traits, size_t _Nb&gt;
basic_ostream&lt;_CharT, _Traits&gt;&amp;
<span class="hljs-keyword">operator</span>&lt;&lt;(basic_ostream&lt;_CharT, _Traits&gt;&amp; __os, <span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;_Nb&gt;</span>&amp; __x)
{
  basic_string&lt;_CharT, _Traits&gt; __tmp;
  __x._M_copy_to_string(__tmp);
  <span class="hljs-keyword">return</span> __os &lt;&lt; __tmp;
}</code></pre></div></body>
</html>