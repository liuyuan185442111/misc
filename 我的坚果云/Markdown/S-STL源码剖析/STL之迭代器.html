<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STL之迭代器</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><p>根据实现的功能，迭代器分为五类： <br>
<img src="http://img.blog.csdn.net/20150519181138966" alt="迭代器分类" title=""> <br>
不同种类迭代器可进行的操作（<a href="http://www.cplusplus.com/reference/iterator/" target="_blank">from</a>）：</p>

<table border="1"><tbody><tr><th colspan="4">category</th><th>properties</th><th>valid expressions</th></tr>
<tr><td colspan="4" rowspan="2">all categories</td><td>copy-constructible, copy-assignable and destructible</td><td>X b(a);<br>
b = a;</td></tr>
<tr><td>Can be incremented</td><td>++a<br>
a++</td></tr>
<tr><td rowspan="10">Random Access</td><td rowspan="6">Bidirectional</td><td rowspan="5">Forward</td><td rowspan="2">Input</td><td>Supports equality/inequality comparisons</td><td>a == b<br>
a != b</td></tr>
<tr><td>Can be dereferenced as an rvalue</td><td>*a<br>
a-&gt;m</td></tr>
<tr><td>Output</td><td>Can be dereferenced as an lvalue<br>
(only for mutable iterator types)</td><td>*a = t<br>
*a++ = t</td></tr>
<tr><td rowspan="2"></td><td>default-constructible</td><td>X a;<br>
X()</td></tr>
<tr><td>Multi-pass: neither dereferencing nor<br>
incrementing affects dereferenceability</td><td>{ b=a; *a++; *b; }</td></tr>
<tr><td colspan="2"></td><td>Can be decremented</td><td>--a<br>
a--<br>
*a--</td></tr>
<tr><td colspan="3" rowspan="4"></td><td>Supports arithmetic operators + and -</td><td>a + n<br>
n + a<br>
a - n<br>
a - b</td></tr>
<tr><td>Supports inequality comparisons (&lt;, &gt;, &lt;= and &gt;=)<br>between iterators</td><td>a &lt; b<br>
a &gt; b<br>
a &lt;= b<br>
a &gt;= b</td></tr>
<tr><td>Supports compound assignment operations += and -=</td><td>a += n<br>
a -= n</td></tr>
<tr><td>Supports offset dereference operator ([])</td><td>a[n]</td></tr>
</tbody></table>



<h2 id="迭代器的结构">迭代器的结构</h2>

<p>源码在stl_iterator_base_types.h中。</p>

<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">// 5种迭代器类别</span>
<span class="hljs-keyword">struct</span> input_iterator_tag {};
<span class="hljs-keyword">struct</span> output_iterator_tag {};
<span class="hljs-keyword">struct</span> forward_iterator_tag : <span class="hljs-keyword">public</span> input_iterator_tag {};
<span class="hljs-keyword">struct</span> bidirectional_iterator_tag : <span class="hljs-keyword">public</span> forward_iterator_tag {};
<span class="hljs-keyword">struct</span> random_access_iterator_tag : <span class="hljs-keyword">public</span> bidirectional_iterator_tag {};

<span class="hljs-comment">// 迭代器基类, 自行开发的迭代器最好继承此基类</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Category, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Distance = ptrdiff_t, <span class="hljs-keyword">typename</span> Pointer = T*, <span class="hljs-keyword">typename</span> Reference = T&amp;&gt;
<span class="hljs-keyword">struct</span> iterator
{
    <span class="hljs-comment">// Category为上面5种类别之一</span>
    <span class="hljs-keyword">typedef</span> Category  iterator_category;
    <span class="hljs-keyword">typedef</span> T         value_type;
    <span class="hljs-keyword">typedef</span> Distance  difference_type;
    <span class="hljs-keyword">typedef</span> Pointer   pointer;
    <span class="hljs-keyword">typedef</span> Reference reference;
};

<span class="hljs-comment">// 提取出迭代器(模板参数)的内置类型</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Iterator&gt;
<span class="hljs-keyword">struct</span> iterator_traits
{
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> Iterator::iterator_category iterator_category;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> Iterator::value_type        value_type;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> Iterator::difference_type  difference_type;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> Iterator::pointer            pointer;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> Iterator::reference         reference;
};

<span class="hljs-comment">// 常规指针的偏特化版本</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> iterator_traits&lt;T*&gt;
{
    <span class="hljs-keyword">typedef</span> random_access_iterator_tag iterator_category;
    <span class="hljs-keyword">typedef</span> T                         value_type;
    <span class="hljs-keyword">typedef</span> ptrdiff_t                 difference_type;
    <span class="hljs-keyword">typedef</span> T*                        pointer;
    <span class="hljs-keyword">typedef</span> T&amp;                        reference;
};

<span class="hljs-comment">// 常规const指针的偏特化版本</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> T&gt;
<span class="hljs-keyword">struct</span> iterator_traits&lt;<span class="hljs-keyword">const</span> T*&gt;
{
    <span class="hljs-keyword">typedef</span> random_access_iterator_tag iterator_category;
    <span class="hljs-keyword">typedef</span> T                         value_type;
    <span class="hljs-keyword">typedef</span> ptrdiff_t                 difference_type;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> T*                  pointer;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> T&amp;                  reference;
};


<span class="hljs-comment">// These functions is not a part of the C++ standard but is syntactic sugar for internal library use only</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iter&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;Iter&gt;::iterator_category
__iterator_category(<span class="hljs-keyword">const</span> Iter&amp;)
{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;Iter&gt;::iterator_category();
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> Iter&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;Iter&gt;::difference_type*
__distance_type(<span class="hljs-keyword">const</span> Iter&amp;)
{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> iterator_traits&lt;Iter&gt;::difference_type*&gt;(<span class="hljs-number">0</span>);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> Iter&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;Iter&gt;::value_type*
__value_type(<span class="hljs-keyword">const</span> Iter&amp;)
{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> iterator_traits&lt;Iter&gt;::value_type*&gt;(<span class="hljs-number">0</span>);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> Iter&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;Iter&gt;::iterator_category
iterator_category(<span class="hljs-keyword">const</span> Iter&amp; i) { <span class="hljs-keyword">return</span> __iterator_category(i); }

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> Iter&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;Iter&gt;::difference_type*
distance_type(<span class="hljs-keyword">const</span> Iter&amp; i) { <span class="hljs-keyword">return</span> __distance_type(i); }

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> Iter&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;Iter&gt;::value_type*
value_type(<span class="hljs-keyword">const</span> Iter&amp; i) { <span class="hljs-keyword">return</span> __value_type(i); }</code></pre>



<h2 id="几个基本的函数">几个基本的函数</h2>

<p>源码在stl_iterator_base_funcs.h中。</p>

<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">// 计算两个迭代器之间的距离</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> InputIterator&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type
__distance(InputIterator first, InputIterator last, input_iterator_tag)
{
    <span class="hljs-keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (first != last)
    {
        ++first;
        ++n;
    }
    <span class="hljs-keyword">return</span> n;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> RandomAccessIterator&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;RandomAccessIterator&gt;::difference_type
__distance(RandomAccessIterator first, RandomAccessIterator last, random_access_iterator_tag)
{
    <span class="hljs-keyword">return</span> last - first;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> InputIterator&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type
distance(InputIterator first, InputIterator last)
{
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;InputIterator&gt;::iterator_category Category;
    <span class="hljs-keyword">return</span> __distance(first, last, Category());
}

<span class="hljs-comment">// 前进</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> InputIterator, <span class="hljs-keyword">typename</span> Distance&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> __advance(InputIterator&amp; i, Distance n, input_iterator_tag)
{
    <span class="hljs-keyword">while</span> (n--) ++i;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> BidirectionalIterator, <span class="hljs-keyword">typename</span> Distance&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> __advance(BidirectionalIterator&amp; i, Distance n, bidirectional_iterator_tag)
{
    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>)
        <span class="hljs-keyword">while</span> (n--) ++i;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">while</span> (n++) --i;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> RandomAccessIterator, <span class="hljs-keyword">typename</span> Distance&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> __advance(RandomAccessIterator&amp; i, Distance n, random_access_iterator_tag)
{
    i += n;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> InputIterator, <span class="hljs-keyword">typename</span> Distance&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> advance(InputIterator&amp; i, Distance n)
{
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;InputIterator&gt;::iterator_category Category;
    __advance(i, n, Category());
}</code></pre>



<h2 id="迭代器适配器">迭代器适配器</h2>

<p>有3种，分别为插入迭代器，反向迭代器，输入输出迭代器。</p>



<h3 id="插入迭代器">插入迭代器</h3>

<p>做的工作是：将赋值操作改为插入操作。分为back_insert_iterator，front_insert_iterator，insert_iterator三种。insert_iterator不仅进行插入操作，还会进行一个右移操作，这样就可以进行持续的插入。 <br>
为了操作方便，还定义了3个函数，他们返回相应的插入迭代器。</p>

<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Container&gt;
<span class="hljs-keyword">class</span> back_insert_iterator : <span class="hljs-keyword">public</span> iterator&lt;output_iterator_tag,<span class="hljs-keyword">void</span>,<span class="hljs-keyword">void</span>,<span class="hljs-keyword">void</span>,<span class="hljs-keyword">void</span>&gt;
{
<span class="hljs-keyword">protected</span>:
    Container* container;
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> Container container_type;

    <span class="hljs-keyword">explicit</span> back_insert_iterator(Container&amp; x) : container(&amp;x) {}
    back_insert_iterator&lt;Container&gt;&amp;
    <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> <span class="hljs-keyword">typename</span> Container::value_type&amp; value)
    {
        container-&gt;push_back(value);
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    back_insert_iterator&lt;Container&gt;&amp; <span class="hljs-keyword">operator</span>*()
    { <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; }
    back_insert_iterator&lt;Container&gt;&amp; <span class="hljs-keyword">operator</span>++()
    { <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; }
    back_insert_iterator&lt;Container&gt;&amp; <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>)
    { <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; }
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Container&gt;
<span class="hljs-keyword">inline</span> back_insert_iterator&lt;Container&gt;
back_inserter(Container&amp; x)
{
    <span class="hljs-keyword">return</span> back_insert_iterator&lt;Container&gt;(x);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Container&gt;
<span class="hljs-keyword">class</span> front_insert_iterator : <span class="hljs-keyword">public</span> iterator&lt;output_iterator_tag,<span class="hljs-keyword">void</span>,<span class="hljs-keyword">void</span>,<span class="hljs-keyword">void</span>,<span class="hljs-keyword">void</span>&gt;
{
<span class="hljs-keyword">protected</span>:
    Container* container;
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> Container container_type;

    <span class="hljs-keyword">explicit</span> front_insert_iterator(Container&amp; x) : container(&amp;x) {}
    front_insert_iterator&lt;Container&gt;&amp;
    <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> <span class="hljs-keyword">typename</span> Container::value_type&amp; value)
    {
        container-&gt;push_front(value);
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    front_insert_iterator&lt;Container&gt;&amp; <span class="hljs-keyword">operator</span>*()
    { <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; }
    front_insert_iterator&lt;Container&gt;&amp; <span class="hljs-keyword">operator</span>++()
    { <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; }
    front_insert_iterator&lt;Container&gt;&amp; <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>)
    { <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; }
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Container&gt;
<span class="hljs-keyword">inline</span> front_insert_iterator&lt;Container&gt;
front_inserter(Container&amp; x)
{
    <span class="hljs-keyword">return</span> front_insert_iterator&lt;Container&gt;(x);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> Container&gt;
<span class="hljs-keyword">class</span> insert_iterator : <span class="hljs-keyword">public</span> iterator&lt;output_iterator_tag,<span class="hljs-keyword">void</span>,<span class="hljs-keyword">void</span>,<span class="hljs-keyword">void</span>,<span class="hljs-keyword">void</span>&gt;
{
<span class="hljs-keyword">protected</span>:
    Container* container;
    <span class="hljs-keyword">typename</span> Container::iterator iter;
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> Container container_type;

    insert_iterator(Container&amp; x, <span class="hljs-keyword">typename</span> Container::iterator i)
        : container(&amp;x), iter(i) {}
    insert_iterator&lt;Container&gt;&amp;
    <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> <span class="hljs-keyword">typename</span> Container::value_type&amp; value)
    {
        iter = container-&gt;insert(iter, value);
        ++iter;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    insert_iterator&lt;Container&gt;&amp; <span class="hljs-keyword">operator</span>*()
    { <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; }
    insert_iterator&lt;Container&gt;&amp; <span class="hljs-keyword">operator</span>++()
    { <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; }
    insert_iterator&lt;Container&gt;&amp; <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>)
    { <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; }
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> Iterator&gt;
<span class="hljs-keyword">inline</span> insert_iterator&lt;Container&gt;
inserter(Container&amp; x, Iterator i)
{
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> Container::iterator iter;
    <span class="hljs-keyword">return</span> insert_iterator&lt;Container&gt;(x, iter(i));
}</code></pre>



<h3 id="反向迭代器">反向迭代器</h3>

<p>反向迭代器，顾名思义。</p>

<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Iterator&gt;
<span class="hljs-keyword">class</span> reverse_iterator
{
<span class="hljs-keyword">protected</span>:
    Iterator current;
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category
    iterator_category;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type
    value_type;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;Iterator&gt;::difference_type
    difference_type;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;Iterator&gt;::pointer
    pointer;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;Iterator&gt;::reference
    reference;

    <span class="hljs-keyword">typedef</span> Iterator iterator_type;
    <span class="hljs-keyword">typedef</span> reverse_iterator&lt;Iterator&gt; Self;

<span class="hljs-keyword">public</span>:
    reverse_iterator() {}
    <span class="hljs-keyword">explicit</span> reverse_iterator(iterator_type x) : current(x) {}

    reverse_iterator(<span class="hljs-keyword">const</span> Self&amp; x) : current(x.current) {}
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> Iter&gt;
    reverse_iterator(<span class="hljs-keyword">const</span> reverse_iterator&lt;Iter&gt;&amp; x)
        : current(x.current) {}

    iterator_type base() <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> current;
    }
    reference <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span>
    {
        Iterator tmp = current;
        <span class="hljs-keyword">return</span> *--tmp;
    }
    pointer <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> &amp;(<span class="hljs-keyword">operator</span>*());
    }

    Self&amp; <span class="hljs-keyword">operator</span>++()
    {
        --current;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    Self <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>)
    {
        Self tmp = *<span class="hljs-keyword">this</span>;
        --current;
        <span class="hljs-keyword">return</span> tmp;
    }
    Self&amp; <span class="hljs-keyword">operator</span>--()
    {
        ++current;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    Self <span class="hljs-keyword">operator</span>--(<span class="hljs-keyword">int</span>)
    {
        Self tmp = *<span class="hljs-keyword">this</span>;
        ++current;
        <span class="hljs-keyword">return</span> tmp;
    }

    Self <span class="hljs-keyword">operator</span>+(difference_type n) <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> Self(current - n);
    }
    Self&amp; <span class="hljs-keyword">operator</span>+=(difference_type n)
    {
        current -= n;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    Self <span class="hljs-keyword">operator</span>-(difference_type n) <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> _Self(current + n);
    }
    Self&amp; <span class="hljs-keyword">operator</span>-=(difference_type n)
    {
        current += n;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    reference <span class="hljs-keyword">operator</span>[](difference_type n) <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> *(*<span class="hljs-keyword">this</span> + n);
    }
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Iterator&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> reverse_iterator&lt;Iterator&gt;&amp; x,
                       <span class="hljs-keyword">const</span> reverse_iterator&lt;Iterator&gt;&amp; y)
{
    <span class="hljs-keyword">return</span> x.base() == y.base();
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Iterator&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> reverse_iterator&lt;Iterator&gt;&amp; x,
                      <span class="hljs-keyword">const</span> reverse_iterator&lt;Iterator&gt;&amp; y)
{
    <span class="hljs-keyword">return</span> y.base() &lt; x.base();
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Iterator&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> reverse_iterator&lt;Iterator&gt;&amp; x,
                       <span class="hljs-keyword">const</span> reverse_iterator&lt;Iterator&gt;&amp; y)
{
    <span class="hljs-keyword">return</span> !(x == y);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Iterator&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-keyword">const</span> reverse_iterator&lt;Iterator&gt;&amp; x,
                      <span class="hljs-keyword">const</span> reverse_iterator&lt;Iterator&gt;&amp; y)
{
    <span class="hljs-keyword">return</span> y &lt; x;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Iterator&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-keyword">const</span> reverse_iterator&lt;Iterator&gt;&amp; x,
                       <span class="hljs-keyword">const</span> reverse_iterator&lt;Iterator&gt;&amp; y)
{
    <span class="hljs-keyword">return</span> !(y &lt; x);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Iterator&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-keyword">const</span> reverse_iterator&lt;Iterator&gt;&amp; x,
                       <span class="hljs-keyword">const</span> reverse_iterator&lt;Iterator&gt;&amp; y)
{
    <span class="hljs-keyword">return</span> !(x &lt; y);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Iterator&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">typename</span> reverse_iterator&lt;Iterator&gt;::difference_type
<span class="hljs-keyword">operator</span>-(<span class="hljs-keyword">const</span> reverse_iterator&lt;Iterator&gt;&amp; x,
          <span class="hljs-keyword">const</span> reverse_iterator&lt;Iterator&gt;&amp; y)
{
    <span class="hljs-keyword">return</span> y.base() - x.base();
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Iterator&gt;
<span class="hljs-keyword">inline</span> reverse_iterator&lt;Iterator&gt;
<span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">typename</span> reverse_iterator&lt;Iterator&gt;::difference_type n,
          <span class="hljs-keyword">const</span> reverse_iterator&lt;Iterator&gt;&amp; x)
{
    <span class="hljs-keyword">return</span> x.<span class="hljs-keyword">operator</span>+(n);
}</code></pre>



<h3 id="输入输出迭代器">输入输出迭代器</h3>

<p>输入迭代器有两个，分别为istream_iterator和istreambuf_iterator；输出迭代器有两个，分别为ostream_iterator和ostreambuf_iterator。 <br>
输入迭代器将自加操作转换为输入操作，输出迭代器将赋值转换为输出。 <br>
实现也不难，直接看源码吧。</p>

<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _Tp,
         <span class="hljs-keyword">class</span> _CharT = <span class="hljs-keyword">char</span>, <span class="hljs-keyword">class</span> _Traits = char_traits&lt;_CharT&gt;,
         <span class="hljs-keyword">class</span> _Dist = ptrdiff_t&gt;
<span class="hljs-keyword">class</span> istream_iterator
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> _CharT                         char_type;
    <span class="hljs-keyword">typedef</span> _Traits                        traits_type;
    <span class="hljs-keyword">typedef</span> basic_istream&lt;_CharT, _Traits&gt; istream_type;

    <span class="hljs-keyword">typedef</span> input_iterator_tag             iterator_category;
    <span class="hljs-keyword">typedef</span> _Tp                            value_type;
    <span class="hljs-keyword">typedef</span> _Dist                          difference_type;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> _Tp*                     pointer;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> _Tp&amp;                     reference;

    istream_iterator() : _M_stream(<span class="hljs-number">0</span>), _M_ok(<span class="hljs-keyword">false</span>) {}
    istream_iterator(istream_type&amp; s) : _M_stream(&amp;s)
    {
        _M_read();
    }

    reference <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> _M_value;
    }
    pointer <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> &amp;(<span class="hljs-keyword">operator</span>*());
    }

    istream_iterator&amp; <span class="hljs-keyword">operator</span>++()
    {
        _M_read();
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    istream_iterator <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>)
    {
        istream_iterator tmp = *<span class="hljs-keyword">this</span>;
        _M_read();
        <span class="hljs-keyword">return</span> tmp;
    }

    <span class="hljs-keyword">bool</span> _M_equal(<span class="hljs-keyword">const</span> istream_iterator&amp; x) <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> (_M_ok == x._M_ok) &amp;&amp; (!_M_ok || _M_stream == x._M_stream);
    }

<span class="hljs-keyword">private</span>:
    istream_type* _M_stream;
    _Tp _M_value;
    <span class="hljs-keyword">bool</span> _M_ok;

    <span class="hljs-keyword">void</span> _M_read()
    {
        _M_ok = (_M_stream &amp;&amp; *_M_stream) ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">if</span> (_M_ok)
        {
            *_M_stream &gt;&gt; _M_value;
            _M_ok = *_M_stream ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;
        }
    }
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _Tp, <span class="hljs-keyword">class</span> _CharT, <span class="hljs-keyword">class</span> _Traits, <span class="hljs-keyword">class</span> _Dist&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span>
<span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> istream_iterator&lt;_Tp, _CharT, _Traits, _Dist&gt;&amp; x,
           <span class="hljs-keyword">const</span> istream_iterator&lt;_Tp, _CharT, _Traits, _Dist&gt;&amp; y)
{
    <span class="hljs-keyword">return</span> x._M_equal(y);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _Tp, <span class="hljs-keyword">class</span> _CharT, <span class="hljs-keyword">class</span> _Traits, <span class="hljs-keyword">class</span> _Dist&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span>
<span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> istream_iterator&lt;_Tp, _CharT, _Traits, _Dist&gt;&amp; x,
           <span class="hljs-keyword">const</span> istream_iterator&lt;_Tp, _CharT, _Traits, _Dist&gt;&amp; y)
{
    <span class="hljs-keyword">return</span> !x._M_equal(y);
}


<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _Tp, <span class="hljs-keyword">class</span> _CharT = <span class="hljs-keyword">char</span>, <span class="hljs-keyword">class</span> _Traits = char_traits&lt;_CharT&gt; &gt;
<span class="hljs-keyword">class</span> ostream_iterator
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> _CharT                         char_type;
    <span class="hljs-keyword">typedef</span> _Traits                        traits_type;
    <span class="hljs-keyword">typedef</span> basic_ostream&lt;_CharT, _Traits&gt; ostream_type;

    <span class="hljs-keyword">typedef</span> output_iterator_tag            iterator_category;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span>                           value_type;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span>                           difference_type;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span>                           pointer;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span>                           reference;

    ostream_iterator(ostream_type&amp; s) : _M_stream(&amp;s), _M_string(<span class="hljs-number">0</span>) {}
    ostream_iterator(ostream_type&amp; s, <span class="hljs-keyword">const</span> _CharT* c)
        : _M_stream(&amp;s), _M_string(c)  {}
    ostream_iterator&lt;_Tp&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> _Tp&amp; value)
    {
        *_M_stream &lt;&lt; value;
        <span class="hljs-keyword">if</span> (_M_string) *_M_stream &lt;&lt; _M_string;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    ostream_iterator&lt;_Tp&gt;&amp; <span class="hljs-keyword">operator</span>*()
    {
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    ostream_iterator&lt;_Tp&gt;&amp; <span class="hljs-keyword">operator</span>++()
    {
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    ostream_iterator&lt;_Tp&gt;&amp; <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>)
    {
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
<span class="hljs-keyword">private</span>:
    ostream_type* _M_stream;
    <span class="hljs-keyword">const</span> _CharT* _M_string;
};</code></pre>

<p>ostreambuf_iterator和istreambuf_iterator的源码在sbuf_iter.h文件中，我也没有细看，直接贴上来了。</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _CharT, <span class="hljs-keyword">typename</span> _Traits&gt;
<span class="hljs-keyword">class</span> ostreambuf_iterator
    : <span class="hljs-keyword">public</span> iterator&lt;output_iterator_tag, <span class="hljs-keyword">void</span>, <span class="hljs-keyword">void</span>, <span class="hljs-keyword">void</span>, <span class="hljs-keyword">void</span>&gt;
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> _CharT                           char_type;
    <span class="hljs-keyword">typedef</span> _Traits                          traits_type;
    <span class="hljs-keyword">typedef</span> basic_streambuf&lt;_CharT, _Traits&gt; streambuf_type;
    <span class="hljs-keyword">typedef</span> basic_ostream&lt;_CharT, _Traits&gt;   ostream_type;

<span class="hljs-keyword">private</span>:
    streambuf_type*     _M_sbuf;
    <span class="hljs-keyword">bool</span>        _M_failed;

<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">inline</span> ostreambuf_iterator(ostream_type&amp; __s) <span class="hljs-keyword">throw</span> ()
        : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }

    ostreambuf_iterator(streambuf_type* __s) <span class="hljs-keyword">throw</span> ()
        : _M_sbuf(__s), _M_failed(!_M_sbuf) { }

    ostreambuf_iterator&amp;
    <span class="hljs-keyword">operator</span>=(_CharT __c);

    ostreambuf_iterator&amp;
    <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">throw</span>()
    {
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }

    ostreambuf_iterator&amp;
    <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">throw</span>()
    {
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }

    ostreambuf_iterator&amp;
    <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">throw</span>()
    {
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }

    <span class="hljs-keyword">bool</span>
    failed() <span class="hljs-keyword">const</span> <span class="hljs-keyword">throw</span>()
    {
        <span class="hljs-keyword">return</span> _M_failed;
    }
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _CharT, <span class="hljs-keyword">typename</span> _Traits&gt;
<span class="hljs-keyword">inline</span> ostreambuf_iterator&lt;_CharT, _Traits&gt;&amp;
ostreambuf_iterator&lt;_CharT, _Traits&gt;::<span class="hljs-keyword">operator</span>=(_CharT __c)
{
    <span class="hljs-keyword">if</span> (!_M_failed &amp;&amp;
            _Traits::eq_int_type(_M_sbuf-&gt;sputc(__c),_Traits::eof()))
        _M_failed = <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}


<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _CharT, <span class="hljs-keyword">typename</span> _Traits&gt;
<span class="hljs-keyword">class</span> istreambuf_iterator
    : <span class="hljs-keyword">public</span> iterator&lt;input_iterator_tag, _CharT, <span class="hljs-keyword">typename</span> _Traits::off_type,
      _CharT*, _CharT&amp;&gt;
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> _CharT                              char_type;
    <span class="hljs-keyword">typedef</span> _Traits                             traits_type;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> _Traits::int_type          int_type;
    <span class="hljs-keyword">typedef</span> basic_streambuf&lt;_CharT, _Traits&gt;        streambuf_type;
    <span class="hljs-keyword">typedef</span> basic_istream&lt;_CharT, _Traits&gt;          istream_type;
    <span class="hljs-keyword">typedef</span> istreambuf_iterator&lt;_CharT, _Traits&gt;    __istreambufiter_type;

<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">// If the end of stream is reached (streambuf_type::sgetc()</span>
    <span class="hljs-comment">// returns traits_type::eof()), the iterator becomes equal to</span>
    <span class="hljs-comment">// the "end of stream" iterator value.</span>
    <span class="hljs-comment">// NB: This implementation assumes the "end of stream" value</span>
    <span class="hljs-comment">// is EOF, or -1.</span>
    streambuf_type*         _M_sbuf;
    int_type            _M_c;

<span class="hljs-keyword">public</span>:
    istreambuf_iterator() <span class="hljs-keyword">throw</span>()
        : _M_sbuf(NULL), _M_c(-<span class="hljs-number">2</span>) { }

    istreambuf_iterator(istream_type&amp; __s) <span class="hljs-keyword">throw</span>()
        : _M_sbuf(__s.rdbuf()), _M_c(-<span class="hljs-number">2</span>) { }

    istreambuf_iterator(streambuf_type* __s) <span class="hljs-keyword">throw</span>()
        : _M_sbuf(__s), _M_c(-<span class="hljs-number">2</span>) { }

    <span class="hljs-comment">// NB: This should really have an int_type return</span>
    <span class="hljs-comment">// value, so "end of stream" postion can be checked without</span>
    <span class="hljs-comment">// hacking.</span>
    char_type
    <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span>
    {
        <span class="hljs-comment">// The result of operator*() on an end of stream is undefined.</span>
        char_type __ret;
        <span class="hljs-keyword">if</span> (_M_sbuf &amp;&amp; _M_c != <span class="hljs-keyword">static_cast</span>&lt;int_type&gt;(-<span class="hljs-number">2</span>))
            __ret = _M_c;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_M_sbuf)
            __ret = traits_type::to_char_type(_M_sbuf-&gt;sgetc());
        <span class="hljs-keyword">else</span>
            __ret = <span class="hljs-keyword">static_cast</span>&lt;char_type&gt;(traits_type::eof());
        <span class="hljs-keyword">return</span> __ret;
    }

    __istreambufiter_type&amp;
    <span class="hljs-keyword">operator</span>++()
    {
        <span class="hljs-keyword">if</span> (_M_sbuf)
            _M_sbuf-&gt;sbumpc();
        _M_c = -<span class="hljs-number">2</span>;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }

    __istreambufiter_type
    <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>)
    {
        __istreambufiter_type __old = *<span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">if</span> (_M_sbuf)
            __old._M_c = _M_sbuf-&gt;sbumpc();
        _M_c = -<span class="hljs-number">2</span>;
        <span class="hljs-keyword">return</span> __old;
    }

    <span class="hljs-keyword">bool</span>
    equal(<span class="hljs-keyword">const</span> __istreambufiter_type&amp; __b)
    {
        int_type __eof = traits_type::eof();
        <span class="hljs-keyword">bool</span> __thiseof = !_M_sbuf || _M_sbuf-&gt;sgetc() == __eof;
        <span class="hljs-keyword">bool</span> __beof = !__b._M_sbuf
                      || __b._M_sbuf-&gt;sgetc() == __eof;
        <span class="hljs-keyword">return</span> (__thiseof &amp;&amp; __beof || (!__thiseof &amp;&amp; !__beof));
    }
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _CharT, <span class="hljs-keyword">typename</span> _Traits&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span>
<span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> istreambuf_iterator&lt;_CharT, _Traits&gt;&amp; __a,
           <span class="hljs-keyword">const</span> istreambuf_iterator&lt;_CharT, _Traits&gt;&amp; __b)
{
    <span class="hljs-keyword">return</span> __a.equal(__b);
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _CharT, <span class="hljs-keyword">typename</span> _Traits&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span>
<span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> istreambuf_iterator&lt;_CharT, _Traits&gt;&amp; __a,
           <span class="hljs-keyword">const</span> istreambuf_iterator&lt;_CharT, _Traits&gt;&amp; __b)
{
    <span class="hljs-keyword">return</span> !__a.equal(__b);
}</code></pre></div></body>
</html>