<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STL之红黑树与hashtable概览</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><h2 id="红黑树setmap">红黑树，set，map</h2>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">// 红黑树, 这是一个内部容器, 不提供给外部使用,</span>
<span class="hljs-comment">// set/multiset和map/multimap都基于Rb_tree, 基本是转调了红黑树的接口而已.</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> Value, <span class="hljs-keyword">typename</span> KeyOfValue, <span class="hljs-keyword">typename</span> Compare,
         <span class="hljs-keyword">typename</span> Alloc = <span class="hljs-built_in">std</span>::allocator&lt;Value&gt; &gt;
<span class="hljs-keyword">class</span> _Rb_tree;

<span class="hljs-comment">// set</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> Compare = <span class="hljs-built_in">std</span>::less&lt;Key&gt;,
         <span class="hljs-keyword">typename</span> Alloc = <span class="hljs-built_in">std</span>::allocator&lt;Key&gt; &gt;
<span class="hljs-keyword">class</span> <span class="hljs-built_in">set</span>;

<span class="hljs-comment">// set内部用来存储数据的是</span>
_Rb_tree&lt;key_type, value_type, _Identity&lt;key_type&gt;, key_compare, allocator_type&gt; _Ref;

<span class="hljs-comment">// map</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> Tp, <span class="hljs-keyword">typename</span> Compare = <span class="hljs-built_in">std</span>::less&lt;Key&gt;,
         <span class="hljs-keyword">typename</span> Alloc = <span class="hljs-built_in">std</span>::allocator&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">const</span> Key, Tp&gt; &gt; &gt;
<span class="hljs-keyword">class</span> <span class="hljs-built_in">map</span>;

<span class="hljs-comment">// map内部用来存储数据的是</span>
_Rb_tree&lt;key_type, value_type, _Select1st&lt;value_type&gt;, key_compare, allocator_type&gt; _Ref;

<span class="hljs-comment">/** 红黑树的节点信息:
树每个节点用来存储数据的是一个Value类型的变量, 对于set来说, 类型Value就是类型Key,
而对于map来说, 类型Value是std::pair&lt;const Key, Tp&gt;.
需要根据这个Value类型的变量来执行比较操作:
首先从这个Value类型的变量中提取出Key类型的变量(通过KeyOfValue这个函数对象),
然后再通过Compare这个函数对象来执行比较(Compare接受两个Key类型的参数, 返回值是bool类型).

红黑树节点内部还有另外四个数据成员来描述其结构:
    _Color_type _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;
*/</span>

<span class="hljs-comment">// less类似这样</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-keyword">struct</span> less
{
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>() (<span class="hljs-keyword">const</span> T&amp; x, <span class="hljs-keyword">const</span> T&amp; y) <span class="hljs-keyword">const</span>
    { <span class="hljs-keyword">return</span> x&lt;y; }
    <span class="hljs-keyword">typedef</span> T first_argument_type;
    <span class="hljs-keyword">typedef</span> T second_argument_type;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">bool</span> result_type;
};

<span class="hljs-comment">// _Identity类似这样, 简单的返回参数</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> _Identity
{
    T&amp; <span class="hljs-keyword">operator</span>()(T&amp; x) <span class="hljs-keyword">const</span>
    { <span class="hljs-keyword">return</span> x; }
    <span class="hljs-keyword">const</span> T&amp; <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">const</span> T&amp; x) <span class="hljs-keyword">const</span>
    { <span class="hljs-keyword">return</span> x; }
};

<span class="hljs-comment">// _Select1st类似这样, 返回pair参数的first</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Pair&gt;
<span class="hljs-keyword">struct</span> _Select1st
{
    <span class="hljs-keyword">typename</span> Pair::first_type&amp;
    <span class="hljs-keyword">operator</span>()(Pair&amp; x) <span class="hljs-keyword">const</span>
    { <span class="hljs-keyword">return</span> x.first; }

    <span class="hljs-keyword">const</span> <span class="hljs-keyword">typename</span> _Pair::first_type&amp;
    <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">const</span> Pair&amp; x) <span class="hljs-keyword">const</span>
    { <span class="hljs-keyword">return</span> x.first; }
};

<span class="hljs-comment">/**
sgi的红黑树内部有一个header节点, 它的parent指向root节点, left指向最左节点, right指向最右节点.
begin()返回的是header的left, end()返回的是header, 这样调用begin()只消耗常数时间.
除此之外, 还有一个数据成员存储节点个数.
再加上执行比较功能的函数对象, 就可以完整标识一棵红黑树, 所以swap函数是这样的(假定allocator相同):
*/</span>
<span class="hljs-keyword">void</span> swap(_Rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;&amp; t)
{
    <span class="hljs-built_in">std</span>::swap(_M_header, t._M_header);
    <span class="hljs-built_in">std</span>::swap(_M_node_count, t._M_node_count);
    <span class="hljs-built_in">std</span>::swap(_M_key_compare, t._M_key_compare);
}</code></pre>



<h2 id="红黑树部分细节">红黑树部分细节</h2>

<p>下面展示红黑树迭代器的部分细节，和find函数的细节，其他部分暂无力理解。</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">// 迭代器的自加、自减</span>
<span class="hljs-keyword">struct</span> _Rb_tree_base_iterator
{
    <span class="hljs-keyword">typedef</span> _Rb_tree_node_base::_Base_ptr    _Base_ptr;
    <span class="hljs-keyword">typedef</span> bidirectional_iterator_tag       iterator_category;
    <span class="hljs-keyword">typedef</span> ptrdiff_t                        difference_type;

    _Base_ptr    _M_node;

    <span class="hljs-keyword">void</span> _M_increment()
    {
        <span class="hljs-keyword">if</span>(_M_node-&gt;_M_right != <span class="hljs-number">0</span>)
        {
            <span class="hljs-comment">// 如果有右子树, 下一个节点将是右子树的最左</span>
            _M_node = _M_node-&gt;_M_right;
            <span class="hljs-keyword">while</span>(_M_node-&gt;_M_left != <span class="hljs-number">0</span>)
                _M_node = _M_node-&gt;_M_left;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">// 如果没有右子树, 下一个节点在上面的层里</span>
            <span class="hljs-comment">// 如果当前节点是父节点的左孩子, 其父节点就是要找的下一个节点</span>
            <span class="hljs-comment">// 如果当前节点是父结点的右孩子, 一直上溯, 直到某个节点是其父结点的左孩子, 其父节点就是要找的下一个节点</span>
            _Base_ptr y = _M_node-&gt;_M_parent;
            <span class="hljs-keyword">while</span>(_M_node == y-&gt;_M_right)
            {
                _M_node = y;
                y = y-&gt;_M_parent;
            }
            <span class="hljs-comment">// 当root节点并无右子树, 且欲寻找root节点的下一节点时, 下面的if会为true, 下一节点就是header节点</span>
            <span class="hljs-comment">// 当前节点已为最大时, 自加将使之跳到header节点, 所以end()返回的也是header节点</span>
            <span class="hljs-keyword">if</span>(_M_node-&gt;_M_right != y)
                _M_node = y;
        }
    }

    <span class="hljs-keyword">void</span> _M_decrement()
    {
        <span class="hljs-keyword">if</span>(_M_node-&gt;_M_color == _S_rb_tree_red &amp;&amp;
           _M_node-&gt;_M_parent-&gt;_M_parent == _M_node)
            <span class="hljs-comment">// 当前节点为end()时, 也就是header时</span>
            _M_node = _M_node-&gt;_M_right;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(_M_node-&gt;_M_left != <span class="hljs-number">0</span>)
        {
            <span class="hljs-comment">// 当前节点有左子树时, 上一节点即为左子树的最右</span>
            _Base_ptr y = _M_node-&gt;_M_left;
            <span class="hljs-keyword">while</span>(y-&gt;_M_right != <span class="hljs-number">0</span>)
                y = y-&gt;_M_right;
            _M_node = y;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">// 当前节点无左子树时, 上一节点在上面的层里</span>
            <span class="hljs-comment">// 若为父节点的右孩子, 父节点即为下一节点</span>
            <span class="hljs-comment">// 若为父节点的左孩子, 一直上溯, 直到某个节点是其父节点的右孩子, 其父节点就是要找的下一节点</span>
            _Base_ptr y = _M_node-&gt;_M_parent;
            <span class="hljs-keyword">while</span>(_M_node == y-&gt;_M_left)
            {
                _M_node = y;
                y = y-&gt;_M_parent;
            }
            _M_node = y;
        }
    }
};

<span class="hljs-comment">// 需找RB树中是否有键值为k的节点</span>
<span class="hljs-comment">// 为何非要找到底呢, 找到相等的返回不就完了?</span>
<span class="hljs-comment">// lower_bound和upper_bound的动作与此类似</span>
<span class="hljs-comment">// equal_range就是调用了pair&lt;iterator,iterator&gt;(lower_bound(k),upper_bound(k));</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> Value, <span class="hljs-keyword">typename</span> KeyOfValue,
         <span class="hljs-keyword">typename</span> Compare, <span class="hljs-keyword">typename</span> Alloc&gt;
<span class="hljs-keyword">typename</span> _Rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::iterator
_Rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::find(<span class="hljs-keyword">const</span> Key&amp; k)
{
    _Link_type y = _M_header;      <span class="hljs-comment">// Last node which is not less than k.</span>
    _Link_type x = _M_root();      <span class="hljs-comment">// Current node.</span>

    <span class="hljs-keyword">while</span>(x != <span class="hljs-number">0</span>)
        <span class="hljs-keyword">if</span>(!_M_key_compare(_S_key(x), k)) <span class="hljs-comment">// k小于等于节点值, 去左子树继续寻找</span>
            y = x, x = _S_left(x); <span class="hljs-comment">// 记下大于等于k的节点</span>
        <span class="hljs-keyword">else</span> <span class="hljs-comment">// k大于节点值, 去右子树继续寻找</span>
            x = _S_right(x);

    iterator j = iterator(y);
    <span class="hljs-comment">// 若树为空, x等于0, j将等于end()</span>
    <span class="hljs-comment">// 若k小于y, 表示没有要找的节点</span>
    <span class="hljs-keyword">return</span> (j == end() || _M_key_compare(k, _S_key(j._M_node))) ?
           end() : j;
}</code></pre>



<h2 id="hashtablehashsethashmap">hashtable，hash_set，hash_map</h2>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">// hash_set和hash_map是gcc提供的, 定义在命名空间__gnu_cxx中</span>
<span class="hljs-comment">// 在c++11里, unordered_map和unordered_set已经替换了hash_set和hash_map</span>

<span class="hljs-comment">/**
与set和map相比, hash_set和hash_map无非是把数据存储到了hashtable而不是红黑树里, 接口与set和map基本相同.
与红黑树的逻辑相似, hashtable节点中有一个Value类型的数据,
通过一个函数对象从Value数据中提取出Key类型的数据,
然后由这个Key类型的数据来确定这个节点的存储位置.
HashFcn是一个函数对象, 它接受一个Key类型的参数,
返回值类型为size_t, 就是通过它确定节点应存储在什么位置;
ExtractKey是一个函数对象, 从Value对象中提取出Key对象,
它和红黑树中KeyOfValue的作用是一样的;
EqualKey是一个函数对象, 用来判断两个Key对象是否相等.
*/</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Value, <span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> HashFcn,
         <span class="hljs-keyword">typename</span> ExtractKey, <span class="hljs-keyword">typename</span> EqualKey,
         <span class="hljs-keyword">typename</span> Alloc = <span class="hljs-built_in">std</span>::allocator&lt;Value&gt; &gt;
<span class="hljs-keyword">class</span> hashtable;

<span class="hljs-comment">// hash_set</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Value,
         <span class="hljs-keyword">typename</span> HashFcn  = hash&lt;Value&gt;,
         <span class="hljs-keyword">typename</span> EqualKey = equal_to&lt;Value&gt;,
         <span class="hljs-keyword">typename</span> Alloc =  allocator&lt;Value&gt; &gt;
<span class="hljs-keyword">class</span> hash_set;

<span class="hljs-comment">// hash_set内部用来存储数据的是</span>
<span class="hljs-keyword">typedef</span> hashtable&lt;Value, Value, HashFcn,
                 _Identity&lt;_Value&gt;, EqualKey, Alloc&gt; _Ht;

<span class="hljs-comment">// hash_map</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> Tp,
         <span class="hljs-keyword">typename</span> HashFcn  = hash&lt;Key&gt;,
         <span class="hljs-keyword">typename</span> EqualKey = equal_to&lt;Key&gt;,
         <span class="hljs-keyword">typename</span> Alloc =  allocator&lt;Tp&gt; &gt;
<span class="hljs-keyword">class</span> hash_map;

<span class="hljs-comment">// hash_map内部用来存储数据的是</span>
<span class="hljs-keyword">typedef</span> hashtable&lt;pair&lt;<span class="hljs-keyword">const</span> Key,Tp&gt;, Key, HashFcn,
                 _Select1st&lt;pair&lt;<span class="hljs-keyword">const</span> Key,Tp&gt; &gt;, EqualKey, Alloc&gt; _Ht;</code></pre>

<p>与hashtable，hash_set，hash_multiset，hash_map，hash_multimap相关的头文件有stl_hashtable.h，stl_hash_fun.h，hash_set，hash_map。 <br>
stl_hashtable.h中定义了hashtable，stl_hash_fun.h定义了常见类型的hash函数，hash_set中定义了hash_set和hash_multiset，hash_map中定义了hash_map和hash_multimap。</p>

<p>stl_hash_fun.h里定义了常见整型的hash函数，只是简单的返回它们本身的值；还定义了字符串的hash函数。 <br>
除此之外的其他类型，都需要自行定义hash函数，如果对该文件提供的hash函数不满意，也可以自行定义。</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key&gt; <span class="hljs-keyword">struct</span> hash { };

<span class="hljs-keyword">inline</span> size_t __stl_hash_string(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s)
{
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> h = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> ( ; *s; ++s)
        h = <span class="hljs-number">5</span>*h + *s;
    <span class="hljs-keyword">return</span> size_t(h);
}

<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> hash&lt;<span class="hljs-keyword">char</span>*&gt;
{
    size_t <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s) <span class="hljs-keyword">const</span>
    { <span class="hljs-keyword">return</span> __stl_hash_string(s); }
};

<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> hash&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt;
{
    size_t <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s) <span class="hljs-keyword">const</span>
    { <span class="hljs-keyword">return</span> __stl_hash_string(s); }
};

<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> hash&lt;<span class="hljs-keyword">char</span>&gt;
{
    size_t <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">char</span> x) <span class="hljs-keyword">const</span>
    { <span class="hljs-keyword">return</span> x; }
};
<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> hash&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt;
{
    size_t <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> x) <span class="hljs-keyword">const</span>
    { <span class="hljs-keyword">return</span> x; }
};
<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> hash&lt;<span class="hljs-keyword">signed</span> <span class="hljs-keyword">char</span>&gt;
{
    size_t <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> x) <span class="hljs-keyword">const</span>
    { <span class="hljs-keyword">return</span> x; }
};

<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> hash&lt;<span class="hljs-keyword">short</span>&gt;
{
    size_t <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">short</span> x) <span class="hljs-keyword">const</span>
    { <span class="hljs-keyword">return</span> x; }
};
<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> hash&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>&gt;
{
    size_t <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> x) <span class="hljs-keyword">const</span>
    { <span class="hljs-keyword">return</span> x; }
};

<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> hash&lt;<span class="hljs-keyword">int</span>&gt;
{
    size_t <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">int</span> x) <span class="hljs-keyword">const</span>
    { <span class="hljs-keyword">return</span> x; }
};
<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> hash&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt;
{
    size_t <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> x) <span class="hljs-keyword">const</span>
    { <span class="hljs-keyword">return</span> x; }
};

<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> hash&lt;<span class="hljs-keyword">long</span>&gt;
{
    size_t <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">long</span> x) <span class="hljs-keyword">const</span>
    { <span class="hljs-keyword">return</span> x; }
};
<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> hash&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>&gt;
{
    size_t <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> x) <span class="hljs-keyword">const</span>
    { <span class="hljs-keyword">return</span> x; }
};</code></pre>

<pre><code>sgi以开链法完成hashtable, 称hashtable的数组为buckets, 以std::vector完成,
buckets vector每个元素的类型是指向节点的指针.

如何确定节点在哪个bucket?
先对Key取hash后, 再执行"hash值%vector的大小"获得其bucket.
关于buckets vector的大小
sgi内部定义了一个拥有28个元素的整型数组, 存储了28个质数,
这些质数逐渐呈现大约两倍的关系, 最小的质数是53,
hashtable自动将大小提升为最接近且足够容纳所有节点的质数.
这样设计保证了hashtable足够稀疏.
</code></pre>

<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">// 迭代器内有一个指向节点的指针, 一个指向hashtable的指针.</span>
<span class="hljs-comment">// 这是它的自加操作, 并不提供自减操作:</span>
iterator&amp; <span class="hljs-keyword">operator</span>++()
{
    <span class="hljs-keyword">const</span> _Node* __old = _M_cur;
    _M_cur = _M_cur-&gt;_M_next; <span class="hljs-comment">// 链表的下一个节点</span>
    <span class="hljs-keyword">if</span>(!_M_cur) <span class="hljs-comment">// 链表如已到结尾, 则要在vector里跳到下一个bucket</span>
    {
        <span class="hljs-comment">// 获得原节点所在的bucket</span>
        size_type __bucket = _M_ht-&gt;_M_bkt_num(__old-&gt;_M_val);
        <span class="hljs-comment">// 当找到下一节点结束</span>
        <span class="hljs-comment">// 或后面的bucket空无一物时也结束, 此时_M_cur为空, 迭代器与end()相等</span>
        <span class="hljs-keyword">while</span> (!_M_cur &amp;&amp; ++__bucket &lt; _M_ht-&gt;_M_buckets.size())
            _M_cur = _M_ht-&gt;_M_buckets[__bucket];
    }
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

<span class="hljs-comment">// hashtable理解起来并不困难, 我也懒得去标注源代码了.</span></code></pre>

<p>hash_set和hash_map缺省使用大小为100的表格，hashtable将调整为193。</p></div></body>
</html>