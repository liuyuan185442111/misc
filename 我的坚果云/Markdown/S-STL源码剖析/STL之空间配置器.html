<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STL之空间配置器</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><p>空间配置器是memory的一部分，以下提供的代码均取自或稍修改自stl_alloc.h。</p>



<h2 id="c标准对空间配置器的规范">C++标准对空间配置器的规范</h2>

<p>标准规范只定义了一个空间配置器，所有的标准容器如果他们的最后一个模板参数未被设置，将会使用这个默认空间配置器：</p>

<pre><code>template &lt;typename T&gt; class allocator;
</code></pre>

<p>任何与默认空间配置器有相同成员并且满足其最小要求的其他空间配置器也可被标准容器用作空间配置器。 <br>
根据C++标准的规范，以下是allocator的必要接口：</p>



<h3 id="成员类型">成员类型</h3>

<table>
<thead>
<tr>
  <th>member</th>
  <th>definition</th>
  <th>represents</th>
</tr>
</thead>
<tbody><tr>
  <td>value_type</td>
  <td>T</td>
  <td>Element type</td>
</tr>
<tr>
  <td>pointer</td>
  <td>T*</td>
  <td>Pointer to element</td>
</tr>
<tr>
  <td>reference</td>
  <td>T&amp;</td>
  <td>Reference to element</td>
</tr>
<tr>
  <td>const_pointer</td>
  <td>const T*</td>
  <td>Pointer to constant element</td>
</tr>
<tr>
  <td>const_reference</td>
  <td>const T&amp;</td>
  <td>Reference to constant element</td>
</tr>
<tr>
  <td>size_type</td>
  <td>size_t</td>
  <td>Quantities of elements</td>
</tr>
<tr>
  <td>difference_type</td>
  <td>ptrdiff_t</td>
  <td>Difference between two pointers</td>
</tr>
<tr>
  <td>rebind&lt;Type&gt;</td>
  <td>一个模板类</td>
  <td>拥有唯一成员other，那是一个typedef，代表allocator&lt;Type&gt;</td>
</tr>
</tbody></table>




<h3 id="成员函数">成员函数</h3>



<pre class="prettyprint"><code class=" hljs cpp">allocator::allocator()
    默认构造函数
allocator::allocator(<span class="hljs-keyword">const</span> allocator&amp;)
    复制构造函数
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;
allocator::allocator(<span class="hljs-keyword">const</span> allocator&lt;U&gt;&amp;)
    泛化的复制构造函数
allocator::~allocator()
    析构函数
pointer allocator::address(reference x) <span class="hljs-keyword">const</span>
    返回某个对象的地址。a.address(x)等同于&amp;x
const_pointer allocator::address(const_reference x) <span class="hljs-keyword">const</span>
    返回某个<span class="hljs-keyword">const</span>对象的地址。a.address(x)等同于&amp;x
pointer allocator::allocate(size_type n, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* = <span class="hljs-number">0</span>)
    配置空间，足以存储n个T对象。第二参数是个提示，实现上可能会利用它来增进区域性，或完全忽略之
<span class="hljs-keyword">void</span> allocator::deallocate(pointer p, size_type n)
    归还先前配置的空间
size_type allocator::max_size() <span class="hljs-keyword">const</span>
    返回可成功配置的最大量
<span class="hljs-keyword">void</span> allocator::construct(pointer p, <span class="hljs-keyword">const</span> T &amp;x)
    等同于<span class="hljs-keyword">new</span>((<span class="hljs-keyword">void</span>*)p) T(x)
<span class="hljs-keyword">void</span> allocator::destroy(pointer p)
    等同于p-&gt;~T()</code></pre>



<h3 id="specialization">specialization</h3>

<p>memory头文件提供了一个void类型空间配置器的specialization，定义如下：</p>



<pre class="prettyprint"><code class=" hljs d"><span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">class</span> allocator&lt;<span class="hljs-keyword">void</span>&gt;
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span>* pointer;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* const_pointer;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span> value_type;
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> U&gt; <span class="hljs-keyword">struct</span> rebind { <span class="hljs-keyword">typedef</span> allocator&lt;U&gt; other; };
};</code></pre>



<h2 id="gcc的实现">gcc的实现</h2>

<p>gcc中定义的allocator完全符合标准的要求：</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Tp&gt;
<span class="hljs-keyword">class</span> allocator
{
    <span class="hljs-keyword">typedef</span> alloc _Alloc; <span class="hljs-comment">// 启用的配置器</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> size_t     size_type;
    <span class="hljs-keyword">typedef</span> ptrdiff_t  difference_type;
    <span class="hljs-keyword">typedef</span> _Tp*       pointer;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> _Tp* const_pointer;
    <span class="hljs-keyword">typedef</span> _Tp&amp;       reference;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> _Tp&amp; const_reference;
    <span class="hljs-keyword">typedef</span> _Tp        value_type;

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _Tp1&gt; <span class="hljs-keyword">struct</span> rebind
    {
        <span class="hljs-keyword">typedef</span> allocator&lt;_Tp1&gt; other;
    };

    allocator() <span class="hljs-keyword">throw</span>() {}
    allocator(<span class="hljs-keyword">const</span> allocator&amp;) <span class="hljs-keyword">throw</span>() {}
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _Tp1&gt; allocator(<span class="hljs-keyword">const</span> allocator&lt;_Tp1&gt;&amp;) <span class="hljs-keyword">throw</span>() {}
    ~allocator() <span class="hljs-keyword">throw</span>() {}

    pointer address(reference __x) <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> &amp;__x;
    }
    const_pointer address(const_reference __x) <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> &amp;__x;
    }

    <span class="hljs-comment">// The C++ standard 没有说明 n 为 0 时返回何值</span>
    _Tp* allocate(size_type __n, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* = <span class="hljs-number">0</span>)
    {
        <span class="hljs-keyword">return</span> __n != <span class="hljs-number">0</span> ? <span class="hljs-keyword">static_cast</span>&lt;_Tp*&gt;(_Alloc::allocate(__n * <span class="hljs-keyword">sizeof</span>(_Tp))) : <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">// p 不允许为空指针</span>
    <span class="hljs-keyword">void</span> deallocate(pointer __p, size_type __n)
    {
        _Alloc::deallocate(__p, __n * <span class="hljs-keyword">sizeof</span>(_Tp));
    }

    <span class="hljs-comment">// 这个实现的也太糊弄了</span>
    size_type max_size() <span class="hljs-keyword">const</span> <span class="hljs-keyword">throw</span>()
    {
        <span class="hljs-keyword">return</span> size_t(-<span class="hljs-number">1</span>) / <span class="hljs-keyword">sizeof</span>(_Tp);
    }

    <span class="hljs-comment">// 通过 placement new 来进行构造</span>
    <span class="hljs-keyword">void</span> construct(pointer __p, <span class="hljs-keyword">const</span> _Tp&amp; __val)
    {
        <span class="hljs-keyword">new</span>(__p) _Tp(__val);
    }
    <span class="hljs-keyword">void</span> destroy(pointer __p)
    {
        __p-&gt;~_Tp();
    }
};

<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-keyword">class</span> allocator&lt;<span class="hljs-keyword">void</span>&gt;
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> size_t      size_type;
    <span class="hljs-keyword">typedef</span> ptrdiff_t   difference_type;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span>*       pointer;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* const_pointer;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span>        value_type;

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _Tp1&gt; <span class="hljs-keyword">struct</span> rebind
    {
        <span class="hljs-keyword">typedef</span> allocator&lt;_Tp1&gt; other;
    };
};</code></pre>

<p>allocator是提供给标准容器或其他组件的接口，实际操作是由alloc这个空间配置器来实现的。 <br>
gcc另外实现了两个空间配置器，分别是一级配置器（__malloc_alloc_template）和二级配置器（__default_alloc_template），他们需要至少提供allocate( )和deallocate( )作为接口。默认启用的是二级配置器。</p>



<pre class="prettyprint"><code class=" hljs d"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">int</span> __inst&gt;
<span class="hljs-keyword">class</span> __malloc_alloc_template;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-built_in">bool</span> threads, <span class="hljs-keyword">int</span> inst&gt;
<span class="hljs-keyword">class</span> __default_alloc_template;</code></pre>

<p>通过typedef将__default_alloc_template定义为alloc：</p>



<pre class="prettyprint"><code class=" hljs d"><span class="hljs-keyword">typedef</span> __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, <span class="hljs-number">0</span>&gt; alloc;
<span class="hljs-keyword">typedef</span> __default_alloc_template&lt;<span class="hljs-literal">false</span>, <span class="hljs-number">0</span>&gt; single_client_alloc;</code></pre>

<p>用户应仅使用alloc，__default_alloc_template 在将来可能会有所修改。 <br>
为简单起见，这里忽略多线程的情况，但alloc是支持多线程的。</p>

<h3 id="一级空间配置器">一级空间配置器</h3>

<p>一级配置器只是简单封装了malloc( )和free( )：</p>



<pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/**************************************************************
   一级配置器
**************************************************************/</span>
template &lt;<span class="hljs-keyword">int</span> __inst&gt;
class __malloc_alloc_template
{
<span class="hljs-keyword">private</span>:
    // out-of-memory handling
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">_S_oom_malloc</span>(size_t);
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *_S_oom_realloc(<span class="hljs-keyword">void</span>*, size_t);
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> (*__malloc_alloc_oom_handler)();

<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">allocate</span>(size_t __n)
    {
        <span class="hljs-keyword">void</span> *__result = malloc(__n);
        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == __result) __result = _S_oom_malloc(__n);
        <span class="hljs-keyword">return</span> __result;
    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> deallocate(<span class="hljs-keyword">void</span>* __p, size_t <span class="hljs-comment">/* __n */</span>)
    {
        free(__p);
    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* reallocate(<span class="hljs-keyword">void</span>* __p, size_t <span class="hljs-comment">/* old_sz */</span>, size_t __new_sz)
    {
        <span class="hljs-keyword">void</span> *__result = realloc(__p, __new_sz);
        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == __result) __result = _S_oom_realloc(__p, __new_sz);
        <span class="hljs-keyword">return</span> __result;
    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> (* __set_malloc_handler(<span class="hljs-keyword">void</span> (*__f)()))()
    {
        <span class="hljs-keyword">void</span> (*__old)() = __malloc_alloc_oom_handler;
        __malloc_alloc_oom_handler = __f;
        <span class="hljs-keyword">return</span>(__old);
    }
};

template &lt;<span class="hljs-keyword">int</span> __inst&gt;
<span class="hljs-keyword">void</span> (* __malloc_alloc_template&lt;__inst&gt;::__malloc_alloc_oom_handler)() = <span class="hljs-number">0</span>;

template &lt;<span class="hljs-keyword">int</span> __inst&gt;
<span class="hljs-keyword">void</span> *__malloc_alloc_template&lt;__inst&gt;::_S_oom_malloc(size_t __n)
{
    <span class="hljs-keyword">void</span> (*__my_malloc_handler)();
    <span class="hljs-keyword">void</span> *__result;

    <span class="hljs-keyword">for</span> (;;)
    {
        __my_malloc_handler = __malloc_alloc_oom_handler;
        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == __my_malloc_handler)
        {
            std::__throw_bad_alloc();
        }
        (*__my_malloc_handler)();
        __result = malloc(__n);
        <span class="hljs-keyword">if</span> (__result) <span class="hljs-keyword">return</span>(__result);
    }
}

template &lt;<span class="hljs-keyword">int</span> __inst&gt;
<span class="hljs-keyword">void</span> *__malloc_alloc_template&lt;__inst&gt;::_S_oom_realloc(<span class="hljs-keyword">void</span>* __p, size_t __n)
{
    <span class="hljs-keyword">void</span> (*__my_malloc_handler)();
    <span class="hljs-keyword">void</span> *__result;

    <span class="hljs-keyword">for</span> (;;)
    {
        __my_malloc_handler = __malloc_alloc_oom_handler;
        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == __my_malloc_handler)
        {
            std::__throw_bad_alloc();
        }
        (*__my_malloc_handler)();
        __result = realloc(__p, __n);
        <span class="hljs-keyword">if</span> (__result) <span class="hljs-keyword">return</span>(__result);
    }
}

typedef __malloc_alloc_template&lt;<span class="hljs-number">0</span>&gt; malloc_alloc;</code></pre>

<p>因为malloc( )没有类似new handler机制，所以一级配置器自己实现了一个类似的机制：如果allocate( )调用malloc( )不成功，改调用oom_malloc( )，oom_malloc( )在内部会调用__my_malloc_handler( )，如果__my_malloc_handler( )未被设定，就抛出一个bad_alloc异常。</p>



<h3 id="二级空间配置器">二级空间配置器</h3>

<p>gcc对二级空间配置器的描述是： <br>
Important implementation properties: <br>
1. If the client request an object of size &gt; _MAX_BYTES, the resulting object will be obtained directly from malloc. <br>
2. In all other cases, we allocate an object of size exactly _S_round_up(requested_size).  Thus the client has enough size information that we can return the object to the proper free list without permanently losing part of the object.</p>

<p>侯捷在《STL源码剖析》里对此的说明是： <br>
提供了一个二级空间配置器，如果区块够大，超过128 bytes，就移交给第一级配置器处理。当区块小于128 bytes时，则以内存池管理，此法又称为次层配置（sub-allocation）：每次配置一大块内存，并维护对应之自由链表。下次若再有相同大小的内存需求，直接从free lists中取出。如果用户释放小额块，就由配置器回收到free-lists中。</p>

<p>为了方便管理，第二级配置器会主动将任何小额区块的内存量上调至8的倍数，并维护16个free lists，各自管理的大小分别为8,16,24,32,40,48,56,64,72,80,88,96,104,112,150,128 bytes的小额区块。</p>

<p>每个free list的节点类型是：</p>



<pre class="prettyprint"><code class=" hljs livecodeserver"><span class="hljs-built_in">union</span> obj
{
    <span class="hljs-built_in">union</span> obj* free_list_link;<span class="hljs-comment"> // 用于维护空闲内存，指向下一个空闲节点  </span>
    <span class="hljs-keyword">char</span> client_data[<span class="hljs-number">1</span>];   <span class="hljs-comment"> // 用于用户使用  </span>
}</code></pre>

<p>一直不能理解，直到我看到：</p>

<blockquote>
  <p>注意节点是union类型的，当节点空闲(未被分配时)，节点使用第一字段指向下一个空闲节点，当节点被分配后，用户可以直接使用第二字段，这样自由链表就不会因为free_list_link指针而造成内存的浪费（当节点被分配出去后，free_list_link指针就没有意义了）。</p>
</blockquote>

<p>才恍然大悟，obj 代表这样一段内存空间，前四个字节是一个指针，当这段内存在free list中时，这个指针指向下一段内存。 <br>
但为什么是char数组？ <br>
其实，这个char数组不是必须的，我们需要的只是一个地址而已，大不了做个强制转换而已（测试代码）：</p>

<pre><code>char heap[10];
obj *result = (obj*)heap;
char *r = (char*)result;
</code></pre>

<p>但如果引入一个char数组，则不需要强制转换了，<code>char *r = result-&gt;client_data;</code>。这里的char数组也可以换成其他类型，甚至是指针类型，但此时比较不好理解，比如<code>char *client_data;</code>，则必须写成这样<code>char *r = (char*)(&amp;result-&gt;client_data);</code>。</p>

<p>下面是二级配置器的实现代码（我稍微做了些调整）：</p>



<pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/**************************************************************
   二级配置器
**************************************************************/</span>

template &lt;bool threads, <span class="hljs-keyword">int</span> inst&gt;
class __default_alloc_template
{
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> _ALIGN = <span class="hljs-number">8</span>; <span class="hljs-comment">// 8字节对齐</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> _MAX_BYTES = <span class="hljs-number">128</span>; <span class="hljs-comment">// 可管理的最大字节数</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> _NFREELISTS = <span class="hljs-number">16</span>; <span class="hljs-comment">// free lists 数目 _MAX_BYTES/_ALIGN</span>

    <span class="hljs-comment">// 将要分配字节数提升至8的整数倍</span>
    <span class="hljs-keyword">static</span> size_t _S_round_up(size_t __bytes)
    {
        <span class="hljs-keyword">return</span> (((__bytes) + (size_t) _ALIGN-<span class="hljs-number">1</span>) &amp; ~((size_t) _ALIGN - <span class="hljs-number">1</span>));
    }

    union _Obj
    {
        union _Obj* _M_free_list_link;
        <span class="hljs-keyword">char</span> _M_client_data[<span class="hljs-number">1</span>];    <span class="hljs-comment">/* The client sees this. */</span>
    };

    <span class="hljs-keyword">static</span> _Obj* <span class="hljs-keyword">volatile</span> _S_free_list[];

    <span class="hljs-comment">// 确定应在哪个 list</span>
    <span class="hljs-keyword">static</span> size_t _S_freelist_index(size_t __bytes)
    {
        <span class="hljs-keyword">return</span> (((__bytes) + (size_t)_ALIGN-<span class="hljs-number">1</span>)/(size_t)_ALIGN - <span class="hljs-number">1</span>);
    }

    <span class="hljs-comment">// 重点实现代码, 后面介绍</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* _S_refill(size_t __n);
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>* _S_chunk_alloc(size_t __size, <span class="hljs-keyword">int</span> &amp;__nobjs);

    <span class="hljs-comment">// Chunk allocation state, chunk_alloc 里使用</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>* _S_start_free; <span class="hljs-comment">// 内存池起始地址</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>* _S_end_free; <span class="hljs-comment">// 内存池结束地址</span>
    <span class="hljs-keyword">static</span> size_t _S_heap_size; <span class="hljs-comment">// 内存池大小</span>

<span class="hljs-keyword">public</span>:
    // 从 free list 头部取出一个大小为 n 的区块, n 大于 0
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">allocate</span>(size_t __n)
    {
        <span class="hljs-keyword">void</span> *__ret = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">if</span> (__n &gt; (size_t) _MAX_BYTES)
        {
            <span class="hljs-comment">// 超过 128 bytes, 直接请求一级配置器</span>
            __ret = malloc_alloc::allocate(__n);
        }
        <span class="hljs-keyword">else</span>
        {
            _Obj* <span class="hljs-keyword">volatile</span>* __my_free_list = _S_free_list + _S_freelist_index(__n);

            _Obj* __result = *__my_free_list;
            <span class="hljs-keyword">if</span> (__result == <span class="hljs-number">0</span>) <span class="hljs-comment">// list 为空</span>
                __ret = _S_refill(_S_round_up(__n)); <span class="hljs-comment">// 从内存池取一些</span>
            <span class="hljs-keyword">else</span>
            {
                *__my_free_list = __result -&gt; _M_free_list_link;
                __ret = __result;
            }
        }

        <span class="hljs-keyword">return</span> __ret;
    };

    <span class="hljs-comment">// 回收区块到 free list 头部, p 不为空</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> deallocate(<span class="hljs-keyword">void</span>* __p, size_t __n)
    {
        <span class="hljs-keyword">if</span> (__n &gt; (size_t) _MAX_BYTES)
            malloc_alloc::deallocate(__p, __n);
        <span class="hljs-keyword">else</span>
        {
            _Obj* <span class="hljs-keyword">volatile</span>* __my_free_list = _S_free_list + _S_freelist_index(__n);
            _Obj* __q = (_Obj*)__p;

            __q -&gt; _M_free_list_link = *__my_free_list;
            *__my_free_list = __q;
        }
    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* reallocate(<span class="hljs-keyword">void</span>* __p, size_t __old_sz, size_t __new_sz)
    {
        <span class="hljs-keyword">void</span> *__result;
        size_t __copy_sz;

        <span class="hljs-keyword">if</span> (__old_sz &gt; (size_t) _MAX_BYTES &amp;&amp; __new_sz &gt; (size_t) _MAX_BYTES)
        {
            <span class="hljs-keyword">return</span>(realloc(__p, __new_sz));
        }
        <span class="hljs-keyword">if</span> (_S_round_up(__old_sz) == _S_round_up(__new_sz)) <span class="hljs-keyword">return</span>(__p);
        __result = allocate(__new_sz);
        __copy_sz = __new_sz &gt; __old_sz? __old_sz : __new_sz;
        memcpy(__result, __p, __copy_sz);
        deallocate(__p, __old_sz);
        <span class="hljs-keyword">return</span>(__result);
    }
};


template &lt;bool __threads, <span class="hljs-keyword">int</span> __inst&gt;
<span class="hljs-keyword">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_start_free = <span class="hljs-number">0</span>;

template &lt;bool __threads, <span class="hljs-keyword">int</span> __inst&gt;
<span class="hljs-keyword">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_end_free = <span class="hljs-number">0</span>;

template &lt;bool __threads, <span class="hljs-keyword">int</span> __inst&gt;
size_t __default_alloc_template&lt;__threads, __inst&gt;::_S_heap_size = <span class="hljs-number">0</span>;

template &lt;bool __threads, <span class="hljs-keyword">int</span> __inst&gt;
typename __default_alloc_template&lt;__threads, __inst&gt;::_Obj* <span class="hljs-keyword">volatile</span>
__default_alloc_template&lt;__threads, __inst&gt; ::_S_free_list[
    __default_alloc_template&lt;__threads, __inst&gt;::_NFREELISTS
] = {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>};


<span class="hljs-comment">// 被 refill() 调用, 从内存池中取空间给 free list 使用</span>
<span class="hljs-comment">// 分配 nobjs 个大小为 size 的区块, 它们占用连续的内存, 实际分配的数量存储于 nobjs 中, 函数返回所分配内存的起始地址</span>
template &lt;bool __threads, <span class="hljs-keyword">int</span> __inst&gt;
<span class="hljs-keyword">char</span> *__default_alloc_template&lt;__threads, __inst&gt;::
_S_chunk_alloc(size_t __size, <span class="hljs-keyword">int</span> &amp;__nobjs)
{
    <span class="hljs-keyword">char</span> *__result;
    size_t __total_bytes = __size * __nobjs;
    size_t __bytes_left = _S_end_free - _S_start_free; <span class="hljs-comment">// 内存池剩余空间</span>

    <span class="hljs-keyword">if</span> (__bytes_left &gt;= __total_bytes)
    {
        <span class="hljs-comment">// 内存池剩余空间完全满足需求量</span>
        __result = _S_start_free;
        _S_start_free += __total_bytes;
        <span class="hljs-keyword">return</span>(__result);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (__bytes_left &gt;= __size)
    {
        <span class="hljs-comment">// 内存池剩余空间不能完全满足需求量, 但能够供应至少一个区块</span>
        __nobjs = (<span class="hljs-keyword">int</span>)(__bytes_left/__size);
        __total_bytes = __size * __nobjs;
        __result = _S_start_free;
        _S_start_free += __total_bytes;
        <span class="hljs-keyword">return</span>(__result);
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">// 内存池剩余空间连一个区块的大小能不能提供</span>
        <span class="hljs-comment">// 利用 malloc() 从 heap 中配置内存, 大小为需求量的两倍, 再加上一个随着配置次数增加而越来越大的附加量</span>
        size_t __bytes_to_get = <span class="hljs-number">2</span> * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="hljs-number">4</span>);
        <span class="hljs-comment">// Try to make use of the left-over piece</span>
        <span class="hljs-comment">// 尝试将内存池中剩余的残余空间分配到适当的 free list 中</span>
        <span class="hljs-comment">// bytes_left 一定是8的整数倍</span>
        <span class="hljs-keyword">if</span> (__bytes_left &gt; <span class="hljs-number">0</span>)
        {
            _Obj* <span class="hljs-keyword">volatile</span>* __my_free_list = _S_free_list + _S_freelist_index(__bytes_left);

            ((_Obj*)_S_start_free) -&gt; _M_free_list_link = *__my_free_list;
            *__my_free_list = (_Obj*)_S_start_free;
        }

        <span class="hljs-comment">// 尝试从 heap 中配置内存</span>
        _S_start_free = (<span class="hljs-keyword">char</span>*)malloc(__bytes_to_get);
        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == _S_start_free)
        {
            <span class="hljs-comment">// heap 空间不足, malloc() 失败, 无法获得内存</span>
            size_t __i;
            _Obj* <span class="hljs-keyword">volatile</span>* __my_free_list;
            _Obj* __p;
            <span class="hljs-comment">// Try to make do with what we have.  That can't hurt.</span>
            <span class="hljs-comment">// We do not try smaller requests, since that tends</span>
            <span class="hljs-comment">// to result in disaster on multi-process machines.</span>
            <span class="hljs-comment">// 尝试搜寻"大小 &gt;=size 的可用区块"</span>
            <span class="hljs-keyword">for</span> (__i = __size; __i &lt;= (size_t)_MAX_BYTES; __i += (size_t)_ALIGN)
            {
                __my_free_list = _S_free_list + _S_freelist_index(__i);
                __p = *__my_free_list;
                <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != __p)
                {
                    *__my_free_list = __p -&gt; _M_free_list_link;
                    _S_start_free = (<span class="hljs-keyword">char</span>*)__p;
                    _S_end_free = _S_start_free + __i;
                    <span class="hljs-comment">// 现在至少能提供一个区块了, 递归调用自己以修正 nobjs</span>
                    <span class="hljs-keyword">return</span>(_S_chunk_alloc(__size, __nobjs));
                }
            }

            <span class="hljs-comment">// 连 free list 里也没有可用内存了</span>
            _S_end_free = <span class="hljs-number">0</span>;
            <span class="hljs-comment">// 调用一级配置器看能不能有点用</span>
            <span class="hljs-comment">// 一级配置器有 out-of-memory 处理机制, 或许有机会改善现在的情况, 如果无法改善, 抛出bad_alloc异常</span>
            _S_start_free = (<span class="hljs-keyword">char</span>*)malloc_alloc::allocate(__bytes_to_get);
        }
        _S_heap_size += __bytes_to_get;
        _S_end_free = _S_start_free + __bytes_to_get;
        <span class="hljs-keyword">return</span>(_S_chunk_alloc(__size, __nobjs));
    }
}

<span class="hljs-javadoc">/**
返回一个大小为 n 的对象(假定 n 已经适当上调至 8 的倍数), 而且尝试为对应的 free list 增加节点数目
在 allocate() 中, 当 free list 中没有可用区块时, 就会调用 refill() 来给 free list 添加节点
新的空间将取自内存池(经由 chunk_alloc() 完成), 缺省取得20个新节点, 但如果内存池空间不足,
获得的节点数可能小于20, 其中一个节点返回给调用者, 剩下的节点添入对应 free list
*/</span>
template &lt;bool __threads, <span class="hljs-keyword">int</span> __inst&gt;
<span class="hljs-keyword">void</span> *__default_alloc_template&lt;__threads, __inst&gt;::_S_refill(size_t __n)
{
    <span class="hljs-keyword">int</span> __nobjs = <span class="hljs-number">20</span>;
    <span class="hljs-comment">// 注意参数 nobjs 是引用类型</span>
    <span class="hljs-keyword">char</span>* __chunk = _S_chunk_alloc(__n, __nobjs);
    _Obj* <span class="hljs-keyword">volatile</span>* __my_free_list;
    _Obj* __result;
    _Obj* __current_obj;
    _Obj* __next_obj;

    <span class="hljs-comment">// 仅获得一个区块, 分配给调用者用, free list 无新节点</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == __nobjs) <span class="hljs-keyword">return</span>(__chunk);

    <span class="hljs-comment">// 将多余区块纳入 free list</span>
    __my_free_list = _S_free_list + _S_freelist_index(__n);
    __result = (_Obj*)__chunk;
    *__my_free_list = __next_obj = (_Obj*)(__chunk + __n);
    <span class="hljs-comment">// 将各节点串联起来, 第0个区块将返回给调用者</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> __i = <span class="hljs-number">1</span>; __i &lt; __nobjs - <span class="hljs-number">1</span>; __i++)
    {
        __current_obj = __next_obj;
        __next_obj = (_Obj*)((<span class="hljs-keyword">char</span>*)__next_obj + __n);
        __current_obj -&gt; _M_free_list_link = __next_obj;
    }
    __next_obj -&gt; _M_free_list_link = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span>(__result);
}</code></pre></div></body>
</html>