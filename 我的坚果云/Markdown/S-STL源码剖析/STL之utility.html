<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STL之utility</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><p>utility里包含两样东西：通用关系比较操作符（Generic relational operators）和pair。 <br>
通用关系比较操作符有6种，分别是==, !=, &lt;, &gt;, &lt;=, &gt;=。 <br>
pair是可以容纳两个类型的容器。</p>



<h2 id="generic-relational-operators">generic relational operators</h2>

<p>比较操作符定义于stl_relops.h中：</p>

<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>
{
<span class="hljs-keyword">namespace</span> rel_ops
{

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _Tp&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> _Tp&amp; __x, <span class="hljs-keyword">const</span> _Tp&amp; __y)
{
    <span class="hljs-keyword">return</span> !(__x == __y);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _Tp&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-keyword">const</span> _Tp&amp; __x, <span class="hljs-keyword">const</span> _Tp&amp; __y)
{
    <span class="hljs-keyword">return</span> __y &lt; __x;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _Tp&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-keyword">const</span> _Tp&amp; __x, <span class="hljs-keyword">const</span> _Tp&amp; __y)
{
    <span class="hljs-keyword">return</span> !(__y &lt; __x);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _Tp&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-keyword">const</span> _Tp&amp; __x, <span class="hljs-keyword">const</span> _Tp&amp; __y)
{
    <span class="hljs-keyword">return</span> !(__x &lt; __y);
}

} <span class="hljs-comment">// namespace rel_ops</span>
} <span class="hljs-comment">// namespace std</span></code></pre>

<p>我并没有把std拿掉，因为这里面定义了一个rel_ops命名空间，为了整体可读性就没取掉std。 <br>
这四个操作符函数，使得针对某个类已经定义过==和&lt;之后，不必再定义其他四个比较运算符，只要包含utility这个头文件即可。 <br>
看下面这个例子：</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iostream&gt;     <span class="hljs-comment">// std::cout, std::boolalpha</span></span>
<span class="hljs-preprocessor">#include &lt;utility&gt;      <span class="hljs-comment">// std::rel_ops</span></span>
<span class="hljs-preprocessor">#include &lt;cmath&gt;        <span class="hljs-comment">// std::sqrt</span></span>

<span class="hljs-keyword">class</span> vector2d {
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">double</span> x,y;
  vector2d (<span class="hljs-keyword">double</span> px,<span class="hljs-keyword">double</span> py): x(px), y(py) {}
  <span class="hljs-keyword">double</span> length() <span class="hljs-keyword">const</span> {<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">sqrt</span>(x*x+y*y);}
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> vector2d&amp; rhs) <span class="hljs-keyword">const</span> {<span class="hljs-keyword">return</span> length()==rhs.length();}
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-keyword">const</span> vector2d&amp; rhs) <span class="hljs-keyword">const</span> {<span class="hljs-keyword">return</span> length()&lt; rhs.length();}
};

<span class="hljs-keyword">int</span> main () {
  <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>::rel_ops;
  vector2d a (<span class="hljs-number">10</span>,<span class="hljs-number">10</span>);   <span class="hljs-comment">// length=14.14</span>
  vector2d b (<span class="hljs-number">15</span>,<span class="hljs-number">5</span>);    <span class="hljs-comment">// length=15.81</span>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::boolalpha;
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"(a&lt;b) is "</span> &lt;&lt; (a&lt;b) &lt;&lt; <span class="hljs-string">'\n'</span>;
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"(a&gt;b) is "</span> &lt;&lt; (a&gt;b) &lt;&lt; <span class="hljs-string">'\n'</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p>sgi对这个头文件有这样的注释：</p>



<pre class="prettyprint"><code class=" hljs ruby">/**** libstdc++-v3 <span class="hljs-symbol">note:</span>  <span class="hljs-constant">Inclusion</span> of this file has been removed from
 * all of the other <span class="hljs-constant">STL</span> headers <span class="hljs-keyword">for</span> safety reasons, except std_utility.h.
 * <span class="hljs-constant">For</span> more information, see the thread of about twenty messages starting
 * with &lt;<span class="hljs-constant">URL</span><span class="hljs-symbol">:http</span><span class="hljs-symbol">://gcc</span>.gnu.org/ml/libstdc++<span class="hljs-regexp">/2001-01/msg</span>00223.html&gt;, <span class="hljs-keyword">or</span> the
 * <span class="hljs-constant">FAQ</span> at &lt;<span class="hljs-constant">URL</span><span class="hljs-symbol">:http</span><span class="hljs-symbol">://gcc</span>.gnu.org/onlinedocs/libstdc++<span class="hljs-regexp">/faq/index</span>.html<span class="hljs-comment">#4_4&gt;.</span>
 *
 * <span class="hljs-constant">Short</span> <span class="hljs-symbol">summary:</span>  the rel_ops operators cannot be made to play nice.
 * <span class="hljs-constant">Don</span><span class="hljs-string">'t use them.
*/</span></code></pre>



<h2 id="pair">pair</h2>

<p>pair定义于stl_pair.h中。</p>

<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _T1, <span class="hljs-keyword">class</span> _T2&gt;
<span class="hljs-keyword">struct</span> pair
{
    <span class="hljs-keyword">typedef</span> _T1 first_type;
    <span class="hljs-keyword">typedef</span> _T2 second_type;

    _T1 first;
    _T2 second;

    pair() : first(_T1()), second(_T2()) {}
    pair(<span class="hljs-keyword">const</span> _T1&amp; __a, <span class="hljs-keyword">const</span> _T2&amp; __b) : first(__a), second(__b) {}
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _U1, <span class="hljs-keyword">class</span> _U2&gt;
    pair(<span class="hljs-keyword">const</span> pair&lt;_U1, _U2&gt;&amp; __p) : first(__p.first), second(__p.second) {}
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _T1, <span class="hljs-keyword">class</span> _T2&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> pair&lt;_T1, _T2&gt;&amp; __x, <span class="hljs-keyword">const</span> pair&lt;_T1, _T2&gt;&amp; __y)
{
    <span class="hljs-keyword">return</span> __x.first == __y.first &amp;&amp; __x.second == __y.second;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _T1, <span class="hljs-keyword">class</span> _T2&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> pair&lt;_T1, _T2&gt;&amp; __x, <span class="hljs-keyword">const</span> pair&lt;_T1, _T2&gt;&amp; __y)
{
    <span class="hljs-keyword">return</span> __x.first &lt; __y.first ||
           (!(__y.first &lt; __x.first) &amp;&amp; __x.second &lt; __y.second);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _T1, <span class="hljs-keyword">class</span> _T2&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> pair&lt;_T1, _T2&gt;&amp; __x, <span class="hljs-keyword">const</span> pair&lt;_T1, _T2&gt;&amp; __y)
{
    <span class="hljs-keyword">return</span> !(__x == __y);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _T1, <span class="hljs-keyword">class</span> _T2&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-keyword">const</span> pair&lt;_T1, _T2&gt;&amp; __x, <span class="hljs-keyword">const</span> pair&lt;_T1, _T2&gt;&amp; __y)
{
    <span class="hljs-keyword">return</span> __y &lt; __x;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _T1, <span class="hljs-keyword">class</span> _T2&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-keyword">const</span> pair&lt;_T1, _T2&gt;&amp; __x, <span class="hljs-keyword">const</span> pair&lt;_T1, _T2&gt;&amp; __y)
{
    <span class="hljs-keyword">return</span> !(__y &lt; __x);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _T1, <span class="hljs-keyword">class</span> _T2&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-keyword">const</span> pair&lt;_T1, _T2&gt;&amp; __x, <span class="hljs-keyword">const</span> pair&lt;_T1, _T2&gt;&amp; __y)
{
    <span class="hljs-keyword">return</span> !(__x &lt; __y);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _T1, <span class="hljs-keyword">class</span> _T2&gt;
<span class="hljs-keyword">inline</span> pair&lt;_T1, _T2&gt; make_pair(<span class="hljs-keyword">const</span> _T1&amp; __x, <span class="hljs-keyword">const</span> _T2&amp; __y)
{
    <span class="hljs-keyword">return</span> pair&lt;_T1, _T2&gt;(__x, __y);
}</code></pre>

<p>pair只是对两种类型进行了简单的封装，并定义了比较运算符而已。 <br>
另外，添加了一个辅助函数make_pair()来构造一个pair。</p></div></body>
</html>