<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Python的内建常量</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><p>内建的6个常量是（<a href="https://docs.python.org/3/library/constants.html" target="_blank">参考</a>）</p>

<pre><code>'True', 'False', 'None', 'Ellipsis', '__debug__', 'NotImplemented'
</code></pre>

<p>True和False是bool的实例 <br>
None是NoneType的唯一实例 <br>
None, False, True and __debug__不能再被赋值(assignments to them, even as an attribute name, raise SyntaxError)。</p>

<h2 id="debug">__debug__</h2>

<p>This constant is true if Python was not started with an -O option. O表示optimization的意思。 <br>
这个常量和assert语句有关，assert语句等价于（<a href="https://docs.python.org/3/reference/simple_stmts.html#assert" target="_blank">参考</a>）：</p>

<pre><code>if __debug__:
    if not expression: raise AssertionError
</code></pre>

<p>或</p>

<pre><code>if __debug__:
    if not expression1: raise AssertionError(expression2)
</code></pre>



<h2 id="ellipsis">Ellipsis</h2>

<p>Ellipsis是ellipsis的实例（不过我没找到ellipsis定义于哪），代码中的…会自动变成Ellipsis，这有个例子（<a href="http://www.keakon.net/2014/12/05/Python%E8%A3%85%E9%80%BC%E7%AF%87%E4%B9%8BEllipsis" target="_blank">参考</a>）：</p>

<pre class="prettyprint"><code class=" hljs python"><span class="hljs-comment"># 等差数列构造器</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProgressionMaker</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span><span class="hljs-params">(self, key)</span>:</span>
        <span class="hljs-keyword">if</span> isinstance(key, tuple) <span class="hljs-keyword">and</span> len(key) == <span class="hljs-number">4</span> <span class="hljs-keyword">and</span> key[<span class="hljs-number">2</span>] <span class="hljs-keyword">is</span> <span class="hljs-built_in">Ellipsis</span>:
            <span class="hljs-keyword">return</span> range(key[<span class="hljs-number">0</span>], key[-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, key[<span class="hljs-number">1</span>] - key[<span class="hljs-number">0</span>])
maker = ProgressionMaker()
print(list(maker[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, ..., <span class="hljs-number">9</span>]))</code></pre>



<h2 id="notimplemented">NotImplemented</h2>

<p>NotImplemented是个特殊值，它能被二元特殊方法返回（比如__eq__() 、 __lt__()  、 __add__() 、 __rsub__() 等），表明某个类型没有像其他类型那样实现这些操作。同样，它或许会被原地处理（in place）的二元特殊方法返回（比如__imul__()、__iand__()等）。还有，它的bool值为True。 <br>
一个例子可以说明NotImplemented的用法（<a href="http://www.jb51.net/article/63208.htm" target="_blank">参考</a>）：</p>

<pre class="prettyprint"><code class=" hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, value)</span>:</span>
        self.value = value
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__eq__</span><span class="hljs-params">(self, other)</span>:</span>
        <span class="hljs-keyword">if</span> isinstance(other, A):
            print(<span class="hljs-string">'Comparing an A with an A'</span>)
            <span class="hljs-keyword">return</span> other.value == self.value
        <span class="hljs-keyword">if</span> isinstance(other, B):
            print(<span class="hljs-string">'Comparing an A with a B'</span>)
            <span class="hljs-keyword">return</span> other.value == self.value
        print(<span class="hljs-string">'Could not compare A with the other class'</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">NotImplemented</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, value)</span>:</span>
        self.value = value
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__eq__</span><span class="hljs-params">(self, other)</span>:</span>
        <span class="hljs-keyword">if</span> isinstance(other, B):
            print(<span class="hljs-string">'Comparing a B with another B'</span>)
            <span class="hljs-keyword">return</span> other.value == self.value
        print(<span class="hljs-string">'Could not compare B with the other class'</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">NotImplemented</span>
a=A(<span class="hljs-number">2</span>)
b=B(<span class="hljs-number">2</span>)
print(b==a)</code></pre>

<p>输出是： <br>
Could not compare B with the other class <br>
Comparing an A with a B <br>
True</p>

<p>在Python中，a == b会调用a.__eq__(b)。 <br>
B的__eq__()并没有实现B与A的比较，b.__eq__(a)方法返回NotImplemented，这样会导致调用A中的__eq__()方法。而且由于在A中的__eq__()定义了A和B之间的比较，所以就得到了正确的结果（True）。 <br>
如果A中的__eq__()也返回NotImplemented，那么运行时会退化到使用内置的比较行为，即比较对象的标识符（在CPython中，是对象在内存中的地址）。</p></div></body>
</html>