<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>c++的异常</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><h2 id="异常分类">异常分类</h2>

<p>语言本身或标准程序库所抛出的所有异常，都派生自基类exception。所有这些标准异常可分为三组：（1）语言本身支持的异常；（2）逻辑错误；（3）运行时错误。 <br>
用户程序可以从第一类异常派生出自定义异常；标准库和用户程序都可以抛出后两种异常。 <br>
<img src="http://img.blog.csdn.net/20150527091355150" alt="标准异常" title=""> <br>
(图片来自参考2)</p>

<pre><code>基础类别exception和bad_exception定义于&lt;exception&gt;
bad_alloc定义于&lt;new&gt;
bad_cast和bad_typeid定义于&lt;typeinfo&gt;
ios_base::failure定义于&lt;ios&gt;
其他异常类别定义于&lt;stdexcept&gt;
</code></pre>



<h3 id="1-语言本身支持的异常">1. 语言本身支持的异常</h3>

<p>此类异常用以支撑某些语言特性。 <br>
(1) new操作失败，会抛出bad_alloc异常（<code>&lt;new&gt;</code>中定义，new的nothrow版本不抛出异常）。 <br>
(2) 执行期间，当一个作用于reference身上的“动态型别转换操作”失败时，dynamic_cast会抛出bad_cast异常。 <br>
(3) 执行期型别辨识（RTTI）过程中，如果交给typeid的参数为零或空指针，typeid操作符会抛出bad_typeid异常。 <br>
(4) 如果发生非预期的异常（函数抛出异常规格（exception specification）以外的异常），程序会自动调用unexpected()，如果用set_unexpected自定义了unexpected函数，自定义unexpected函数中有<code>throw;</code>或抛出了不在异常规格中的其他异常，c++运行时环境将自动抛出bad_exception。。 <br>
If a function with bad_exception listed in its dynamic-exception-specifier throws an exception not listed in it and unexpected rethrows it (or throws any other exception also not in the dynamic-exception-specifier), a bad_exception is automatically thrown.（来自参考3）</p>

<p>这四异常都有三个函数：一个是构造函数，不带参数；一个是析构函数，是virtual的；第三个是virtual const char* what() throw()。这三个函数都不会再抛出异常。 <br>
(5) 还有一个异常ios_base::failure，它定义在ios_base类内部，当数据流由于错误或者到达文件末尾而发生状态改变时，就可能抛出这个异常。</p>



<h3 id="2-逻辑错误">2. 逻辑错误</h3>

<p>这类异常总是派生自logic_error。 <br>
(1) domain_error指出专业领域范畴内的错误。 <br>
(2) invalid_argument表示无效参数，例如将bitset(array of bits)以char而非0或1进行初始化。 <br>
(3) length_error指出某个行为“可能超越了最大极限”，例如对某个字符串附加太多字符。 <br>
(4) out_of_range指出参数值“不在预期范围内”，例如在处理容器或string中采用一个错误索引。</p>



<h3 id="3-运行时错误">3. 运行时错误</h3>

<p>这类异常派生自runtime_error，用来指出“不在程序范围内，且不容易回避”的事件。 <br>
(1) range_error指出内部计算时发生区间错误。 <br>
(2) overflow_error指出算术运算发生上溢位。 <br>
(3) underflow_error指出算术运算发生下溢位。</p>



<h2 id="源码">源码</h2>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//std_stdexcept.h</span>
<span class="hljs-keyword">class</span> logic_error : <span class="hljs-keyword">public</span> exception
{
    <span class="hljs-built_in">string</span> _M_msg;
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">explicit</span> logic_error(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;  __arg);
    <span class="hljs-keyword">virtual</span> ~logic_error() <span class="hljs-keyword">throw</span>();
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* what() <span class="hljs-keyword">const</span> <span class="hljs-keyword">throw</span>();
};

<span class="hljs-keyword">class</span> domain_error : <span class="hljs-keyword">public</span> logic_error
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">explicit</span> domain_error(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;  __arg);
};

<span class="hljs-keyword">class</span> invalid_argument : <span class="hljs-keyword">public</span> logic_error
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">explicit</span> invalid_argument(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;  __arg);
};

<span class="hljs-keyword">class</span> length_error : <span class="hljs-keyword">public</span> logic_error
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">explicit</span> length_error(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;  __arg);
};

<span class="hljs-keyword">class</span> out_of_range : <span class="hljs-keyword">public</span> logic_error
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">explicit</span> out_of_range(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;  __arg);
};


<span class="hljs-keyword">class</span> runtime_error : <span class="hljs-keyword">public</span> exception
{
    <span class="hljs-built_in">string</span> _M_msg;
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">explicit</span> runtime_error(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;  __arg);
    <span class="hljs-keyword">virtual</span> ~runtime_error() <span class="hljs-keyword">throw</span>();
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* what() <span class="hljs-keyword">const</span> <span class="hljs-keyword">throw</span>();
};

<span class="hljs-keyword">class</span> range_error : <span class="hljs-keyword">public</span> runtime_error
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">explicit</span> range_error(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;  __arg);
};

<span class="hljs-keyword">class</span> overflow_error : <span class="hljs-keyword">public</span> runtime_error
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">explicit</span> overflow_error(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;  __arg);
};

<span class="hljs-keyword">class</span> underflow_error : <span class="hljs-keyword">public</span> runtime_error
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">explicit</span> underflow_error(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;  __arg);
};</code></pre>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//exception（稍有改动）</span>
<span class="hljs-comment">// 标准库可能抛出的所有异常的基类</span>
<span class="hljs-keyword">class</span> exception
{
<span class="hljs-keyword">public</span>:
    exception() <span class="hljs-keyword">throw</span>() { }
    <span class="hljs-keyword">virtual</span> ~exception() <span class="hljs-keyword">throw</span>();
    <span class="hljs-comment">// 返回描述当前错误的字符串, 派生类应覆写此函数</span>
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* what() <span class="hljs-keyword">const</span> <span class="hljs-keyword">throw</span>();
};

<span class="hljs-keyword">class</span> bad_exception : <span class="hljs-keyword">public</span> exception
{
<span class="hljs-keyword">public</span>:
    bad_exception() <span class="hljs-keyword">throw</span>() { }
    <span class="hljs-keyword">virtual</span> ~bad_exception() <span class="hljs-keyword">throw</span>();
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* what() <span class="hljs-keyword">const</span> <span class="hljs-keyword">throw</span>();
};
<span class="hljs-comment">// 参考terminate的说明</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span> (*unexpected_handler)();
unexpected_handler set_unexpected(unexpected_handler) <span class="hljs-keyword">throw</span>();
<span class="hljs-comment">// 默认调用terminate, 但可以通过set_unexpected()更改其行为</span>
<span class="hljs-keyword">void</span> unexpected();

<span class="hljs-comment">/**
* 当一个异常没有catch块捕获时(一层一层throw, throw到main也没有catch处理它),
* 或出现无法处理的情况, 系统将自动调用终结函数,
* 系统提供了一个默认的终结函数terminate(), terminate()会调用abort()退出程序,
* 可以通过set_terminate()来设置新的终结函数, 终结函数必须是terminate_handler类型的,
* terminate()也可以被用户调用.
*/</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span> (*terminate_handler)();
terminate_handler set_terminate(terminate_handler) <span class="hljs-keyword">throw</span>();
<span class="hljs-keyword">void</span> terminate() <span class="hljs-keyword">throw</span>();

<span class="hljs-comment">// 当一个异常已经被抛出, 但在相应的处理程序中异常的初始化还未完成时,</span>
<span class="hljs-comment">// 此函数返回true; 其他情况返回false.</span>
<span class="hljs-comment">// 当此函数返回true时抛出其他异常将导致terminate()被调用.</span>
<span class="hljs-keyword">bool</span> uncaught_exception() <span class="hljs-keyword">throw</span>();</code></pre>



<h2 id="类型匹配">类型匹配</h2>

<p>当catch语句针对异常进行类型匹配的时候，有两种类型转换可能发生： <br>
1. 基于继承的类型转换。一个被声明用于捕获基类异常的catch语句也可以处理异常基类的派生类。 <br>
2. 从一种指针类型转换到无类型指针，一个针对const void <em>或void </em>的catch语句可以捕获任何异常类型的指针。</p>



<h2 id="拷贝">拷贝</h2>

<p>c++以拷贝的方式抛出异常。 <br>
用<code>throw;</code>重新抛出异常的时候抛出的是最开始的那个拷贝。 <br>
这是有意义的，很多时候我们抛出的是一个局部变量，所以需要为其复制一份，并使之有效期持续到该异常完全被处理完毕。</p>

<p>看一个例子：</p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">class</span> A
{
<span class="hljs-keyword">public</span>:
    A(){<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"in A constructor\n"</span>;}
    ~A(){<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"in A destructor\n"</span>;}
};

<span class="hljs-keyword">class</span> B : <span class="hljs-keyword">public</span>  A
{
<span class="hljs-keyword">public</span>:
    B(){<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"in B constructor\n"</span>;}
    ~B(){<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"in B destructor\n"</span>;}
};

B b;

<span class="hljs-keyword">void</span> fun()
{
    <span class="hljs-keyword">try</span>
    {
        <span class="hljs-keyword">throw</span> b;
    }
    <span class="hljs-keyword">catch</span>(A a)<span class="hljs-comment">//发生了截断,用引用就好一些</span>
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"catch A\n"</span>;
        <span class="hljs-keyword">throw</span>;
    }
}
<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">try</span>
    {
        fun();
    }
    <span class="hljs-keyword">catch</span>(...)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"catch all\n"</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p>输出是：</p>

<pre><code>in A constructor
in B constructor
catch A
in A destructor
catch all
in B destructor
in A destructor
in B destructor
in A destructor
</code></pre>

<p><code>throw b;</code>扔出的是b的一个复制品，而不是b本身。 <br>
<code>throw;</code>扔出的是b的那个复制品，而不是a。 <br>
输出的前两行是语句<code>B b;</code>调用B的构造函数，最后四行是b的复制品的析构函数和b的析构函数。</p>

<p>只有在一个catch子句评估完毕并且知道它不会再抛出exception之后，真正的exception object(也就是b的那个复制品)才会被摧毁。 <br>
在整个异常传递过程中，只会产生一个exception object。</p>

<h2 id="异常规格">异常规格</h2>

<p>参考3提供了一个例子：</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">// bad_exception example</span>
<span class="hljs-preprocessor">#include &lt;iostream&gt;       <span class="hljs-comment">// std::cerr</span></span>
<span class="hljs-preprocessor">#include &lt;exception&gt;      <span class="hljs-comment">// std::bad_exception, std::set_unexpected</span></span>

<span class="hljs-keyword">void</span> myunexpected() {
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"unexpected handler called\n"</span>;
  <span class="hljs-keyword">throw</span>;
}

<span class="hljs-keyword">void</span> myfunction() <span class="hljs-keyword">throw</span> (<span class="hljs-keyword">int</span>, <span class="hljs-built_in">std</span>::bad_exception) {
  <span class="hljs-keyword">throw</span> <span class="hljs-string">'x'</span>; <span class="hljs-comment">// throws char (not in exception-specification)</span>
}

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">void</span>) {
  <span class="hljs-built_in">std</span>::set_unexpected(myunexpected);
  <span class="hljs-keyword">try</span> {
    myfunction();
  }
  <span class="hljs-keyword">catch</span>(<span class="hljs-keyword">int</span>) { <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"caught int\n"</span>; }
  <span class="hljs-keyword">catch</span>(<span class="hljs-built_in">std</span>::bad_exception be) { <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"caught bad_exception\n"</span>; }
  <span class="hljs-keyword">catch</span>(...) { <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"caught some other exception\n"</span>; }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p>输出是： <br>
unexpected handler called <br>
caught bad_exception</p>

<h2 id="析构函数与异常">析构函数与异常</h2>

<p>在异常传递过程中执行到堆栈开解（stack-unwinding）部分，异常机制会销毁所有局部变量。如果这些局部变量在销毁的过程中又抛出了异常，会导致到调用terminate函数。（函数uncaught_exception可以识别这种情况。） <br>
看这样的例子：</p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">struct</span> B
{
    ~B() { <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"destruct B\n"</span>; }
};

<span class="hljs-keyword">struct</span> C
{
    B b;
    ~C()
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"destruct C\n"</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"uncaught_exception? "</span> &lt;&lt; boolalpha &lt;&lt; uncaught_exception() &lt;&lt; endl;
        <span class="hljs-keyword">throw</span> <span class="hljs-number">2</span>;
    }
};
<span class="hljs-keyword">void</span> f()
{
    C c;
    <span class="hljs-keyword">throw</span> <span class="hljs-number">1</span>;
}
<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">try</span>{f();}
    <span class="hljs-keyword">catch</span>(<span class="hljs-keyword">int</span> t)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"catch "</span> &lt;&lt; t &lt;&lt; endl;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
<span class="hljs-comment">//程序会异常退出</span></code></pre>

<p>另外如果在某个析构函数里抛出异常，而又没有在其内部捕获它，这个析构函数就不会完全运行。它会在异常抛出的地方停止。 <br>
所以应阻止异常传播到析构函数外面。</p>

<h2 id="构造函数与异常">构造函数与异常</h2>

<p>c++只销毁构造完全的对象，所谓构造完全的对象是指它的构造函数被完全执行的对象。 <br>
所以如果在构造函数里抛出异常，并不会调用对应的析构函数。上面说过，异常机制会销毁所有的局部变量，但考虑这样一种情况：</p>



<pre class="prettyprint"><code class=" hljs cs">class M
{
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> *p1;
    <span class="hljs-keyword">int</span> *p2;
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">M</span>():<span class="hljs-title">p1</span>(0),<span class="hljs-title">p2</span>(0)
    {
        p1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;
        p2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;
    }
    ~M()
    {
        delete p1;
        delete p2;
    }
};</code></pre>

<p>如果new p2的时候抛出了异常，p1的资源就泄漏了。 <br>
一种方法是在构造函数里使用try catch：</p>



<pre class="prettyprint"><code class=" hljs r">    M():p1(<span class="hljs-number">0</span>),p2(<span class="hljs-number">0</span>)
    {
        <span class="hljs-keyword">try</span>
        {
            p1 = new int;
            p2 = new int;
        }
        catch(<span class="hljs-keyword">...</span>)
        {
            delete p1;
            delete p2;
        }
    }</code></pre>

<p>另一种更好的方法是将p1、p2所指的对象当做M所管理的资源来对待，通过别的对象来管理这些资源，比如auto_ptr。这样不仅免去了在析构函数中手动释放资源的必要，发生异常的时候构造函数还可以避免资源泄露。</p>

<p><a href="http://blog.csdn.net/liuyuan185442111/article/details/76937229" target="_blank">探索c++的new和delete</a>还探讨了operator new函数抛出异常的情形。</p>

<h2 id="参考">参考</h2>

<p>More Effective C++ <br>
<a href="http://www.cnblogs.com/zhuyf87/archive/2012/12/29/2839378.html" target="_blank">c++标准异常类别</a> <br>
<a href="http://www.cplusplus.com/reference/exception/bad_exception/" target="_blank">bad_exception</a> <br>
深度探索C++对象模型 第7章 <br>
<a href="http://www.cnblogs.com/zhyg6516/archive/2011/03/08/1977007.html" target="_blank">C++ 异常 与 ”为什么析构函数不能抛出异常“ 问题</a> <br>
<a href="http://www.cplusplus.com/reference/exception/uncaught_exception/" target="_blank">uncaught_exception</a></p></div></body>
</html>