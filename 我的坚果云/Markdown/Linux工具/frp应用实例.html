<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>frp应用实例</title>
<link rel="stylesheet" href="https://csdn.net/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "all"},extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"] } });
</script>
</head>
<body><div class="container"><p>frp 是一个用于内网穿透的反向代理应用，这是一个非常优秀的开源项目，开发者是 <a href="https://blog.fatedier.com/about/">fatedier</a>。</p>

<h2 id="server端配置">server端配置</h2>

<pre class="prettyprint"><code class=" hljs makefile"><span class="hljs-comment"># frps.ini</span>
[common]
<span class="hljs-constant">bind_port</span> = 7000
<span class="hljs-constant">token</span> = passwd

<span class="hljs-comment"># 可选 通过浏览器查看frp的状态以及代理统计信息展示</span>
<span class="hljs-constant">dashboard_port</span> = 7500
<span class="hljs-constant">dashboard_user</span> = admin
<span class="hljs-constant">dashboard_pwd</span> = passwd

<span class="hljs-comment"># 可选 点对点内网穿透使用</span>
<span class="hljs-constant">bind_udp_port</span> = 7001</code></pre>

<pre><code>./frps -c frps.ini
</code></pre>

<h2 id="client端配置">client端配置</h2>

<p>先展示3种基础用法：</p>

<pre class="prettyprint"><code class=" hljs makefile"><span class="hljs-comment"># frpc.ini</span>
[common]
<span class="hljs-constant">server_addr</span> = xx.xx.xx.xx
<span class="hljs-constant">server_port</span> = 7000
<span class="hljs-constant">token</span> = passwd
<span class="hljs-comment"># 可选 启动的代理 默认全部启动</span>
<span class="hljs-constant">start</span> = everything,msts,http_proxy

<span class="hljs-comment"># 每个代理均可按需配置use_encryption和use_compression</span>

<span class="hljs-comment"># Everything提供的HTTP Server</span>
[everything]
<span class="hljs-constant">type</span> = tcp
<span class="hljs-comment"># local_ip也可配置成其他提供服务的服务器的ip地址, 如果是本机提供</span>
<span class="hljs-comment"># 该服务, 则设置127.0.0.1, 以下服务均由本机提供, 故省略该配置项</span>
<span class="hljs-constant">local_ip</span> = 127.0.0.1
<span class="hljs-constant">local_port</span> = 80
<span class="hljs-constant">remote_port</span> = 7080

<span class="hljs-comment"># 远程桌面连接</span>
[msts]
<span class="hljs-constant">type</span> = tcp
<span class="hljs-constant">local_port</span> = 3389
<span class="hljs-constant">remote_port</span> = 7389
<span class="hljs-constant">use_compression</span> = true

<span class="hljs-comment"># HTTP代理</span>
[http_proxy]
<span class="hljs-constant">type</span> = tcp
<span class="hljs-constant">remote_port</span> = 7100
<span class="hljs-constant">plugin</span> = http_proxy
<span class="hljs-constant">plugin_http_user</span> = abc
<span class="hljs-constant">plugin_http_passwd</span> = abc
<span class="hljs-constant">use_encryption</span> = true
<span class="hljs-constant">use_compression</span> = true</code></pre>

<pre><code>frpc.exe -c frpc.ini
</code></pre>

<p>以上3种用法，本质上是将处于内网的C的端口 local_ip:p1 映射到处于公网的S的端口 p2，访问 S:p2，即是访问 C:local_ip:p1，这些流量都要通过S中转，但对于访问者都是透明的。</p>

<p>接下来是两种高端玩法</p>

<h2 id="安全地暴露内网服务">安全地暴露内网服务</h2>

<p>作者称该玩法为 stcp（secret tcp），访问者也需要运行另外一个 frpc，模式可用下图描述：</p>

<pre><code>frpc::local_ip:port1 ----- frps ----- visitor::port2
访问本地的port2端口，相当于访问远端的frpc上的local_ip:port1端口
</code></pre>

<p>上节中的 frpc.ini 需要添加如下配置：</p>

<pre class="prettyprint"><code class=" hljs makefile"><span class="hljs-comment"># frpc.ini</span>
[secret_tcp]
<span class="hljs-constant">type</span> = stcp
<span class="hljs-constant">sk</span> = abcdefg
<span class="hljs-constant">local_port</span> = 80</code></pre>

<p>visitor 的 frpc 需要做如下配置：</p>

<pre class="prettyprint"><code class=" hljs makefile"><span class="hljs-comment"># frpc2.ini</span>
[common]
<span class="hljs-constant">server_addr</span> = xx.xx.xx.xx
<span class="hljs-constant">server_port</span> = 7000
<span class="hljs-constant">token</span> = passwd

[secret_service]
<span class="hljs-constant">role</span> = visitor
<span class="hljs-constant">type</span> = stcp
<span class="hljs-comment"># server_name和sk要和上面frpc.ini中一致</span>
<span class="hljs-constant">server_name</span> = secret_tcp
<span class="hljs-constant">sk</span> = abcdefg
<span class="hljs-constant">bind_port</span> = 8000</code></pre>

<h2 id="点对点内网穿透">点对点内网穿透</h2>

<blockquote>
  <p>frp 提供了一种新的代理类型 xtcp 用于应对在希望传输大量数据且流量不经过服务器的场景。 <br>
  使用方式同 stcp 类似，需要在两边都部署上 frpc 用于建立直接的连接。 <br>
  目前处于开发的初级阶段，并不能穿透所有类型的 NAT 设备，所以穿透成功率较低。穿透失败时可以尝试 stcp 的方式。</p>
</blockquote>

<p>frps 除正常配置外需要额外配置一个 udp 端口用于支持该类型的客户端，在上面 frps.ini 中已添加。frpc.ini 需要额外添加：</p>

<pre class="prettyprint"><code class=" hljs ini"><span class="hljs-title">[p2p_service]</span>
<span class="hljs-setting">type = <span class="hljs-value">xtcp</span></span>
<span class="hljs-setting">sk = <span class="hljs-value">abcdefg</span></span>
<span class="hljs-setting">local_port = <span class="hljs-value"><span class="hljs-number">80</span></span></span></code></pre>

<p>在要访问这个服务的机器上启动另外一个 frpc，配置如下:</p>



<pre class="prettyprint"><code class=" hljs makefile"><span class="hljs-comment"># frpc.ini</span>
[common]
<span class="hljs-constant">server_addr</span> = xx.xx.xx.xx
<span class="hljs-constant">server_port</span> = 7000
<span class="hljs-constant">token</span> = passwd

[p2p_visitor]
<span class="hljs-constant">type</span> = xtcp
<span class="hljs-constant">role</span> = visitor
<span class="hljs-comment"># server_name和sk要和上面frpc.ini中一致</span>
<span class="hljs-constant">server_name</span> = p2p_service
<span class="hljs-constant">sk</span> = abcdefg
<span class="hljs-constant">bind_port</span> = 9000</code></pre>

<h2 id="参考">参考</h2>

<p>frp还提供很多其他功能，如有需求，可查看： <br>
<a href="https://github.com/fatedier/frp">frp项目地址</a> <br>
<a href="https://github.com/fatedier/frp/blob/master/README_zh.md">frp中文文档</a> <br>
frps_full.ini <br>
frpc_full.ini</p></div></body>
</html>