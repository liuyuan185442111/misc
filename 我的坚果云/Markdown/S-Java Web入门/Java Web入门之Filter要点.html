<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Java Web入门之Filter要点</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><h2 id="基础知识">基础知识</h2>

<p>Web服务器接收到来自客户端的web请求，在交给Servlet处理之前，会先经过过滤器的过滤。Servlet处理完请求将结果返回给客户端的时候，也需要先经过过滤器的过滤。多个过滤器可以组成过滤器链，按照在web.xml的注册顺序依次调用，对返回结果的过滤顺序正好与此相反。</p>

<p>过滤器必须实现javax.servlet.Filter接口，这一接口声明了init、doFilter、destroy三个方法。</p>

<pre><code>public void init(FilterConfig);
</code></pre>

<p>在容器实例化过滤器时被调用，对过滤器进行初始化，调用时会传递一个包含过滤器的配置和运行环境的FilterConfig对象。利用FilterConfig对象可以得到ServletContext对象，以及在web.xml文件中指定的过滤器初始化参数。</p>

<pre><code>public void doFilter(ServletRequest, ServletResponse, FilterChain);
</code></pre>

<p>过滤器的自定义行为主要在这里完成，过滤器执行doFilter方法时，会自动获得过滤器链对象，使用该对象的doFilter方法可继续调用下一级过滤器。</p>

<pre><code>public void destory();
</code></pre>

<p>在停止使用过滤器前，由容器调用过滤器的这个方法，完成必要的清除和释放资源的工作。</p>

<p>Filter可能的实现过程是（以过滤web请求为例）：从web.xml中找到第一个   <code>&lt;filter&gt;</code>，得到过滤器类路径、过滤器参数、下一个过滤器，将参数封装到FilterConfig对象中传递给过滤器对象的init方法，将ServletRequest，ServletResponse，FilterChain（下一个过滤器对象）作为参数传递给滤器对象的doFilter方法。用户在doFilter方法中调用FilterChain.doFilter方法，这样会调用下一个过滤器，过程类似，如果没有调用FilterChain.doFilter方法，web请求就不会提交给Servlet，也就是说web请求在此消失。</p>

<p>如果在Servlet里先调用<code>out.flush();out.close();</code>，再执行<code>Thread.sleep(3000);</code>，过滤器这样写：</p>

<pre><code>System.out.println("before");
filterChain.doFilter(request, response);
System.out.println("after");
</code></pre>

<p>结果是客户端先得到网页，终端里等待3s后再打印出after。应该是执行完<code>out.close();</code>之后，web服务器结束输出，将结果返回给客户端。如果没有out.close();语句，则在3s后终端打印完after，客户端才得到网页内容，可能是调用完过滤器后web服务器自动调用了out.close();。</p>



<h2 id="一个简单的例子">一个简单的例子</h2>

<p>只有指定的IP地址才能访问/abc/*。</p>

<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">package</span> advance;
<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> javax.servlet.Filter;
<span class="hljs-keyword">import</span> javax.servlet.FilterChain;
<span class="hljs-keyword">import</span> javax.servlet.FilterConfig;
<span class="hljs-keyword">import</span> javax.servlet.ServletException;
<span class="hljs-keyword">import</span> javax.servlet.ServletRequest;
<span class="hljs-keyword">import</span> javax.servlet.ServletResponse;
<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;
<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilterIP</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span>
{</span>
    <span class="hljs-keyword">private</span> FilterConfig fiterconfig;
    <span class="hljs-keyword">private</span> String ip;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span>(FilterConfig config) <span class="hljs-keyword">throws</span> ServletException
    {
        <span class="hljs-keyword">this</span>.fiterconfig = config;
        ip = fiterconfig.getInitParameter(<span class="hljs-string">"allowedIP"</span>);
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span>(){}
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span>(ServletRequest req, ServletResponse res, FilterChain chain) <span class="hljs-keyword">throws</span> IOException, ServletException
    {
        HttpServletRequest request = (HttpServletRequest)req;
        HttpServletResponse response = (HttpServletResponse)res;
        String reqIP = request.getRemoteHost();
        <span class="hljs-keyword">if</span> (reqIP.equals(ip))
        {
            chain.doFilter(req, res);
        }
        <span class="hljs-keyword">else</span>
        {
            response.sendRedirect(<span class="hljs-string">"error.jsp"</span>);
        }
    }
}</code></pre>

<p>web.xml配置</p>

<pre class="prettyprint"><code class="language-xml hljs ">    <span class="hljs-tag">&lt;<span class="hljs-title">filter</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">filter-name</span>&gt;</span>fIP<span class="hljs-tag">&lt;/<span class="hljs-title">filter-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">filter-class</span>&gt;</span>advance.FilterIP<span class="hljs-tag">&lt;/<span class="hljs-title">filter-class</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">init-param</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">param-name</span>&gt;</span>allowedIP<span class="hljs-tag">&lt;/<span class="hljs-title">param-name</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">param-value</span>&gt;</span>10.108.36.227<span class="hljs-tag">&lt;/<span class="hljs-title">param-value</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">init-param</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">filter</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">filter-mapping</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">filter-name</span>&gt;</span>fIP<span class="hljs-tag">&lt;/<span class="hljs-title">filter-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">url-pattern</span>&gt;</span>/abc/*<span class="hljs-tag">&lt;/<span class="hljs-title">url-pattern</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">filter-mapping</span>&gt;</span></code></pre>



<h2 id="两个filter组成filterchain">两个Filter组成FilterChain</h2>

<p>filter1</p>

<pre class="prettyprint"><code class="language-java hljs ">    System.out.println(<span class="hljs-string">"before1"</span>);
    filterChain.doFilter(request, response);
    System.out.println(<span class="hljs-string">"after1"</span>);</code></pre>

<p>fiter2</p>



<pre class="prettyprint"><code class="language-java hljs ">    System.out.println(<span class="hljs-string">"before2"</span>);
    filterChain.doFilter(request, response);
    System.out.println(<span class="hljs-string">"after2"</span>);</code></pre>

<p>web.xml配置</p>



<pre class="prettyprint"><code class="language-xml hljs ">     <span class="hljs-tag">&lt;<span class="hljs-title">filter</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">filter-name</span>&gt;</span>f1<span class="hljs-tag">&lt;/<span class="hljs-title">filter-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">filter-class</span>&gt;</span>advance.Filter1<span class="hljs-tag">&lt;/<span class="hljs-title">filter-class</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">filter</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">filter-mapping</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">filter-name</span>&gt;</span>f1<span class="hljs-tag">&lt;/<span class="hljs-title">filter-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-title">url-pattern</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">filter-mapping</span>&gt;</span>

      <span class="hljs-tag">&lt;<span class="hljs-title">filter</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">filter-name</span>&gt;</span>f2<span class="hljs-tag">&lt;/<span class="hljs-title">filter-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">filter-class</span>&gt;</span>advance.Filter2<span class="hljs-tag">&lt;/<span class="hljs-title">filter-class</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">filter</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">filter-mapping</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">filter-name</span>&gt;</span>f2<span class="hljs-tag">&lt;/<span class="hljs-title">filter-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-title">url-pattern</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">filter-mapping</span>&gt;</span></code></pre>

<p>结果： <br>
before1 <br>
before2 <br>
after2 <br>
after1 <br>
<img src="http://img.blog.csdn.net/20150418173811568" alt="result" title=""></p>



<h2 id="sendredirect和forward的区别">sendRedirect和forward的区别</h2>

<p>HttpServletResponse.sendRedirect()是通过向客户浏览器发送命令来完成跳转操作，是重新定向，前后页面不是一个request，在所有的语句都执行完之后才完成跳转操作。 <br>
HttpServletRequest.getRequestDispatcher()返回的是一个RequestDispather对象。RequestDispatcher.forward()是在服务器端运行，是请求转发，前后页面共享一个request，所以RequestDispatcher.forward()对于浏览器来说是“透明的”，浏览器的地址栏都不会变，此语句后面的语句将不再执行。 <br>
<code>&lt;jsp:forward&gt;</code>是服务器跳转，跳转语句后面的语句将不再执行。实际是调用了pageContext.forward()函数。</p>

<p>ServletContext.getRequestDispatcher(String url)中的url只能使用绝对路径； <br>
ServletRequest.getRequestDispatcher(String url)中的url可以使用相对路径。 <br>
因为ServletRequest具有相对路径的概念；而ServletContext无此概念。</p>

<p>在开发中如果项目中有一些敏感web资源不想被外界直接访问，那么可以考虑将这些敏感的web资源放到WEB-INF目录下，这样就可以禁止外界直接通过URL来访问了，但可以通过request.getRequestDispatcher(“/WEB-INF/some.jsp”).forward(request, response)来访问。</p>



<h2 id="其他">其他</h2>

<h3 id="filterchain的获得">FilterChain的获得</h3>

<p>在web.xml中从头到尾依次查找<code>&lt;filter-mapping&gt;</code>标签里的<code>&lt;url-pattern&gt;</code>，如果请求页面的url符合则得到<code>&lt;filter-name&gt;</code>，再根据<code>&lt;filter-name&gt;</code>查找其<code>&lt;filter-class&gt;</code>。所以FilterChain的顺序只与<code>&lt;filter-mapping&gt;</code>标签的顺序有关。 <br>
获得FilterChain中下一个过滤器应该是动态查找确定的，因为可能在某个Filter中进行了forward动作，查找下一个Filter的时候只能找下面可以过滤forward的过滤器。</p>

<h3 id="跳过后续过滤器">跳过后续过滤器</h3>

<p>假如应用中存在多个过滤器，如何在某个过滤器处理后跳过后续过滤器处理？这里提供了两种方式来解决这个问题。 <br>
方式一： <br>
在后续过滤器中根据前面过滤器处理后设置的标识手动跳过。标识可以放在request Attributes里，比如<code>request.setAttribute("jumpFilter", "true")</code>。 <br>
方式二： <br>
过滤器处理时，不进行后续过滤器链处理（FilterChain#doFilter()），而是直接转发请求给Servlet或URL（RequestDispatcher#forward()），比如request.getRequestDispatcher(httpServletRequest.getServletPath() + httpServletRequest.getPathInfo()).forward(request, response)。 <br>
这样会跳过后续的所有过滤器处理，如果有某个过滤器仍然需要进行处理，那可以在web.xml中配置该过滤器<code>&lt;filter-mapping&gt;：&lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;</code>表示仍会处理forward的请求。</p>

<p>2.4版本的servlet规范在部属描述符中新增加了一个<code>&lt;dispatcher&gt;</code>元素，这个元素有四个可能的值，即REQUEST,FORWARD,INCLUDE和ERROR，可以在一个<code>&lt;filter-mapping&gt;</code>元素中加入任意数目的<code>&lt;dispatcher&gt;</code>，使得filter将会作用于直接从客户端过来的request，通过forward过来的request，通过include过来的request和通过<code>&lt;error-page&gt;</code>过来的request。如果没有指定任何<code>&lt;dispatcher&gt;</code>元素，默认值是REQUEST。</p>

<h3 id="过滤器可以针对某个servlet过滤">过滤器可以针对某个servlet过滤</h3>

<p>需要更改的是把web.xml里相应的<code>&lt;url-pattern&gt;</code>改成<code>&lt;servlet-name&gt;</code>。</p>

<pre class="prettyprint"><code class="language-xml hljs "><span class="hljs-tag">&lt;<span class="hljs-title">filter-mapping</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">filter-name</span>&gt;</span>MyFilter<span class="hljs-tag">&lt;/<span class="hljs-title">filter-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">servlet-name</span>&gt;</span>MyServlet<span class="hljs-tag">&lt;/<span class="hljs-title">servlet-name</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">filter-mapping</span>&gt;</span></code></pre>



<h3 id="spring-security">Spring Security</h3>

<p>Spring Security的web架构是完全基于标准的servlet过滤器的。它没有在内部使用servlet或任何其他基于servlet的框架（比如spring mvc），所以它没有与任何特定的web技术强行关联。它只管处理HttpServletRequest和HttpServletResponse，不关心请求是来自浏览器，web服务客户端，HttpInvoker，还是一个AJAX应用。</p>

<h2 id="参考">参考</h2>

<p>关于Filter中ServletRequest和ServletResponse强转HttpServletRequest和HttpServletResponse安全问题 <br>
<a href="http://blog.csdn.net/huan_mie/article/details/6114427">http://blog.csdn.net/huan_mie/article/details/6114427</a> <br>
getRequestDispatcher()与sendRedirect()的区别 <br>
<a href="http://www.cnblogs.com/phpzxh/archive/2010/02/01/1661137.html">http://www.cnblogs.com/phpzxh/archive/2010/02/01/1661137.html</a> <br>
理解Servlet过滤器(javax.servlet.Filter) <br>
<a href="http://blog.csdn.net/microtong/article/details/5007170">http://blog.csdn.net/microtong/article/details/5007170</a> <br>
如何跳过过滤器处理？ <br>
<a href="http://88250.b3log.org/how-to-skip-filters-in-java">http://88250.b3log.org/how-to-skip-filters-in-java</a> <br>
web.xml里<code>&lt;filter-mapping&gt;</code>中的<code>&lt;dispatcher&gt;</code>作用 <br>
<a href="http://hintcnuie.iteye.com/blog/226251/">http://hintcnuie.iteye.com/blog/226251/</a> <br>
安全过滤器链 <br>
<a href="http://www.mossle.com/docs/springsecurity3/html/web-infrastructure.html">http://www.mossle.com/docs/springsecurity3/html/web-infrastructure.html</a></p></div></body>
</html>