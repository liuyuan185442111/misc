线程同步
互斥量 pthread_mutex_t
读写锁 pthread_rwlock_t
条件变量 pthread_cond_t
条件变量让线程等待特定条件的发生，条件本身是由互斥量保护的。
有两个函数可以用于通知线程条件已经满足，pthread_cond_signal将唤醒等待该条件的某个线程，pthread_cond_broadcast将唤醒等待该条件的所有线程（pthread_cond_signal在实现的时候可以唤醒不止一个线程）。
使用pthread_cond_wait和pthread_cond_timewait等待条件的发生。man says "These functions atomically release mutex and cause the calling thread to block on the condition variable cond."。这两个函数会原子地释放互斥量和将调用线程阻塞到条件变量上。调用线程被唤醒后成功获得互斥量之后函数再返回。
看APUE给出的实例：
```
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
struct msg {
struct msg *m_next;
/* ... more stuff here ... */
};
struct msg *workq;
pthread_cond_t qready = PTHREAD_COND_INITIALIZER;
pthread_mutex_t qlock = PTHREAD_MUTEX_INITIALIZER;
void *process_msg(void *p)
{
    struct msg *mp;
        for(;;) {
                pthread_mutex_lock(&qlock);
                while(workq == NULL)
                        pthread_cond_wait(&qready, &qlock);
                mp = workq;
                workq = mp->m_next;
                pthread_mutex_unlock(&qlock);
                /* now process the message mp */
                free(mp);
        }
}
void *enqueue_msg(void *p)
{
        for(;;) {
                struct msg *mp = (struct msg *)malloc(sizeof(struct msg));
                pthread_mutex_lock(&qlock);
                mp->m_next = workq;
                workq = mp;
                pthread_cond_broadcast(&qready);
                pthread_mutex_unlock(&qlock);
                sleep(1);
        }
}
int main()
{
        pthread_t t1,t2;
        int i = 0;
        pthread_create(&t1,NULL,enqueue_msg,NULL);
        for(; i<10; ++i)
        {
                pthread_t t2;
                pthread_create(&t2,NULL,process_msg,NULL);
                pthread_detach(t2);
        }
        pthread_join(t1,NULL);
        return 0;
}
```
现在结合实例看一下wait操作：调用wait之前肯定要先判断条件是否满足，判断条件之前得先获得互斥锁，所以wait必须得释放互斥锁；如果wait的两个操作不是原子的，考虑在释放互斥锁之后马上切换到了生产者线程，生产者获得互斥锁产生新的条件并pthread_cond_signal了，那这个signal就会丢失掉，所以两个操作必须是原子的。
process_msg的流程看起来就像是同步的一样，通过条件变量异步操作转换为了同步操作（Lua的协程是不是就是这样实现的？）。唯一不像的地方是那个while循环，这个没办法，考虑pthread_cond_broadcast唤醒多个等待线程的情况，其他线程可能已经改变了条件，所以必须重新判断。
最后看一下enqueue_msg中pthread_cond_broadcast和释放互斥锁的先后顺序。总的来说，两种都可能是正确的。如果pthread_cond_broadcast在先，broadcast以后，等待线程会被调度运行，它们都会被阻塞在互斥锁上，等待生产者线程释放互斥锁后，一个等待线程会获得互斥锁满足条件然后使条件失效再释放互斥锁，然后其他等待线程获得互斥锁不满足条件继续调用wait等待。如果释放互斥锁在先，消费者可以在生产者调用broadcast之前被调度，获取互斥锁，然后使条件失效，最后释放互斥锁；接着，当调用broadcast时，条件不再为真，等待线程从wait返回之后再次进入wait等待，这种情况也使得从wait返回之后必须重新检查条件。

参考
APUE 11.6节和习题11.4
[深入解析条件变量(condition variables)](https://www.cnblogs.com/harlanc/p/8596211.html)