<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>JavaScript原型链的那点事</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><p>函数也是一种对象，以下三种定义函数的方式本质是一样的：</p>

<pre><code>function f1(m){console.log(m)}
var f2 = function(m){console.log(m)}
var f3 = new Function('m','console.log(m)')
</code></pre>

<p>前两种可以算是第三种的语法糖。</p>

<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span><span class="hljs-params">(m)</span>{</span><span class="hljs-keyword">this</span>.value=m;}
<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-number">8</span>);</code></pre>

<p>作用上等价于</p>

<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-keyword">var</span> Person = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(m)</span>{</span><span class="hljs-keyword">this</span>.value=m;}
<span class="hljs-keyword">var</span> p = {}
p.__proto__ = Person.prototype;
Person.call(p, <span class="hljs-number">8</span>);</code></pre>

<p>call改变函数体内this的值，所以p.value为8。 <br>
<code>p.__proto__ = Person.prototype;</code>是为了实现继承，访问p的属性xxx时，如果p没有该属性，则会去它的<code>__proto__</code>指向的对象中去寻找，如果还没有就继续向上层去找。<code>__proto__</code>实际上是一个隐藏属性，浏览器可能并不会提供。</p>

<p>下面是JavaScript原型链的关系图： <br>
<img src="http://img.blog.csdn.net/20161226165409738?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1eXVhbjE4NTQ0MjExMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="关系图" title=""> <br>
其中： <br>
var Animal = function()… <br>
var anim = new Animal()… <br>
<img src="http://img.blog.csdn.net/20161226165448099?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1eXVhbjE4NTQ0MjExMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="描述" title=""></p>

<p>因为Animal、Function、Object都是函数，所以它们的<code>__proto__</code>都指向Function.prototype。 <br>
Function和Object是特殊的函数，Function是为了可以定义普通函数，Object是为了定义其他对象。</p>

<p>typeof Function.prototype虽然是function，但是别的函数都有对应的prototype，它却没有，这有点不统一了，所以我认为应该不把Function.prototype看做是function。</p>

<p>Animal是通过new Function得到的，所以<code>Animal.__proto__</code>指向Function.prototype。在定义Animal的时候，也定义了Animal.prototype。</p>

<p>在JavaScript中，每个函数对象都有名为“prototype”的属性（除了Function.prototype），用于引用原型对象。此原型对象又有名为“constructor”的属性，它反过来引用函数本身。 <br>
其他对象的prototype的<code>__proto__</code>都指向Object.prototype，Object.prototype的<code>__ptoto__</code>指向null。</p>

<p>稍稍修改后的关系图： <br>
<img src="http://img.blog.csdn.net/20161226165437027?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1eXVhbjE4NTQ0MjExMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="关系图" title=""> <br>
函数原型对象的constructor属性又指向函数本身，所以可以通过anim.constructor.prototype得到Animal的原型对象，从而为其添加一些属性。</p>



<h2 id="参考">参考</h2>

<p><a href="http://www.blogjava.net/heavensay/archive/2013/10/20/405440.html" target="_blank">http://www.blogjava.net/heavensay/archive/2013/10/20/405440.html</a> <br>
<a href="http://rockyuse.iteye.com/blog/1426510" target="_blank">http://rockyuse.iteye.com/blog/1426510</a></p>



<h2 id="by-the-way">by the way</h2>

<p>有一个无符号右移运算符 &gt;&gt;&gt; <br>
对于负数，&gt;&gt;&gt;先将其转换为无符号数，然后进行右移。 <br>
所以，-64&gt;&gt;&gt;0就把-64转换为了无符号数。</p>

<p>全等号由三个等号表示（===），只有在无需类型转换运算数就相等的情况下，才返回 true。</p>

<hr>

<p>For-in语句是严格的迭代语句，用于枚举对象的属性。 <br>
它的语法如下： <br>
for (property in expression) statement <br>
例子： <br>
for (sProp in window) { <br>
  document.writeln (sProp); <br>
} <br>
用于显示 window 对象的所有属性。</p>

<hr>

<p>把对象的所有引用都设置为null，可以强制性地废除对象。例如： <br>
var oObject = new Object; <br>
// do something with the object here <br>
oObject = null; <br>
当变量oObject设置为null后，对第一个创建的对象的引用就不存在了。这意味着下次运行无用存储单元收集程序时，该对象将被销毁。</p></div></body>
</html>