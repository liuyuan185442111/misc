<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STL之处理uninitialized memory</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><p>memory里除了空间配置器，auto_ptr，还有一些作用于uninitialized memory的工具。</p>



<h2 id="构造和析构工具">构造和析构工具</h2>

<p>定义于stl_construct.h文件。</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _T1, <span class="hljs-keyword">class</span> _T2&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> _Construct(_T1* __p, <span class="hljs-keyword">const</span> _T2&amp; __value)
{
    <span class="hljs-keyword">new</span> ((<span class="hljs-keyword">void</span>*) __p) _T1(__value);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _T1&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> _Construct(_T1* __p)
{
    <span class="hljs-keyword">new</span> ((<span class="hljs-keyword">void</span>*) __p) _T1();
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _Tp&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> _Destroy(_Tp* __pointer)
{
    __pointer-&gt;~_Tp();
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _ForwardIterator&gt;
<span class="hljs-keyword">void</span> __destroy_aux(_ForwardIterator __first, _ForwardIterator __last, __false_type)
{
    <span class="hljs-keyword">for</span> ( ; __first != __last; ++__first)
        _Destroy(&amp;*__first);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _ForwardIterator&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type) {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _ForwardIterator, <span class="hljs-keyword">class</span> _Tp&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> __destroy(_ForwardIterator __first, _ForwardIterator __last, _Tp*)
{
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> __type_traits&lt;_Tp&gt;::has_trivial_destructor
    _Trivial_destructor;
    __destroy_aux(__first, __last, _Trivial_destructor());
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _ForwardIterator&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> _Destroy(_ForwardIterator __first, _ForwardIterator __last)
{
    __destroy(__first, __last, __value_type(__first));
}

<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> _Destroy(<span class="hljs-keyword">char</span>*, <span class="hljs-keyword">char</span>*) {}
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> _Destroy(<span class="hljs-keyword">int</span>*, <span class="hljs-keyword">int</span>*) {}
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> _Destroy(<span class="hljs-keyword">long</span>*, <span class="hljs-keyword">long</span>*) {}
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> _Destroy(<span class="hljs-keyword">float</span>*, <span class="hljs-keyword">float</span>*) {}
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> _Destroy(<span class="hljs-keyword">double</span>*, <span class="hljs-keyword">double</span>*) {}
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> _Destroy(<span class="hljs-keyword">wchar_t</span>*, <span class="hljs-keyword">wchar_t</span>*) {}</code></pre>

<p>上述construct接受一个指针和一个初值，该函数的用途就是将初值设定到指针所指的空间上。c++的placement new运算符可用来完成这一任务。 <br>
destroy有两个版本，第一版本接受一个指针，准备将该指针所指之物析构掉，直接调用该对象的析构函数即可。第二版本接受first和last两个迭代器，准备将 [first, last) 范围内的所有对象析构掉。 <br>
在第二个版本destroy()中，首先利用__value_type()（ 参考<a href="http://blog.csdn.net/liuyuan185442111/article/details/45848299#t0">STL之迭代器</a>）获得迭代器所指对象的型别，再利用__type_traits（参考<a href="http://blog.csdn.net/liuyuan185442111/article/details/45848827">STL之__normal_iterator和__type_traits</a>）判断该型别的析构函数是否无关痛痒。若是(__true_type) ，则什么也不做就结束；若否（__false_type），这才以循环方式巡访整个范围，并在循环中每经历一个对象就调用第一个版本的destroy()。</p>

<h2 id="内存处理工具">内存处理工具</h2>

<p>stl_uninitialized.h这里定义了一些全局函数，用来填充（fill）或复制（copy）大块内存数据，它们隶属于STL标准规范。 <br>
uninitialized_copy(); <br>
uninitialized_fill(); <br>
uninitialized_fill_n(); <br>
这些函数不属于空间配置器范畴，但与对象初值设置有关，对于容器的大规模元素初值设置很有帮助。这些函数对于效率都面面俱到的考虑，最差情况下回调用construct()，最佳情况则会使用c标准函数memmove()直接进行内存数据的移动。 <br>
这三个函数使我们能够将内存的配置与对象的构造行为分离开来。 <br>
这三个函数分别对应于高层次的copy()，fill()，fill_n()。 <br>
这三个函数必须具备 “commit or rollback” 语意，要么构造出所有必要元素，要么不构造任何东西。但我为了简便，下面的代码中把异常处理给去掉了。</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _InputIter, <span class="hljs-keyword">class</span> _ForwardIter&gt;
<span class="hljs-keyword">inline</span> _ForwardIter
__uninitialized_copy_aux(_InputIter __first, _InputIter __last,
                         _ForwardIter __result, __true_type)
{
    <span class="hljs-keyword">return</span> copy(__first, __last, __result);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _InputIter, <span class="hljs-keyword">class</span> _ForwardIter&gt;
_ForwardIter __uninitialized_copy_aux(_InputIter __first, _InputIter __last,
                                      _ForwardIter __result, __false_type)
{
    _ForwardIter __cur = __result;
    <span class="hljs-keyword">for</span> ( ; __first != __last; ++__first, ++__cur)
        _Construct(&amp;*__cur, *__first);
    <span class="hljs-keyword">return</span> __cur;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _InputIter, <span class="hljs-keyword">class</span> _ForwardIter, <span class="hljs-keyword">class</span> _Tp&gt;
<span class="hljs-keyword">inline</span> _ForwardIter
__uninitialized_copy(_InputIter __first, _InputIter __last,
                     _ForwardIter __result, _Tp*)
{
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> __type_traits&lt;_Tp&gt;::is_POD_type _Is_POD;
    <span class="hljs-keyword">return</span> __uninitialized_copy_aux(__first, __last, __result, _Is_POD());
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _InputIter, <span class="hljs-keyword">class</span> _ForwardIter&gt;
<span class="hljs-keyword">inline</span> _ForwardIter
uninitialized_copy(_InputIter __first, _InputIter __last,
                   _ForwardIter __result)
{
    <span class="hljs-keyword">return</span> __uninitialized_copy(__first, __last, __result, __value_type(__result));
}

<span class="hljs-keyword">inline</span> <span class="hljs-keyword">char</span>*
uninitialized_copy(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* __first, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* __last,
                   <span class="hljs-keyword">char</span>* __result)
{
    memmove(__result, __first, __last - __first);
    <span class="hljs-keyword">return</span> __result + (__last - __first);
}

<span class="hljs-keyword">inline</span> <span class="hljs-keyword">wchar_t</span>*
uninitialized_copy(<span class="hljs-keyword">const</span> <span class="hljs-keyword">wchar_t</span>* __first, <span class="hljs-keyword">const</span> <span class="hljs-keyword">wchar_t</span>* __last,
                   <span class="hljs-keyword">wchar_t</span>* __result)
{
    memmove(__result, __first, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">wchar_t</span>) * (__last - __first));
    <span class="hljs-keyword">return</span> __result + (__last - __first);
}


<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _ForwardIter, <span class="hljs-keyword">class</span> _Tp&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>
__uninitialized_fill_aux(_ForwardIter __first, _ForwardIter __last,
                         <span class="hljs-keyword">const</span> _Tp&amp; __x, __true_type)
{
    fill(__first, __last, __x);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _ForwardIter, <span class="hljs-keyword">class</span> _Tp&gt;
<span class="hljs-keyword">void</span>
__uninitialized_fill_aux(_ForwardIter __first, _ForwardIter __last,
                         <span class="hljs-keyword">const</span> _Tp&amp; __x, __false_type)
{
    _ForwardIter __cur = __first;
    <span class="hljs-keyword">for</span> ( ; __cur != __last; ++__cur)
        _Construct(&amp;*__cur, __x);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _ForwardIter, <span class="hljs-keyword">class</span> _Tp, <span class="hljs-keyword">class</span> _Tp1&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>
__uninitialized_fill(_ForwardIter __first, _ForwardIter __last,
                     <span class="hljs-keyword">const</span> _Tp&amp; __x, _Tp1*)
{
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> __type_traits&lt;_Tp1&gt;::is_POD_type _Is_POD;
    __uninitialized_fill_aux(__first, __last, __x, _Is_POD());
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _ForwardIter, <span class="hljs-keyword">class</span> _Tp&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>
uninitialized_fill(_ForwardIter __first, _ForwardIter __last,
                   <span class="hljs-keyword">const</span> _Tp&amp; __x)
{
    __uninitialized_fill(__first, __last, __x, __value_type(__first));
}


<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _ForwardIter, <span class="hljs-keyword">class</span> _Size, <span class="hljs-keyword">class</span> _Tp&gt;
<span class="hljs-keyword">inline</span> _ForwardIter
__uninitialized_fill_n_aux(_ForwardIter __first, _Size __n,
                           <span class="hljs-keyword">const</span> _Tp&amp; __x, __true_type)
{
    <span class="hljs-keyword">return</span> fill_n(__first, __n, __x);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _ForwardIter, <span class="hljs-keyword">class</span> _Size, <span class="hljs-keyword">class</span> _Tp&gt;
_ForwardIter
__uninitialized_fill_n_aux(_ForwardIter __first, _Size __n,
                           <span class="hljs-keyword">const</span> _Tp&amp; __x, __false_type)
{
    _ForwardIter __cur = __first;
    <span class="hljs-keyword">for</span> ( ; __n &gt; <span class="hljs-number">0</span>; --__n, ++__cur)
        _Construct(&amp;*__cur, __x);
    <span class="hljs-keyword">return</span> __cur;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _ForwardIter, <span class="hljs-keyword">class</span> _Size, <span class="hljs-keyword">class</span> _Tp, <span class="hljs-keyword">class</span> _Tp1&gt;
<span class="hljs-keyword">inline</span> _ForwardIter
__uninitialized_fill_n(_ForwardIter __first, _Size __n, <span class="hljs-keyword">const</span> _Tp&amp; __x, _Tp1*)
{
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> __type_traits&lt;_Tp1&gt;::is_POD_type _Is_POD;
    <span class="hljs-keyword">return</span> __uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _ForwardIter, <span class="hljs-keyword">class</span> _Size, <span class="hljs-keyword">class</span> _Tp&gt;
<span class="hljs-keyword">inline</span> _ForwardIter
uninitialized_fill_n(_ForwardIter __first, _Size __n, <span class="hljs-keyword">const</span> _Tp&amp; __x)
{
    <span class="hljs-keyword">return</span> __uninitialized_fill_n(__first, __n, __x, __value_type(__first));
}</code></pre>



<h2 id="rawstorageiterator">raw_storage_iterator</h2>

<p>实现在stl_raw_storage_iter.h文件中。 <br>
用来在未初始化的内存中走访并进行初始化工作，这个类一般作为迭代器的基类。</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _ForwardIterator, <span class="hljs-keyword">class</span> _Tp&gt;
<span class="hljs-keyword">class</span> raw_storage_iterator
{
<span class="hljs-keyword">protected</span>:
    _ForwardIterator _M_iter;
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> output_iterator_tag iterator_category;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span>                value_type;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span>                difference_type;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span>                pointer;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span>                reference;

    <span class="hljs-keyword">explicit</span> raw_storage_iterator(_ForwardIterator __x) : _M_iter(__x) {}
    raw_storage_iterator&amp; <span class="hljs-keyword">operator</span>*() { <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; }
    raw_storage_iterator&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> _Tp&amp; __element)
    {
        <span class="hljs-keyword">new</span> ((<span class="hljs-keyword">void</span>*) (&amp;*_M_iter)) (*_ForwardIterator)(__element);
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    raw_storage_iterator&lt;_ForwardIterator, _Tp&gt;&amp; <span class="hljs-keyword">operator</span>++()
    {
        ++_M_iter;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    raw_storage_iterator&lt;_ForwardIterator, _Tp&gt; <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>)
    {
        raw_storage_iterator&lt;_ForwardIterator, _Tp&gt; __tmp = *<span class="hljs-keyword">this</span>;
        ++_M_iter;
        <span class="hljs-keyword">return</span> __tmp;
    }
};</code></pre>



<h2 id="临时缓存">临时缓存</h2>

<p>在stl_tempbuf.h文件中实现。</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">// get_temporary_buffer为n个T分配临时内存, 并返回指向内存块的指针和实际分配的数量</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> T&gt;
<span class="hljs-keyword">inline</span> pair &lt;T*, ptrdiff_t&gt;
get_temporary_buffer(ptrdiff_t n)
{
    <span class="hljs-keyword">if</span> (n &gt; ptrdiff_t(INT_MAX / <span class="hljs-keyword">sizeof</span>(T)))
        n = INT_MAX / <span class="hljs-keyword">sizeof</span>(T);

    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>)
    {
        T* tmp = (T*) <span class="hljs-built_in">malloc</span>((size_t)n * <span class="hljs-keyword">sizeof</span>(T));
        <span class="hljs-keyword">if</span> (tmp != <span class="hljs-number">0</span>)
            <span class="hljs-keyword">return</span> pair&lt;T*, ptrdiff_t&gt;(tmp, n);
        n /= <span class="hljs-number">2</span>;
    }

    <span class="hljs-keyword">return</span> pair&lt;T*, ptrdiff_t&gt;((T*)<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
}

<span class="hljs-comment">// return_temporary_buffer释放内存</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> T&gt;
<span class="hljs-keyword">void</span> return_temporary_buffer(T* p)
{
    <span class="hljs-built_in">free</span>(p);
}</code></pre></div></body>
</html>