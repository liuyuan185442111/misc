<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STL容器之valarray</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><p>valarray，为高速计算设计，以一些简化编程和一般用途的开支做为代价，主要用于数学计算。 <br>
valarray被定义于&lt;valarray&gt;中，sgi将其实现于诸多源文件中。 <br>
valarray不是STL标准容器。</p>

<p>看起来很烦，专业领域所用，也就不再深究，列出valarray的接口：</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> valarray
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> T value_type;

    <span class="hljs-comment">// 构造和析构</span>
    valarray();
    <span class="hljs-keyword">explicit</span> valarray(size_t);
    valarray(<span class="hljs-keyword">const</span> T&amp;, size_t);
    valarray(<span class="hljs-keyword">const</span> T*, size_t);
    valarray(<span class="hljs-keyword">const</span> valarray&amp;);
    valarray(<span class="hljs-keyword">const</span> slice_array&lt;T&gt;&amp;);
    valarray(<span class="hljs-keyword">const</span> gslice_array&lt;T&gt;&amp;);
    valarray(<span class="hljs-keyword">const</span> mask_array&lt;T&gt;&amp;);
    valarray(<span class="hljs-keyword">const</span> indirect_array&lt;T&gt;&amp;);
    ~valarray();

    <span class="hljs-comment">// 赋值</span>
    valarray&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> valarray&lt;T&gt;&amp;);
    valarray&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> T&amp;); <span class="hljs-comment">// 赋给所有元素</span>
    valarray&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> slice_array&lt;T&gt;&amp;);
    valarray&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> gslice_array&lt;T&gt;&amp;);
    valarray&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> mask_array&lt;T&gt;&amp;);
    valarray&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> indirect_array&lt;T&gt;&amp;);

    <span class="hljs-comment">// 下标访问</span>
    <span class="hljs-keyword">const</span> T&amp;          <span class="hljs-keyword">operator</span>[](size_t) <span class="hljs-keyword">const</span>;
    T&amp;                <span class="hljs-keyword">operator</span>[](size_t);
    valarray&lt;T&gt;       <span class="hljs-keyword">operator</span>[](slice) <span class="hljs-keyword">const</span>;
    slice_array&lt;T&gt;    <span class="hljs-keyword">operator</span>[](slice);
    valarray&lt;T&gt;       <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">const</span> gslice&amp;) <span class="hljs-keyword">const</span>;
    gslice_array&lt;T&gt;   <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">const</span> gslice&amp;);
    valarray&lt;T&gt;       <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">const</span> valarray&lt;<span class="hljs-keyword">bool</span>&gt;&amp;) <span class="hljs-keyword">const</span>;
    mask_array&lt;T&gt;     <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">const</span> valarray&lt;<span class="hljs-keyword">bool</span>&gt;&amp;);
    valarray&lt;T&gt;       <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">const</span> valarray&lt;size_t&gt;&amp;) <span class="hljs-keyword">const</span>;
    indirect_array&lt;T&gt; <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">const</span> valarray&lt;size_t&gt;&amp;);

    <span class="hljs-comment">// 运算符, 其他未列出</span>
    valarray&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>*= (<span class="hljs-keyword">const</span> T&amp;);
    valarray&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>*= (<span class="hljs-keyword">const</span> valarray&lt;T&gt;&amp;);

    <span class="hljs-comment">// member functions</span>
    size_t size() <span class="hljs-keyword">const</span>;
    T    sum() <span class="hljs-keyword">const</span>;
    T    min() <span class="hljs-keyword">const</span>;
    T    max() <span class="hljs-keyword">const</span>;
    <span class="hljs-keyword">void</span> resize(size_t size, T c = T());

    <span class="hljs-comment">// 移位, 正数左移, 负数右移</span>
    valarray&lt;T&gt; shift (<span class="hljs-keyword">int</span>) <span class="hljs-keyword">const</span>;
    valarray&lt;T&gt; cshift(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">const</span>; <span class="hljs-comment">// 循环移位</span>

    <span class="hljs-comment">// 对所有元素执行func函数</span>
    valarray&lt;T&gt; apply (T func(T)) <span class="hljs-keyword">const</span>;
    valarray&lt;T&gt; apply (T func(<span class="hljs-keyword">const</span> T&amp;)) <span class="hljs-keyword">const</span>;

<span class="hljs-keyword">private</span>:
    size_t _M_size;
    T* _M_data;
};</code></pre>

<p>另外，&lt;valarray&gt;还将cmath里的大部分数学函数都进行了重载，使之可应用于valarray。</p>

<p>valarray直接调用operator new()来获取内存，用operator delete()释放内存，所以模板参数里并没有空间配置器。</p>



<h2 id="sub-array">sub-array</h2>

<p><font color="red_"><strong>可以用operator<a href=""></a>来获得sub-array，可以对sub-array直接赋值，可以用sub-array来构造valarray。</strong></font> <br>
valarray定义了与此相关的slice，slice_array，gslice，gslice_array，mask_array，indirect_array几个辅助类。</p>

<p>cplusplus.com上的例子：</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">// valarray::operator[] example</span>
<span class="hljs-preprocessor">#include &lt;iostream&gt;     <span class="hljs-comment">// std::cout</span></span>
<span class="hljs-preprocessor">#include &lt;valarray&gt;     <span class="hljs-comment">// std::valarray, std::slice, std::gslice</span></span>

<span class="hljs-keyword">int</span> main ()
{
  <span class="hljs-built_in">std</span>::valarray&lt;<span class="hljs-keyword">int</span>&gt; myarray(<span class="hljs-number">10</span>);             <span class="hljs-comment">//  0  0  0  0  0  0  0  0  0  0</span>

  <span class="hljs-comment">// slice:</span>
  myarray[<span class="hljs-built_in">std</span>::slice(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)]=<span class="hljs-number">10</span>;              <span class="hljs-comment">//  0  0 10  0  0 10  0  0 10  0</span>

  <span class="hljs-comment">// gslice:</span>
  size_t lengths[]={<span class="hljs-number">2</span>,<span class="hljs-number">2</span>};
  size_t strides[]={<span class="hljs-number">6</span>,<span class="hljs-number">2</span>};
  myarray[<span class="hljs-built_in">std</span>::gslice(<span class="hljs-number">1</span>, <span class="hljs-built_in">std</span>::valarray&lt;size_t&gt;(lengths,<span class="hljs-number">2</span>), <span class="hljs-built_in">std</span>::valarray&lt;size_t&gt;(strides,<span class="hljs-number">2</span>))]=<span class="hljs-number">20</span>;
                                              <span class="hljs-comment">//  0 20 10 20  0 10  0 20 10 20</span>

  <span class="hljs-comment">// mask:</span>
  <span class="hljs-built_in">std</span>::valarray&lt;<span class="hljs-keyword">bool</span>&gt; mymask(<span class="hljs-number">10</span>);
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; ++i) mymask[i]= ((i%<span class="hljs-number">2</span>)==<span class="hljs-number">0</span>);
  myarray[mymask] += <span class="hljs-built_in">std</span>::valarray&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>);  <span class="hljs-comment">//  3 20 13 20  3 10  3 20 13 20</span>

  <span class="hljs-comment">// indirect:</span>
  size_t sel[]= {<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>};
  <span class="hljs-built_in">std</span>::valarray&lt;size_t&gt; myselection (sel,<span class="hljs-number">3</span>);   <span class="hljs-comment">//  3 20 99 20  3 99  3 99 13 20</span>
  myarray[myselection]=<span class="hljs-number">99</span>;

  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"myarray: "</span>;
  <span class="hljs-keyword">for</span> (size_t i=<span class="hljs-number">0</span>; i&lt;myarray.size(); ++i)
      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; myarray[i] &lt;&lt; <span class="hljs-string">' '</span>;
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">'\n'</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><strong>slice</strong> <br>
slice类有两个构造函数，一个是默认的，另一个接受三个参数，依次是起始位置，元素个数，元素间隔。</p>

<p><strong>gslice</strong> <br>
gslice类有三个构造函数：</p>

<pre><code>gslice();
gslice(size_t, const valarray&lt;size_t&gt;&amp;, const valarray&lt;size_t&gt;&amp;);
gslice(const gslice&amp;);
</code></pre>

<p>以第二个构造函数为例，a gslice with：</p>

<pre><code>start = 1
size = {2, 3}
stride = {7, 2}
</code></pre>

<p>would select：</p>



<pre class="prettyprint"><code class=" hljs markdown"><span class="hljs-code">                    [0][1][2][3][4][5][6][7][8][9][10][11][12][13]</span>
start=1:                *
<span class="hljs-code">                        |</span>
size=2, stride=7:       <span class="hljs-emphasis">*--------------------*</span>
<span class="hljs-code">                        |                    |</span>
size=3, stride=2:       <span class="hljs-emphasis">*-----*</span>-----<span class="hljs-bullet">*        *</span>------<span class="hljs-emphasis">*------*</span>
<span class="hljs-code">                        |     |     |        |      |      |</span>
gslice:                 <span class="hljs-bullet">*     *</span>     <span class="hljs-bullet">*        *</span>      <span class="hljs-bullet">*      *</span>
<span class="hljs-code">                    [0][1][2][3][4][5][6][7][8][9][10][11][12][13]</span></code></pre>

<p><strong>mask</strong> <br>
选则参数mask中为true的元素对应valarray中的元素。</p>

<p><strong>indirect</strong> <br>
将indirect中的元素作为下标，选择对应valarray中的元素。</p>

<p><font color="red_"><strong>这四种方式都指定了valarray中部分元素，以它们作为参数调用operator<a href=""></a>，将得到四种对应的array，然后可用这四种array构造valarray（通过构造函数或赋值运算符函数），或对原valarray进行赋值。</strong></font></p>

<p>主要参考：<a href="http://www.cplusplus.com/reference/valarray/">http://www.cplusplus.com/reference/valarray/</a></p></div></body>
</html>