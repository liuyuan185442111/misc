<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STL容器之list</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><pre><code>template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class list;
</code></pre>

<p>内部实现是一个双向循环链表，为符合前闭后开的特点，添加了一个空节点，list内部存储的即指向此空节点的指针，仅凭此指针便可标识整个链表。 <br>
begin()获得的是此指针的next，end()获得的是此指针。 <br>
下面是list的接口：</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">// 构造、析构、赋值、获得allocator</span>
<span class="hljs-keyword">explicit</span> <span class="hljs-built_in">list</span>(<span class="hljs-keyword">const</span> allocator_type&amp; alloc = allocator_type());
<span class="hljs-keyword">explicit</span> <span class="hljs-built_in">list</span>(size_type n, <span class="hljs-keyword">const</span> value_type&amp; val = value_type(),
                <span class="hljs-keyword">const</span> allocator_type&amp; alloc = allocator_type());
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> InputIterator&gt;
<span class="hljs-built_in">list</span>(InputIterator first, InputIterator last,
        <span class="hljs-keyword">const</span> allocator_type&amp; alloc = allocator_type());
<span class="hljs-built_in">list</span>(<span class="hljs-keyword">const</span> <span class="hljs-built_in">list</span>&amp; x);
~<span class="hljs-built_in">list</span>();
<span class="hljs-built_in">list</span>&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">list</span>&amp; x);
allocator_type get_allocator() <span class="hljs-keyword">const</span>;

<span class="hljs-comment">// 迭代器</span>
iterator begin();
const_iterator begin() <span class="hljs-keyword">const</span>;
terator end();
const_iterator end() <span class="hljs-keyword">const</span>;
reverse_iterator rbegin();
const_reverse_iterator rbegin() <span class="hljs-keyword">const</span>;
reverse_iterator rend();
const_reverse_iterator rend() <span class="hljs-keyword">const</span>;

<span class="hljs-comment">// 容量</span>
<span class="hljs-keyword">bool</span> empty() <span class="hljs-keyword">const</span>;
size_type size() <span class="hljs-keyword">const</span>;
size_type max_size() <span class="hljs-keyword">const</span>;

<span class="hljs-comment">// 成员访问</span>
<span class="hljs-comment">// 即*begin()</span>
reference front();
const_reference front() <span class="hljs-keyword">const</span>;
<span class="hljs-comment">// 即*(--end())</span>
reference back();
const_reference back() <span class="hljs-keyword">const</span>;

<span class="hljs-comment">// 修改</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> InputIterator&gt;
<span class="hljs-keyword">void</span> assign(InputIterator first, InputIterator last);
<span class="hljs-keyword">void</span> assign(size_type n, <span class="hljs-keyword">const</span> value_type&amp; val);
<span class="hljs-comment">// 即insert(begin(), val), 新插入的节点是新的头节点</span>
<span class="hljs-keyword">void</span> push_front(<span class="hljs-keyword">const</span> value_type&amp; val);
<span class="hljs-comment">// 即erase(begin())</span>
<span class="hljs-keyword">void</span> pop_front();
<span class="hljs-comment">// 即insert(end(), val)</span>
<span class="hljs-keyword">void</span> push_back(<span class="hljs-keyword">const</span> value_type&amp; val);
<span class="hljs-comment">// 即erase(--end())</span>
<span class="hljs-keyword">void</span> pop_back();
<span class="hljs-comment">// 都是在position之前插入</span>
<span class="hljs-comment">// 返回指向插入节点的迭代器</span>
iterator insert(iterator position, <span class="hljs-keyword">const</span> value_type&amp; val);
<span class="hljs-keyword">void</span> insert(iterator position, size_type n, <span class="hljs-keyword">const</span> value_type&amp; val);
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> InputIterator&gt;
<span class="hljs-keyword">void</span> insert(iterator position, InputIterator first, InputIterator last);
<span class="hljs-comment">// 返回指向position后面节点的迭代器</span>
iterator erase(iterator position);
<span class="hljs-comment">// 实际是调用上面的erase(), 返回指向last后面节点的迭代器</span>
iterator erase(iterator first, iterator last);
<span class="hljs-comment">// 实际是交换指向空节点的指针</span>
<span class="hljs-keyword">void</span> swap(<span class="hljs-built_in">list</span>&amp; x);
<span class="hljs-keyword">void</span> resize(size_type n, value_type val = value_type());
<span class="hljs-comment">// erase所有节点</span>
<span class="hljs-keyword">void</span> clear();

<span class="hljs-comment">// 操作</span>
<span class="hljs-comment">// 将x拼接到position之前</span>
<span class="hljs-keyword">void</span> splice(iterator position, <span class="hljs-built_in">list</span>&amp; x);
<span class="hljs-comment">// 将i指向的节点拼接到position之前</span>
<span class="hljs-keyword">void</span> splice(iterator position, <span class="hljs-built_in">list</span>&amp; x, iterator i);    
<span class="hljs-comment">// 将[first,last)拼接到position之前</span>
<span class="hljs-keyword">void</span> splice(iterator position, <span class="hljs-built_in">list</span>&amp; x, iterator first, iterator last);
<span class="hljs-comment">// erase掉所有值为val的节点</span>
<span class="hljs-keyword">void</span> remove(<span class="hljs-keyword">const</span> value_type&amp; val);
<span class="hljs-comment">// erase掉所有pred(*iterator)为真的节点</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> Predicate&gt;
<span class="hljs-keyword">void</span> remove_if(Predicate pred);
<span class="hljs-comment">// 将所有相同的相邻节点减少为1个, 保留第一个出现的, erase掉其他的</span>
<span class="hljs-keyword">void</span> unique();
<span class="hljs-comment">// 节点相同的判定条件为binary_pred(*cur, *next)为真</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> BinaryPredicate&gt;
<span class="hljs-keyword">void</span> unique(BinaryPredicate binary_pred);
<span class="hljs-comment">// 需要保证*this和x都为升序, merge完毕, x为空, *this升序排序</span>
<span class="hljs-keyword">void</span> merge(<span class="hljs-built_in">list</span>&amp; x);
<span class="hljs-comment">// 当comp(x,y)表示x&lt;y时, 最终list是升序排列</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> Compare&gt;
<span class="hljs-keyword">void</span> merge(<span class="hljs-built_in">list</span>&amp; x, Compare comp);
<span class="hljs-comment">// 调用merge()进行排序</span>
<span class="hljs-keyword">void</span> sort();
<span class="hljs-comment">// comp是merge()的排序规则</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> Compare&gt;
<span class="hljs-keyword">void</span> sort(Compare comp);

<span class="hljs-comment">// 关系操作符和swap</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> T, <span class="hljs-keyword">class</span> Alloc&gt;
<span class="hljs-keyword">void</span> swap(<span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;T,Alloc&gt;</span>&amp; x, <span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;T,Alloc&gt;</span>&amp; y);
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> T, <span class="hljs-keyword">class</span> Alloc&gt;
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;T,Alloc&gt;</span>&amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;T,Alloc&gt;</span>&amp; rhs);
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> T, <span class="hljs-keyword">class</span> Alloc&gt;
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;T,Alloc&gt;</span>&amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;T,Alloc&gt;</span>&amp; rhs);
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> T, <span class="hljs-keyword">class</span> Alloc&gt;
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;T,Alloc&gt;</span>&amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;T,Alloc&gt;</span>&amp; rhs);
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> T, <span class="hljs-keyword">class</span> Alloc&gt;
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;T,Alloc&gt;</span>&amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;T,Alloc&gt;</span>&amp; rhs);
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> T, <span class="hljs-keyword">class</span> Alloc&gt;
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;T,Alloc&gt;</span>&amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;T,Alloc&gt;</span>&amp; rhs);
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> T, <span class="hljs-keyword">class</span> Alloc&gt;
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;T,Alloc&gt;</span>&amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;T,Alloc&gt;</span>&amp; rhs);</code></pre>

<p>并没有看懂它的排序算法（这是gcc 4.7.1里的）：</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Alloc&gt;
<span class="hljs-keyword">void</span> <span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;_Tp, _Alloc&gt;</span>::sort()
{
    <span class="hljs-comment">// Do nothing if the list has length 0 or 1.</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_M_impl._M_node._M_next != &amp;<span class="hljs-keyword">this</span>-&gt;_M_impl._M_node
            &amp;&amp; <span class="hljs-keyword">this</span>-&gt;_M_impl._M_node._M_next-&gt;_M_next != &amp;<span class="hljs-keyword">this</span>-&gt;_M_impl._M_node)
    {
        <span class="hljs-built_in">list</span> __carry;
        <span class="hljs-built_in">list</span> __tmp[<span class="hljs-number">64</span>];
        <span class="hljs-built_in">list</span> * __fill = &amp;__tmp[<span class="hljs-number">0</span>];
        <span class="hljs-built_in">list</span> * __counter;

        <span class="hljs-keyword">do</span>
        {
            __carry.splice(__carry.begin(), *<span class="hljs-keyword">this</span>, begin());

            <span class="hljs-keyword">for</span>(__counter = &amp;__tmp[<span class="hljs-number">0</span>];
                    __counter != __fill &amp;&amp; !__counter-&gt;empty();
                    ++__counter)
            {
                __counter-&gt;merge(__carry);
                __carry.swap(*__counter);
            }
            __carry.swap(*__counter);
            <span class="hljs-keyword">if</span> (__counter == __fill)
                ++__fill;
        }
        <span class="hljs-keyword">while</span> ( !empty() );

        <span class="hljs-keyword">for</span> (__counter = &amp;__tmp[<span class="hljs-number">1</span>]; __counter != __fill; ++__counter)
            __counter-&gt;merge(*(__counter - <span class="hljs-number">1</span>));
        swap( *(__fill - <span class="hljs-number">1</span>) );
    }
}</code></pre>

<p>我尝试改成普通函数来理解，还是没懂：</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;list&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">void</span> show(<span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>&amp;l)
{
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">':'</span>;
    <span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>::iterator i;
    <span class="hljs-keyword">for</span>(i=l.begin(); i!=l.end(); ++i)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="hljs-string">' '</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; endl;
}
<span class="hljs-keyword">void</span> sortx(<span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> &amp;l);
<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> l;
    l.push_back(<span class="hljs-number">3</span>);
    l.push_back(<span class="hljs-number">2</span>);
    l.push_back(<span class="hljs-number">5</span>);
    l.push_back(<span class="hljs-number">1</span>);
    l.push_back(<span class="hljs-number">4</span>);
    l.push_back(<span class="hljs-number">6</span>);
    l.push_back(<span class="hljs-number">7</span>);
    l.push_back(<span class="hljs-number">8</span>);
    show(l);
    <span class="hljs-built_in">cout</span> &lt;&lt; endl;

    sortx(l);
    <span class="hljs-comment">//l.sort();</span>
    <span class="hljs-comment">//show(l);</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">// 神奇的算法</span>
<span class="hljs-keyword">void</span> sortx(<span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> &amp;l)
{
    <span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> carry;
    <span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> tmp[<span class="hljs-number">64</span>];
    <span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> * fill = &amp;tmp[<span class="hljs-number">0</span>];
    <span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> * counter;

    <span class="hljs-keyword">do</span>
    {
        carry.splice(carry.begin(), l, l.begin());

        <span class="hljs-comment">// counter到达目前最大值或counter为空时结束</span>
        <span class="hljs-keyword">for</span>(counter = &amp;tmp[<span class="hljs-number">0</span>]; counter != fill &amp;&amp; !counter-&gt;empty(); ++counter)
        {
            counter-&gt;merge(carry); <span class="hljs-comment">// carry里的数据merge到counter里, carry变为空</span>
            carry.swap(*counter);
        }
        carry.swap(*counter);
        <span class="hljs-keyword">if</span> (counter == fill)
            ++fill;

        <span class="hljs-comment">//show(carry); // 总是空的!</span>
        <span class="hljs-comment">// 依次存1,2,4,8...个数据, 满了推到上层</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"---------\n"</span>;
        show(tmp[<span class="hljs-number">0</span>]);
        show(tmp[<span class="hljs-number">1</span>]);
        show(tmp[<span class="hljs-number">2</span>]);
        show(tmp[<span class="hljs-number">3</span>]);
        getchar();
    }
    <span class="hljs-keyword">while</span> ( !l.empty() );

    <span class="hljs-keyword">for</span> (counter = &amp;tmp[<span class="hljs-number">1</span>]; counter != fill; ++counter)
        counter-&gt;merge(*(counter - <span class="hljs-number">1</span>));
    l.swap( *(fill - <span class="hljs-number">1</span>) );
}</code></pre></div></body>
</html>