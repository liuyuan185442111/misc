<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STL之stack</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><p>栈，LIFO的数据结构。</p>

<pre><code>template &lt;typename T, typename Container = deque&lt;T&gt; &gt; class stack;
</code></pre>

<p>stack是一个容器适配器，数据从容器的一端插入和取出（称为top端）。内部有一个Container类型的private变量，用来存储数据。</p>

<p>容器只要支持如下操作即可作为stack的内部容器：</p>

<pre><code>empty()、size()、back()、push_back()、pop_back()
</code></pre>

<p>vector，deque，list都满足要求，默认使用的是deque。</p>

<p>根据标准，stack有3个成员类型：</p>

<pre><code>value_type      第一个模板参数     栈元素的类型
container_type  第二个模板参数     栈内部容器的类型
size_type       一个无符号整型     通常是size_t类型
</code></pre>

<p>stack还有一些成员函数，它们都是public的：</p>

<pre><code>explicit stack (const container_type&amp; ctnr = container_type());
参数类型须和第二个模板参数相同

bool empty() const;
判断stack是否为空，即size是否为0，调用内部容器的empty()

size_type size() const;
调用内部容器的size()

value_type&amp; top();
const value_type&amp; top() const;
返回顶部元素，调用内部容器的back()

void push (const value_type&amp; val);
插入一个元素，被初始化为val的拷贝，调用内部容器的push_back()

void pop();
移除顶部元素，会调用移除元素的析构函数，调用内部容器的pop_back()
</code></pre>

<p>此外，stack还有一些关系操作符，它们都是模板函数。（lhs=the left-hand side）</p>

<pre><code>template &lt;class T, class Container&gt;
bool operator== (const stack&lt;T,Container&gt;&amp; lhs, const stack&lt;T,Container&gt;&amp; rhs);
template &lt;class T, class Container&gt;
bool operator!= (const stack&lt;T,Container&gt;&amp; lhs, const stack&lt;T,Container&gt;&amp; rhs);
template &lt;class T, class Container&gt;
bool operator&lt;  (const stack&lt;T,Container&gt;&amp; lhs, const stack&lt;T,Container&gt;&amp; rhs);
template &lt;class T, class Container&gt;
bool operator&lt;= (const stack&lt;T,Container&gt;&amp; lhs, const stack&lt;T,Container&gt;&amp; rhs);
template &lt;class T, class Container&gt;
bool operator&gt;  (const stack&lt;T,Container&gt;&amp; lhs, const stack&lt;T,Container&gt;&amp; rhs);
template &lt;class T, class Container&gt;
bool operator&gt;= (const stack&lt;T,Container&gt;&amp; lhs, const stack&lt;T,Container&gt;&amp; rhs);
</code></pre>

<p>下面是stack的完整源代码（stl_stack.h）：</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">// operator==和operator&lt;的前向声明对于友元的声明是必须的</span>
<span class="hljs-comment">// stack的前向声明对于operator==和operator&lt;的声明是必须的</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Sequence = <span class="hljs-stl_container"><span class="hljs-built_in">deque</span>&lt;_Tp&gt;</span> &gt;
<span class="hljs-keyword">class</span> <span class="hljs-built_in">stack</span>;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Seq&gt;
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">stack</span>&lt;_Tp,_Seq&gt;</span>&amp; __x, <span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">stack</span>&lt;_Tp,_Seq&gt;</span>&amp; __y);
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Seq&gt;
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">stack</span>&lt;_Tp,_Seq&gt;</span>&amp; __x, <span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">stack</span>&lt;_Tp,_Seq&gt;</span>&amp; __y);

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Sequence&gt;
<span class="hljs-keyword">class</span> <span class="hljs-built_in">stack</span>
{
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Tp1, <span class="hljs-keyword">typename</span> _Seq1&gt;
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">stack</span>&lt;_Tp1, _Seq1&gt;</span>&amp;, <span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">stack</span>&lt;_Tp1, _Seq1&gt;</span>&amp;);
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Tp1, <span class="hljs-keyword">typename</span> _Seq1&gt;
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">stack</span>&lt;_Tp1, _Seq1&gt;</span>&amp;, <span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">stack</span>&lt;_Tp1, _Seq1&gt;</span>&amp;);

<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> _Sequence::value_type      value_type;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> _Sequence::size_type       size_type;
    <span class="hljs-keyword">typedef</span>           _Sequence                  container_type;

    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> _Sequence::reference       reference;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> _Sequence::const_reference const_reference;

<span class="hljs-keyword">protected</span>:
    _Sequence c;

<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">stack</span>() : c() {}
    <span class="hljs-keyword">explicit</span> <span class="hljs-built_in">stack</span>(<span class="hljs-keyword">const</span> _Sequence&amp; __s) : c(__s) {}
    <span class="hljs-keyword">bool</span> empty() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> c.empty(); }
    size_type size() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> c.size(); }
    reference top() { <span class="hljs-keyword">return</span> c.back(); }
    const_reference top() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> c.back(); }
    <span class="hljs-keyword">void</span> push(<span class="hljs-keyword">const</span> value_type&amp; __x) { c.push_back(__x); }
    <span class="hljs-keyword">void</span> pop() { c.pop_back(); }
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Seq&gt;
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">stack</span>&lt;_Tp,_Seq&gt;</span>&amp; __x, <span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">stack</span>&lt;_Tp,_Seq&gt;</span>&amp; __y)
{
    <span class="hljs-keyword">return</span> __x.c == __y.c;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Seq&gt;
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">stack</span>&lt;_Tp,_Seq&gt;</span>&amp; __x, <span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">stack</span>&lt;_Tp,_Seq&gt;</span>&amp; __y)
{
    <span class="hljs-keyword">return</span> __x.c &lt; __y.c;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Seq&gt;
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">stack</span>&lt;_Tp,_Seq&gt;</span>&amp; __x, <span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">stack</span>&lt;_Tp,_Seq&gt;</span>&amp; __y)
{
    <span class="hljs-keyword">return</span> !(__x == __y);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Seq&gt;
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">stack</span>&lt;_Tp,_Seq&gt;</span>&amp; __x, <span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">stack</span>&lt;_Tp,_Seq&gt;</span>&amp; __y)
{
    <span class="hljs-keyword">return</span> __y &lt; __x;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Seq&gt;
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">stack</span>&lt;_Tp,_Seq&gt;</span>&amp; __x, <span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">stack</span>&lt;_Tp,_Seq&gt;</span>&amp; __y)
{
    <span class="hljs-keyword">return</span> !(__y &lt; __x);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Seq&gt;
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">stack</span>&lt;_Tp,_Seq&gt;</span>&amp; __x, <span class="hljs-keyword">const</span> <span class="hljs-stl_container"><span class="hljs-built_in">stack</span>&lt;_Tp,_Seq&gt;</span>&amp; __y)
{
    <span class="hljs-keyword">return</span> !(__x &lt; __y);
}</code></pre></div></body>
</html>