<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STL之auto_ptr</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><p><strong>在c++11里auto_ptr被声明为过时的。</strong> <br>
智能指针在std_memory.h中实现，下面是它的源码（稍有改动）：</p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _Tp1&gt;
<span class="hljs-keyword">struct</span> auto_ptr_ref
{
    _Tp1* _M_ptr;
    auto_ptr_ref(_Tp1* __p) : _M_ptr(__p) {}
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _Tp&gt;
<span class="hljs-keyword">class</span> <span class="hljs-built_in">auto_ptr</span>
{
<span class="hljs-keyword">private</span>:
    _Tp *_M_ptr;

<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> _Tp element_type;

    <span class="hljs-built_in">auto_ptr</span>(_Tp *p = <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span>() : _M_ptr(p) {}

    <span class="hljs-comment">// 复制构造函数和赋值函数</span>
    <span class="hljs-built_in">auto_ptr</span>(<span class="hljs-built_in">auto_ptr</span> &amp;a) <span class="hljs-keyword">throw</span>() : _M_ptr(a.release()) {}
    <span class="hljs-built_in">auto_ptr</span> &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-built_in">auto_ptr</span> &amp;__a) <span class="hljs-keyword">throw</span>()
    {
        reset(__a.release());
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }

    <span class="hljs-comment">// 泛化复制和赋值</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _Tp1&gt;
    <span class="hljs-built_in">auto_ptr</span>(<span class="hljs-built_in">auto_ptr</span>&lt;_Tp1&gt; &amp;__a) <span class="hljs-keyword">throw</span>()
        : _M_ptr(__a.release()) {}
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _Tp1&gt;
    <span class="hljs-built_in">auto_ptr</span> &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-built_in">auto_ptr</span>&lt;_Tp1&gt; &amp;__a) <span class="hljs-keyword">throw</span>()
    {
        reset(__a.release());
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }

    <span class="hljs-comment">// 类型转换运算符</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _Tp1&gt;
    <span class="hljs-keyword">operator</span> <span class="hljs-built_in">auto_ptr</span>&lt;_Tp1&gt;() <span class="hljs-keyword">throw</span>()
    {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">auto_ptr</span>&lt;_Tp1&gt;(<span class="hljs-keyword">this</span>-&gt;release());
    }

    ~<span class="hljs-built_in">auto_ptr</span>()
    {
        <span class="hljs-keyword">delete</span> _M_ptr;
    }

    _Tp &amp;<span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> <span class="hljs-keyword">throw</span>()
    {
        <span class="hljs-keyword">return</span> *_M_ptr;
    }
    _Tp *<span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> <span class="hljs-keyword">throw</span>()
    {
        <span class="hljs-keyword">return</span> _M_ptr;
    }
    _Tp *get() <span class="hljs-keyword">const</span> <span class="hljs-keyword">throw</span>()
    {
        <span class="hljs-keyword">return</span> _M_ptr;
    }

    <span class="hljs-comment">// 将指针清零并返回清零前的指针</span>
    _Tp *release() <span class="hljs-keyword">throw</span>()
    {
        _Tp *__tmp = _M_ptr;
        _M_ptr = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> __tmp;
    }
    <span class="hljs-comment">// 将_M_ptr清零后指向新的内容</span>
    <span class="hljs-keyword">void</span> reset(_Tp* __p = <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span>()
    {
        <span class="hljs-keyword">if</span> (__p != _M_ptr)
        {
            <span class="hljs-keyword">delete</span> _M_ptr;
            _M_ptr = __p;
        }
    }

<span class="hljs-comment">// 以下存在意义在于接受右值参数, 详见于对应文档</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _Tp1&gt;
    <span class="hljs-keyword">operator</span> auto_ptr_ref&lt;_Tp1&gt;() <span class="hljs-keyword">throw</span>()
    {
        <span class="hljs-keyword">return</span> auto_ptr_ref&lt;_Tp&gt;(<span class="hljs-keyword">this</span>-&gt;release());
    }

    <span class="hljs-built_in">auto_ptr</span>(auto_ptr_ref&lt;_Tp&gt; __ref) <span class="hljs-keyword">throw</span>()
        : _M_ptr(__ref._M_ptr) {}
    <span class="hljs-built_in">auto_ptr</span> &amp;<span class="hljs-keyword">operator</span>=(auto_ptr_ref&lt;_Tp&gt; __ref) <span class="hljs-keyword">throw</span>()
    {
        <span class="hljs-keyword">if</span> (__ref._M_ptr != <span class="hljs-keyword">this</span>-&gt;get())
        {
            <span class="hljs-keyword">delete</span> _M_ptr;
            _M_ptr = __ref._M_ptr;
        }
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
};</code></pre>



<h2 id="原理">原理</h2>

<p>auto_ptr的拷贝构造函数和赋值操作符，与一般类的做法不太相同，它们的参数都是auto_ptr&amp;，而不是auto_ptr const &amp;。一般来说，类的拷贝构造函数和赋值操作符的参数都是const &amp;。但是auto_ptr的做法也是合理的：<strong>确保拥有权能够转移</strong>。 <br>
auto_ptr强调对资源的<strong>拥有权（ownership）</strong>。也就是说，auto_ptr是“它所指对象”的拥有者，一个对象只能属于一个拥有者。 <br>
为了保证auto_ptr的拥有权唯一，auto_ptr的拷贝构造函数和赋值操作符做了这样一件事情：<strong>移除另一个auto_ptr的拥有权</strong>。 <br>
如果auto_ptr的拷贝构造函数和赋值操作符的参数是auto_ptr const &amp;，那么实参的拥有权将不能转移。因为转移拥有权需要修改auto_ptr的成员变量，而实参确是一个const对象，不允许修改。</p>

<h2 id="问题">问题</h2>

<p>但是呢，这样会带来一个问题。 <br>
假如写出这样的代码：</p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;memory&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv) {
    <span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; ptr1(<span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1</span>))); <span class="hljs-comment">// 使用临时对象进行拷贝构造</span>
    <span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; ptr2;
    ptr2 = (<span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1</span>))); <span class="hljs-comment">// 使用临时对象进行赋值</span>
}</code></pre>

<p>假设没有定义auto_ptr_ref类及相关的函数，那么这段代码将不能通过编译。主要的原因是，拷贝构造函数及赋值操作符的参数：<code>auto_ptr&lt;int&gt;(new int(1))</code>是<strong>临时对象</strong>。临时对象属于典型的<strong>右值</strong>，而<strong><font color="#DC143C">非const &amp;是不能指向右值的</font></strong>。（参见More Effective C++，Item 19）。比如：</p>

<pre><code>int &amp;a = 5; // 错误
const int &amp;b = 5; // 可以, 仅语法通过, 实际没什么意义, const int b = 5;效果是一样的
</code></pre>

<p>auto_ptr的拷贝构造函数及赋值操作符的参数类型恰恰是auto_ptr&amp;，而非const auto_ptr &amp;。 <br>
同理，下面的两段代码，也不会通过编译：</p>

<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;memory&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; f() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 这里也使用临时对象进行拷贝构造</span>
}
<span class="hljs-keyword">int</span> main() {
    <span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; ptr3(f()); <span class="hljs-comment">// 使用临时对象进行拷贝构造</span>
    <span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; ptr4;
    ptr4 = f(); <span class="hljs-comment">// 使用临时对象进行赋值  </span>
}</code></pre>

<p>普通类不会遇到这个问题，是因为他们的拷贝构造函数及赋值操作符（不管是用户定义还是编译器生成的版本），参数都是const &amp;。</p>



<h2 id="autoptrref之原理">auto_ptr_ref之原理</h2>

<p>下面的构造函数，是可以接受auto_ptr临时对象的。</p>

<pre><code>auto_ptr(auto_ptr __a) throw() : _M_ptr(__a.release()) { }
</code></pre>

<p>但上述构造函数不能通过编译，因为它会循环调用自己（该构造函数会调用auto_ptr的拷贝构造函数）。我们稍作修改：</p>

<pre><code>auto_ptr(auto_ptr_ref&lt;element_type&gt; __ref) throw() // element_type就是auto_ptr的模板参数
: _M_ptr(__ref._M_ptr) {}
</code></pre>

<p>该版本的构造函数，可以接受auto_ptr_ref的临时对象。如果auto_ptr可以隐式转换到auto_ptr_ref，那么我们就能够用auto_ptr临时对象来调用该构造函数。这个隐式转换不难实现：</p>

<pre><code>template&lt;typename _Tp1&gt;
operator auto_ptr_ref&lt;_Tp1&gt;() throw()
{ return auto_ptr_ref&lt;_Tp1&gt;(this-&gt;release()); }
</code></pre>

<p>好像auto_ptr_ref赋予了auto_ptr“引用”的语义一样。</p>

<h2 id="用mutable突破限制">用mutable突破限制</h2>

<p>上面问题的根源在于<strong>非const &amp;是不能指向右值的</strong>，那么我们就让复制构造和赋值函数的形参变成const &amp;。 <br>
因为形参auto_ptr const&amp; a会调用release()，所以release()必须也变为const，但是release()还需要修改私有成员_M_ptr的值。此时，mutable修饰符出场，将_M_ptr限定为mutable的，问题解决。 <br>
实现如下（顺带测试了一下）：</p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-built_in">auto_ptr</span>
{
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">mutable</span> T *M_ptr;

<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">auto_ptr</span>(T *p = <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span>() : M_ptr(p) {}
    <span class="hljs-built_in">auto_ptr</span>(<span class="hljs-built_in">auto_ptr</span> <span class="hljs-keyword">const</span> &amp;a) <span class="hljs-keyword">throw</span>() : M_ptr(a.release()) {}
    <span class="hljs-built_in">auto_ptr</span> &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-built_in">auto_ptr</span> <span class="hljs-keyword">const</span> &amp;a) <span class="hljs-keyword">throw</span>()
    {
        reset(a.release());
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    ~<span class="hljs-built_in">auto_ptr</span>()
    {
        <span class="hljs-keyword">delete</span> M_ptr;
    }

    T &amp;<span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> <span class="hljs-keyword">throw</span>()
    {
        <span class="hljs-keyword">return</span> *M_ptr;
    }
    T *<span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> <span class="hljs-keyword">throw</span>()
    {
        <span class="hljs-keyword">return</span> M_ptr;
    }
    T *get() <span class="hljs-keyword">const</span> <span class="hljs-keyword">throw</span>()
    {
        <span class="hljs-keyword">return</span> M_ptr;
    }

    <span class="hljs-comment">// 唯有以下两个函数会对M_ptr进行修改</span>
    T *release() <span class="hljs-keyword">const</span> <span class="hljs-keyword">throw</span>()
    {
        T *tmp = M_ptr;
        M_ptr = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> tmp;
    }
    <span class="hljs-keyword">void</span> reset(T *p = <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span>()
    {
        <span class="hljs-keyword">if</span> (p != M_ptr)
        {
            <span class="hljs-keyword">delete</span> M_ptr;
            M_ptr = p;
        }
    }

    <span class="hljs-comment">// 泛化复制和赋值</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> T1&gt;
    <span class="hljs-built_in">auto_ptr</span>(<span class="hljs-built_in">auto_ptr</span>&lt;T1&gt; &amp;a) <span class="hljs-keyword">throw</span>() : M_ptr(a.release()) {}
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> T1&gt;
    <span class="hljs-built_in">auto_ptr</span> &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-built_in">auto_ptr</span>&lt;T1&gt; &amp;a) <span class="hljs-keyword">throw</span>()
    {
        reset(a.release());
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    <span class="hljs-comment">// 类型转换运算符</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> T1&gt;
    <span class="hljs-keyword">operator</span> <span class="hljs-built_in">auto_ptr</span>&lt;T1&gt;() <span class="hljs-keyword">throw</span>()
    {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">auto_ptr</span>&lt;T1&gt;(<span class="hljs-keyword">this</span>-&gt;release());
    }
};

<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; ptr1(<span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1</span>)));
    <span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; ptr2;
    ptr2 = (<span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1</span>)));
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *ptr1 &lt;&lt; *ptr2;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p>需要注意的是，<code>mutable T *M_ptr;</code>可以写成<code>T mutable *M_ptr;</code>，但不能写成<code>T * mutable M_ptr;</code>，虽然从意义上来说mutable修饰的确实是M_ptr。 <br>
mutable只能用于修饰类的非静态数据成员，它的存在就是为了突破const的限制，const auto_ptr的成员M_ptr是不可变的，但*M_ptr是可变的，既然mutable的功能只是为了突破const的限制，必然是让M_ptr变得可变。mutable的功能单一，放在语句的最前边也就行了。 <br>
虽然mutable和const是一对反义词，但从语法上来说，volatile和const比较像。</p>

<h2 id="参考">参考</h2>

<p>为什么需要auto_ptr_ref <br>
<a href="http://www.iteye.com/topic/746062" target="_blank">http://www.iteye.com/topic/746062</a></p></div></body>
</html>