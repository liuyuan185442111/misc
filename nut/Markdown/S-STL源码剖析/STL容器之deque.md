deque (通常读作 "deck")是一个double-ended queue。
deque动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。

deque采用两层存储结构，用一块所谓的map（非STL的map容器）作为主控，map是一个数组，数组元素是一个指针，指向另一段连续性空间，称为缓冲区。缓冲区是deque的存储空间主体。

deque内部存储有指向map的指针（T**类型），map的大小（size_type类型），map已使用部分的起始和结尾位置，指向起始节点的start迭代器，指向结尾节点的finish迭代器。通过这些信息，便可以完全确定一个双端队列。

deque迭代器保存有所指节点所在的缓冲区在map中的位置，缓冲区的起始和终止位置，当前节点在缓冲区中的位置。
比较繁杂的是迭代器的移动操作，可能会移至不同缓冲区。

缓冲区的大小是固定的（一些实现里或许可以设置此大小），当插入或删除节点时，缓冲区的数目可能会相应增多或减少。map的大小却是不固定的，类似vector的处理策略，它会随着新节点的插入一直增大，而不会减少。实现尽量使用map中间的部分，而将两边的部分空出来作为预留空间，以便减少在前后端执行push操作时map的调整动作。

当执行insert操作时，实现会判断插入点前后的节点数目，选择数目少的一端进行移动。进行erase操作时也是这样。

deque提供的接口与list，vector差不多，就不再赘述。

deque方便了在front端插入与删除，但其他操作比vector的效率差很多。
除非有必要，尽可能选择使用vector而非deque。
对deque进行的排序操作，为了最高效率，可将deque先完整复制到一个vector，将vector排序后（利用STL sort算法），再复制回deque。

大体内容就是这些，其他细节可参考：
1. list和vector的实现
2. STL源码剖析 4.4 deque
3. sgi STL的deque源码