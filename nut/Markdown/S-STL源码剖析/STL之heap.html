<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STL之heap</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><p>heap并不归属与STL容器组件，它是个幕后英雄，扮演priority queue的助手。 <br>
heap在algorithm头文件中实现，sgi把它放在了stl_heap.h中。 <br>
共有4个操纵heap的函数，分别是：</p>

<pre><code>push_heap, pop_heap, make_heap, sort_heap
</code></pre>



<h2 id="堆的知识">堆的知识</h2>



<h3 id="堆的定义">堆的定义</h3>

<p>二叉堆是一种完全二叉树，它满足两个特性： <br>
1．父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值。 <br>
2．每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。 <br>
当父结点的键值总是大于或等于任何一个子节点的键值时为最大堆（max-heap）。当父结点的键值总是小于或等于任何一个子节点的键值时为最小堆（min-heap）。</p>



<h3 id="堆的存储">堆的存储</h3>

<p>一般用数组来表示堆： <br>
<img src="http://img.my.csdn.net/uploads/201108/22/0_1314014706gZqn.gif" alt="存储" title=""> <br>
如果数组从0节点开始存储，i节点的父节点下标就为(i–1)/2，它的左右子节点下标分别为2*i+1和2*i+2。 <br>
如果数组的0节点弃用，从1节点开始存储，i节点的父节点下标为i/2，左右子节点下标分别为2*i和2*i+1。</p>



<h3 id="堆的push">堆的push</h3>

<p>新加入的元素放在数组的末尾处，然后执行一个上溯过程：将新节点与其父节点比较，如果比父节点大（对于max-heap），父子就兑换位置，如此一直上溯，直到不需要兑换或到根节点。</p>

<h3 id="堆的pop">堆的pop</h3>

<p>取出根节点，将最后一个节点的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。 <br>
调整时先在左右儿子结点中找最大的（对于max-heap），如果父结点比这个最大的子结点还大说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于从根结点开始将一个数据“下沉”的过程。</p>

<h3 id="堆化数组">堆化数组</h3>

<p>最简单的一个想法是：一个一个元素的push进heap进行了。但实际上可以更高效一些，看上面的那张图，所有的叶子节点已经是合法的堆了，所以只要从节点56开始调整即可。</p>

<h3 id="参考">参考</h3>

<p>白话经典算法系列之七 堆与堆排序 <br>
<a href="http://blog.csdn.net/morewindows/article/details/6709644/" target="_blank">http://blog.csdn.net/morewindows/article/details/6709644/</a> <br>
STL源码剖析，侯捷</p>



<h2 id="我的实现">我的实现</h2>

<p>根据以上思路写出的代码（可能用了两个小时）：</p>

<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;ctime&gt;</span>
<span class="hljs-preprocessor">#include &lt;cstdlib&gt;</span>
<span class="hljs-preprocessor">#include &lt;vector&gt;</span>
<span class="hljs-preprocessor">#include &lt;memory&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">int</span> buf[] = {<span class="hljs-number">34</span>, <span class="hljs-number">56</span>, <span class="hljs-number">43</span>, <span class="hljs-number">82</span>};
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> heap(buf, buf+<span class="hljs-number">4</span>);

<span class="hljs-comment">// 调整节点i, 使其符合max-heap的条件</span>
<span class="hljs-comment">// 假定节点i以后的节点都满足max-heap的条件</span>
<span class="hljs-keyword">void</span> adjust(<span class="hljs-keyword">int</span> i)
{
    <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>*i+<span class="hljs-number">2</span>; <span class="hljs-comment">// 右子节点</span>
    <span class="hljs-comment">// 不断下沉</span>
    <span class="hljs-keyword">while</span>(j &lt; heap.size()) <span class="hljs-comment">// 右子节点存在</span>
    {
        <span class="hljs-keyword">if</span>(heap[j-<span class="hljs-number">1</span>]&gt;heap[j]) --j; <span class="hljs-comment">// 找到子节点中较大的</span>
        <span class="hljs-keyword">if</span>(heap[j]&lt;=heap[i]) <span class="hljs-keyword">break</span>;
        swap(heap[j],heap[i]);
        i = j;
        j = <span class="hljs-number">2</span>*i+<span class="hljs-number">2</span>;
    }
    <span class="hljs-keyword">if</span>(j == heap.size()) <span class="hljs-comment">// 只有左子节点, 没有右子节点的情况</span>
    {
        <span class="hljs-keyword">if</span>(heap[j-<span class="hljs-number">1</span>]&gt;heap[i]) swap(heap[j-<span class="hljs-number">1</span>],heap[i]);
    }
    <span class="hljs-comment">// i是叶子节点的情况不作处理</span>
}

<span class="hljs-comment">// 构建max-heap</span>
<span class="hljs-keyword">void</span> MakeHeap()
{
    <span class="hljs-keyword">int</span> len = heap.size();
    <span class="hljs-comment">// 共有(len+1)/2个叶子节点</span>
    <span class="hljs-comment">// 从 len-叶子节点数+1 开始构造堆, 即从(len+1)/2开始</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=(len+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>; i&gt;=<span class="hljs-number">0</span>; --i)
        adjust(i);
}

<span class="hljs-keyword">void</span> PushHeap(<span class="hljs-keyword">int</span> a)
{
    heap.push_back(a);
    <span class="hljs-keyword">int</span> j = heap.size()-<span class="hljs-number">1</span>; <span class="hljs-comment">// 子节点</span>
    <span class="hljs-comment">// 上溯</span>
    <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span>)
    {
        <span class="hljs-keyword">int</span> i = (j-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>; <span class="hljs-comment">// 父节点</span>
        <span class="hljs-keyword">if</span>(heap[j] &lt;= heap[i]) <span class="hljs-keyword">break</span>;
        swap(heap[j],heap[i]);
        j = i;
    }
}

<span class="hljs-keyword">void</span> PopHeap()
{
    <span class="hljs-built_in">cout</span> &lt;&lt; *heap.begin() &lt;&lt; <span class="hljs-string">' '</span>;
    *heap.begin() = *(heap.end()-<span class="hljs-number">1</span>);
    heap.pop_back();
    adjust(<span class="hljs-number">0</span>);
}

<span class="hljs-keyword">int</span> main()
{
    MakeHeap();
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; ++i)
        PushHeap(rand()%<span class="hljs-number">99</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">14</span>; ++i)
        PopHeap();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>



<h2 id="stl源码">STL源码</h2>

<p>下面是四个函数的声明：</p>

<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">// 执行完毕后, [first,last)是一个合法的堆</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> RandomAccessIterator&gt;
<span class="hljs-keyword">void</span> make_heap (RandomAccessIterator first, RandomAccessIterator last);
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> RandomAccessIterator, <span class="hljs-keyword">class</span> Compare&gt;
<span class="hljs-keyword">void</span> make_heap (RandomAccessIterator first, RandomAccessIterator last, Compare comp );

<span class="hljs-comment">// [first,last-1)是一个合法的堆, last-1位置是新push的值, 执行完毕后[first,last)是新的堆</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> RandomAccessIterator&gt;
<span class="hljs-keyword">void</span> push_heap (RandomAccessIterator first, RandomAccessIterator last);
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> RandomAccessIterator, <span class="hljs-keyword">class</span> Compare&gt;
<span class="hljs-keyword">void</span> push_heap (RandomAccessIterator first, RandomAccessIterator last, Compare comp);

<span class="hljs-comment">// [first,last)是一个合法的堆, 执行完毕后[first,last-1)是新的堆, 原堆顶元素置于last-1位置</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> RandomAccessIterator&gt;
<span class="hljs-keyword">void</span> pop_heap (RandomAccessIterator first, RandomAccessIterator last);
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> RandomAccessIterator, <span class="hljs-keyword">class</span> Compare&gt;
<span class="hljs-keyword">void</span> pop_heap (RandomAccessIterator first, RandomAccessIterator last, Compare comp);

<span class="hljs-comment">// [first,last)是一个合法的堆, 执行完毕后原序列不再是堆, 而是有序的序列</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> RandomAccessIterator&gt;
<span class="hljs-keyword">void</span> sort_heap (RandomAccessIterator first, RandomAccessIterator last);
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> RandomAccessIterator, <span class="hljs-keyword">class</span> Compare&gt;
<span class="hljs-keyword">void</span> sort_heap (RandomAccessIterator first, RandomAccessIterator last, Compare comp);</code></pre>

<p>每个函数都有两个版本，第一个版本接受两个随机访问迭代器，第二个版本额外还接受一个比较对象。 <br>
以下是第一个版本的源码：</p>

<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">//__first:序列起始位置 __holeIndex:hole的索引 __topIndex:堆顶索引 __value:要push的元素</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _RandomAccessIterator, <span class="hljs-keyword">class</span> _Distance, <span class="hljs-keyword">class</span> _Tp&gt;
<span class="hljs-keyword">void</span>
__push_heap(_RandomAccessIterator __first,
            _Distance __holeIndex, _Distance __topIndex, _Tp __value)
{
    <span class="hljs-comment">// hole不断上浮, 小于__value的__parent不断下沉, 最后将__value放在合适的位置上</span>
    _Distance __parent = (__holeIndex - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
    <span class="hljs-keyword">while</span> (__holeIndex &gt; __topIndex &amp;&amp; *(__first + __parent) &lt; __value)
    {
        *(__first + __holeIndex) = *(__first + __parent);
        __holeIndex = __parent;
        __parent = (__holeIndex - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
    }
    *(__first + __holeIndex) = __value;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _RandomAccessIterator, <span class="hljs-keyword">class</span> _Distance, <span class="hljs-keyword">class</span> _Tp&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>
__push_heap_aux(_RandomAccessIterator __first,
                _RandomAccessIterator __last, _Distance*, _Tp*)
{
    __push_heap(__first, _Distance((__last - __first) - <span class="hljs-number">1</span>), _Distance(<span class="hljs-number">0</span>),
                _Tp(*(__last - <span class="hljs-number">1</span>)));
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _RandomAccessIterator&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    <span class="hljs-comment">// 调用此函数时, 新元素应已置于容器的最尾端</span>
    __push_heap_aux(__first, __last, __distance_type(__first), __value_type(__first));
}


<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _RandomAccessIterator, <span class="hljs-keyword">class</span> _Distance, <span class="hljs-keyword">class</span> _Tp&gt;
<span class="hljs-keyword">void</span>
__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
              _Distance __len, _Tp __value)
{
    _Distance __topIndex = __holeIndex;
    _Distance __secondChild = <span class="hljs-number">2</span> * __holeIndex + <span class="hljs-number">2</span>;
    <span class="hljs-keyword">while</span> (__secondChild &lt; __len)
    {
        <span class="hljs-keyword">if</span> (*(__first + __secondChild) &lt; *(__first + (__secondChild - <span class="hljs-number">1</span>)))
            __secondChild--;
        *(__first + __holeIndex) = *(__first + __secondChild);
        __holeIndex = __secondChild;
        __secondChild = <span class="hljs-number">2</span> * (__secondChild + <span class="hljs-number">1</span>);
    }
    <span class="hljs-keyword">if</span> (__secondChild == __len)
    {
        *(__first + __holeIndex) = *(__first + (__secondChild - <span class="hljs-number">1</span>));
        __holeIndex = __secondChild - <span class="hljs-number">1</span>;
    }
    __push_heap(__first, __holeIndex, __topIndex, __value);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _RandomAccessIterator, <span class="hljs-keyword">class</span> _Tp, <span class="hljs-keyword">class</span> _Distance&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>
__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
           _RandomAccessIterator __result, _Tp __value, _Distance*)
{
    *__result = *__first;
    __adjust_heap(__first, _Distance(<span class="hljs-number">0</span>), _Distance(__last - __first), __value);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _RandomAccessIterator, <span class="hljs-keyword">class</span> _Tp&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>
__pop_heap_aux(_RandomAccessIterator __first, _RandomAccessIterator __last,
               _Tp*)
{
    __pop_heap(__first, __last - <span class="hljs-number">1</span>, __last - <span class="hljs-number">1</span>,
               _Tp(*(__last - <span class="hljs-number">1</span>)), __distance_type(__first));
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _RandomAccessIterator&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> pop_heap(_RandomAccessIterator __first,
                     _RandomAccessIterator __last)
{
    __pop_heap_aux(__first, __last, __value_type(__first));
}


<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _RandomAccessIterator, <span class="hljs-keyword">class</span> _Tp, <span class="hljs-keyword">class</span> _Distance&gt;
<span class="hljs-keyword">void</span>
__make_heap(_RandomAccessIterator __first,
            _RandomAccessIterator __last, _Tp*, _Distance*)
{
    <span class="hljs-keyword">if</span> (__last - __first &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;
    _Distance __len = __last - __first;
    _Distance __parent = (__len - <span class="hljs-number">2</span>)/<span class="hljs-number">2</span>;

    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)
    {
        __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)));
        <span class="hljs-keyword">if</span> (__parent == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
        __parent--;
    }
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _RandomAccessIterator&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    __make_heap(__first, __last,
                __value_type(__first), __distance_type(__first));
}


<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> _RandomAccessIterator&gt;
<span class="hljs-keyword">void</span> sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    <span class="hljs-keyword">while</span> (__last - __first &gt; <span class="hljs-number">1</span>)
        pop_heap(__first, __last--);
}</code></pre>

<p>第二个版本与第一个版本只有比较的地方不同，其他地方完全一样，例如：</p>

<pre class="prettyprint"><code class="language-cpp hljs ">    <span class="hljs-keyword">while</span> (__holeIndex &gt; __topIndex &amp;&amp; *(__first + __parent) &lt; __value)
    {
        *(__first + __holeIndex) = *(__first + __parent);
        __holeIndex = __parent;
        __parent = (__holeIndex - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
    }

    <span class="hljs-keyword">while</span> (__holeIndex &gt; __topIndex &amp;&amp; __comp(*(__first + __parent), __value))
    {
        *(__first + __holeIndex) = *(__first + __parent);
        __holeIndex = __parent;
        __parent = (__holeIndex - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
    }</code></pre>

<p>通过设置第二个版本的第三个模板参数，就可以实现min-heap。</p>

<p>总体而言，sgi的实现和我的实现大体相同，还有几点不同： <br>
1. push和pop操作的元素的位置 <br>
调用push()之前，新元素应已置于容器的最尾端； <br>
调用pop()之后，旧元素将置于容器的最尾端，所以，调用sort_heap()之后，两个迭代器之间的数据就有序了。 <br>
2. 交换动作 <br>
push()和pop()使用了hole的概念，通过hole的上浮和下沉来进行调整。</p></div></body>
</html>