<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>诛仙的攻击过程</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><h2 id="普通攻击">普通攻击</h2>

<p>人发出的攻击，客户端会发送给服务器C2S::NORMAL_ATTACK命令，然后new一个session_normal_attack，在其中调用gactive_imp::NormalAttack；怪发出的攻击，在session_npc_attack中调用gactive_imp::NormalAttack。 <br>
然后调用gactive_imp::DoAttack，DoAttack是虚函数，有不同的实现。 <br>
人和怪的DoAttack都会形成一个attack_msg，经过_filters.EF_TranslateSendAttack的处理后发给被攻击者。不同的是，人还会进入战斗状态，并通知宠物和召唤兽进行攻击，并按概率减少武器的魂力 (装备的魂力是在gplayer_imp::AdjustDamage中减少的) 。 <br>
然后攻击消息GM_MSG_ATTACK就发到了被攻击者那里，此时强制攻击、红名、白名之类的还没有判断。</p>

<p>对方收到攻击消息后，会判断阵营，经_filters.EF_TranslateRecvAttack处理，最后调用HandleAttackMsg。</p>



<h2 id="普通技能">普通技能</h2>

<p>人发出的攻击，客户端会发送给服务器C2S::CAST_SKILL命令，对辰皇进行了特殊处理，对连续技也进行了特殊处理。</p>

<p>连续技： <br>
GNET::SkillWrapper::GetPreCastSkillId返回参数表示的技能id的前提技能，这是一个静态成员函数，系统把连续技的前提技能存在一个static map里，如果当前技能有前提技能，查看当前的session是不是前提技能的session。</p>

<p>辰皇： <br>
如果处于元无间状态，释放特定技能，由灵使用spirit_session_skill来释放该技能，spirit_session_skill的特殊之处在于它的GetExclusiveMask返回0，表示在有spirit_session_skill时，可以添加其他session，而session_skill的GetExclusiveMask返回~(SS_MASK_MOVE)，表示在有spirit_session_skill时，只能添加move session。</p>

<p>下面进入session_skill： <br>
session_skill::StartSession调用GNET::SkillWrapper::StartSkill，返回第一击的时间，如果小于50毫秒则是瞬发技能， 调用GNET::SkillWrapper::Run；否则，进入session定时机制，第一击结束后，调用GNET::SkillWrapper::Run，若后面还有段数，不断定时调用GNET::SkillWrapper::Run。</p>

<p>如果是蓄力技能，蓄力结束会调用session_skill::RestartSession，调用GNET::SkillWrapper::Continue，并把蓄力的tick传给它。</p>

<p>在SkillWrapper::StartSkill中，create技能，会检查skill-&gt;Condition();和冷却时间，检查pray距离，执行Skill::FirstRun，destroy技能。</p>

<p>反正最后会调用：</p>

<pre><code>bool Run(const SkillStub::State *state)
{
    state-&gt;Calculate(this);
    return true;
}
</code></pre>

<p>player.perform=x;会被解析为skill-&gt;GetPlayer()-&gt;SetPerform(x); <br>
在bool PlayerWrapper::SetPerform(int inform)中： <br>
如果攻击范围是自己，先执行StateAttack，再执行BlessMe，再执行CalcCost扣蓝，直接返回。 <br>
如果攻击范围不是自己，先执行BlessMe。</p>

<p>如果是攻击技能，形成一个attack_msg：</p>

<pre><code>    object.FillAttackMsg(XID(-1,-1), msg, 0); 
    msg.crit_rate    += (int)(1000*skill-&gt;GetCrit());
    msg.crit_factor  += skill-&gt;GetCrithurt();
    msg.skill_attack_rate  += skill-&gt;GetSkillaccu();
</code></pre>

<p>object.Attack(*target,msg,0); <br>
根据攻击范围不同选择调用： <br>
object.RegionAttack1 <br>
object.RegionAttack2 <br>
object.RegionAttack3</p>

<p>如果是祝福或诅咒，形成一个enchant_msg，然后调用： <br>
object.Enchant <br>
object.RegionEnchant1 <br>
object.RegionEnchant2 <br>
object.RegionEnchant3</p>

<p>然后计算消耗CalcCost();</p>

<p>object_interface::Attack很简单，直接发送GM_MSG_ATTACK消息。 <br>
object_interface::Enchant很简单，直接发送GM_MSG_ENCHANT消息。 <br>
Region类的则会收集周围的目标，发消息出去，对人数的控制是在gmatrix::SendMultiMessage里实现的。 <br>
GetCoverage返回最多的攻击人数。 <br>
这里有个坑，收集目标的时候是收集所有active的东西，而对怪无效、对人无效是在被攻击那里判断的，这就导致对怪无效的群攻技能有时候打不到足够多的人。</p>

<p>然后发消息到了被攻击者，如果SetPerform参数不为0，还会调用一个PlayerWrapper::DoPerform，这里处理了技能的冷却。</p>



<h2 id="被攻击者">被攻击者</h2>

<p>普攻和攻击技能通过GM_MSG_ATTACK消息发送，祝福和诅咒技能通过GM_MSG_ENCHANT消息发送。前者会调用HandleAttackMsg，后者会调用HandleEnhantMsg。</p>

<p>在gactive_imp::HandleAttackMsg中： <br>
首先判断一些攻击限制和阵营</p>

<p>计算命中和基础伤害（gactive_imp::AttackJudgement）： <br>
如果是物理攻击，命中的计算如下： <br>
int rate =  (普攻命中 + 180)/3 - (普攻躲闪 - 55)/2; <br>
if(rate &lt; 40) rate = 40; <br>
if(rate &gt; 99) rate = 99; <br>
技能攻击（技能命中是面板显示值减去100后再乘10，技能躲闪是面板显示值的10倍）： <br>
Rand(0,1000) &lt; 1000+技能命中-技能躲闪 <br>
每次命中概率其实就是技能命中-命中躲闪</p>

<p>基础伤害=rand(damage_low, damage_high)-防御，最小为0 <br>
damage_low和damage_high在攻击者那里计算，对于人：damage_low是ratio*最低攻击+plus，damage_high是ratio*最高攻击+plus</p>

<p>如果受攻击的是怪，加仇恨 <br>
如果受攻击的是人，进入战斗状态，通知宠物和召唤兽反击，如果是辰皇，用光灵反击</p>

<p>处理反弹</p>

<p>被隐身的人攻击，爆率加50%</p>

<p>得到基础伤害和伤害倍数后，让filter通过EF_AdjustDamage处理一下</p>

<p>float damage = dmg.damage * dmg.adjust + attack-&gt;spec_damage + dmg.damage_no_crit; <br>
spec_damage是附加伤害，不计算防御；damage_no_crit是不出暴的伤害，计算防御，是技能编辑器里的plus2</p>

<p>然后计算百分比减免伤害 <br>
计算人对人对怪的伤害百分比增减</p>

<p>计算造化的增减</p>

<p>固定减少伤害的判定</p>

<p>再加上一个fixed_damage（无视防御和减免，好像没有用）</p>

<p>最后得到了int_damage</p>

<p>另外还有一个神圣力伤害dt_damage</p>

<p>通过DoDamage扣血，在DoDamage里filter通过EF_BeforeDamage还处理了一下，但是客户端显示的还是未处理前的伤害</p>

<p>filter通过EF_BeAttacked处理一下</p>

<p>把伤害发给客户端显示</p>

<p>struct attack_msg中有</p>

<pre><code>struct
{
    int skill;
    int level;
} attached_skill;
</code></pre>

<p>如果技能有对被攻击者的效果，会在DoPerform里对其进行赋值，在HandleAttackMsg的后面会调用_skill.Attack，这里边会执行StateAttack。</p></div></body>
</html>