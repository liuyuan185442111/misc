<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>c++11常用新特性：语言层面</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h2><a id="_0"></a>强类型枚举</h2>
<p>在c语言中，枚举类型是整型，但长度由编译器决定，枚举类型的成员的可见范围被提升至该枚举类型所在的作用域内。</p>
<p>在c++11中引入了称为强类型枚举的新类型，由关键字enum class或enum struct标识。<br>
每一个enum class都是一个新的类型，不能与整型自动转换。<br>
enum class成员的作用域起自其声明之处，终止于enum class定义结束之处。<br>
可显式声明枚举类型（包括不限定作用域的enum）的长度。</p>
<pre><code>enum struct Level : char
{
	first, second,
};

Level l = Level::second;
//l = 2;//error
cout &lt;&lt; sizeof(l) &lt;&lt; endl;//1
</code></pre>
<h2><a id="autodecltype_17"></a>auto和decltype</h2>
<p>定义迭代器类型的时候不用写很长的一串了，比如：</p>
<pre><code>std::map&lt;std::string, std::vector&lt;int&gt;&gt; m;
for(auto it = std::begin(m); it != std::end(m); ++it) 
{
}
</code></pre>
<p>这段代码还展示了两个地方，一是&gt;&gt;中间不用加空格了，二是全局的begin和end函数（函数模板）。</p>
<p>auto先计算出表达式，再根据表达式的结果来推断类型。<br>
auto会忽略掉直接修饰变量的const，但会保留指针指向变量的const。</p>
<pre><code>int i=0;
const int ci=i, &amp;cr = ci;
auto b=ci;//int
auto c=cr;//int
auto d=&amp;i;//int*
auto e=&amp;ci;//const int*
const auto f=ci;//const int
const auto g=&amp;ci;//const int * const
auto &amp;h=ci;//const int&amp;
</code></pre>
<p>同一个赋值语句中，auto可用来声明多个变量的类型，编译器会用第一个变量去推导auto的类型，推导出来的数据类型被作用于其他变量（来自《深入理解c++11》4.2节）：</p>
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>g <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> h <span class="token operator">=</span> y<span class="token punctuation">;</span> <span class="token comment">//h: const int</span>
<span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">*</span>m <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> n <span class="token operator">=</span> y<span class="token punctuation">;</span> <span class="token comment">//auto: int, n: int</span>
<span class="token keyword">auto</span> o <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>p <span class="token operator">=</span> o<span class="token punctuation">,</span> <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">;</span>
</code></pre>
<p>这基本符合我们的想象。</p>
<h2><a id="decltype_46"></a>decltype</h2>
<blockquote>
<p>当用decltype(e)来获取类型时，编译器将依序判断一下四规则：<br>
如果e是一个变量或类成员，那么decltype(e)就是e的类型<br>
否则，假设e的类型是T，如果e是一个将亡值，那么decltype(e)为T&amp;&amp;<br>
否则，假设e的类型是T，如果e是一个左值，那么decltype(e)为T&amp;<br>
否则，假设e的类型是T，则decltype(e)为T</p>
</blockquote>
<p>以上内容和下面的例子摘自《深入了解c++11》4.3.3节：</p>
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> arr<span class="token punctuation">;</span>
<span class="token keyword">struct</span> S <span class="token punctuation">{</span> <span class="token keyword">double</span> d<span class="token punctuation">;</span> <span class="token punctuation">}</span> s<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">Overloaded</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">Overloaded</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span> <span class="token function">RvalRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">bool</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 规则1: 单个标记符表达式以及访问类成员，推导为本类型</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> var1<span class="token punctuation">;</span>             <span class="token comment">// int[5], 标记符表达式</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> var2<span class="token punctuation">;</span>             <span class="token comment">// int*, 标记符表达式</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>d<span class="token punctuation">)</span> var4<span class="token punctuation">;</span>             <span class="token comment">// double, 成员访问表达式</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>Overloaded<span class="token punctuation">)</span> var5<span class="token punctuation">;</span>      <span class="token comment">// 无法通过编译，是个重载的函数</span>

<span class="token comment">// 规则2: 将亡值，推导为类型的右值引用</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">RvalRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> var6 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// int&amp;&amp;</span>

<span class="token comment">// 规则3: 左值，推导为类型的引用</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">?</span> i <span class="token operator">:</span> i<span class="token punctuation">)</span> var7 <span class="token operator">=</span> i<span class="token punctuation">;</span>     <span class="token comment">// int&amp;, 三元运算符，这里返回一个i的左值</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> var8 <span class="token operator">=</span> i<span class="token punctuation">;</span>              <span class="token comment">// int&amp;, 带圆括号的左值</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">++</span>i<span class="token punctuation">)</span> var9 <span class="token operator">=</span> i<span class="token punctuation">;</span>              <span class="token comment">// int&amp;, ++i返回i的左值</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> var10 <span class="token operator">=</span> i<span class="token punctuation">;</span>          <span class="token comment">// int&amp;, []操作返回左值</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span>  var11 <span class="token operator">=</span> i<span class="token punctuation">;</span>           <span class="token comment">// int&amp;, *操作返回左值</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token string">"lval"</span><span class="token punctuation">)</span> var12 <span class="token operator">=</span> <span class="token string">"lval"</span><span class="token punctuation">;</span>     <span class="token comment">// const char(&amp;)[9], 字符串字面常量为左值</span>

<span class="token comment">// 规则4：以上都不是，推导为本类型</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> var13<span class="token punctuation">;</span>               <span class="token comment">// int, 除字符串外字面常量为右值</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>i<span class="token operator">++</span><span class="token punctuation">)</span> var14<span class="token punctuation">;</span>             <span class="token comment">// int, i++返回右值</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">Func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> var15<span class="token punctuation">;</span>       <span class="token comment">// const bool, 圆括号可以忽略</span>
</code></pre>
<p>以下是来自其他地方的一些类似描述：<br>
<strong>如果decltype使用的表达式是一个变量，则decltype返回该变量的类型，包括直接修饰变量的const和引用</strong>。引用从来都是作为其所指对象的同义词出现，只有用在decltype处是一个例外。</p>
<pre><code>const int ci=0, &amp;cj=ci;
decltype(ci) x=0;//x与ci的类型完全相同，const int
decltype(cj) y=x;//y和cj的类型完全相同，const int &amp;
</code></pre>
<p><strong>如果decltype使用的表达式不是一个变量，则返回表达式结果对应的类型。</strong><br>
<strong>但如果表达式可以作为左值，产生的就是引用。</strong></p>
<p>auto和decltype组合起来用能实现函数返回类型后置：</p>
<pre><code>template &lt;typename T, typename U&gt;
auto add(T t, U u) -&gt; decltype(t + u) {
	return t + u;
}
</code></pre>
<h2><a id="_101"></a>新的区间迭代</h2>
<p>由于auto的出现，上节例子中的区间迭代简化了一些，然而c++11提供了更简洁的区间迭代：</p>
<pre><code>std::map&lt;std::string, std::vector&lt;int&gt;&gt; m;
for(auto e:m) 
{
}
</code></pre>
<dl>
<dt>为了使数据结构可迭代：</dt>
<dd>这个数据结构必须要有begin和end方法，成员方法和独立函数都行，这两个方法分别返回开始和结束的迭代器</dd>
<dd>迭代器支持*操作符、!=操作符、++方法（前缀形式，成员函数和独立函数都行）</dd>
</dl>
<p>新的区间迭代其实是调用了std::begin和std::end，所以自定义的数据结构实现begin和end成员方法就可以了，当然也可以对std::begin和std::end进行特化。</p>
<h2><a id="nullptr_113"></a>nullptr</h2>
<p>增强的安全的空指针类型，是nullptr_t类型的常量，nullptr_t是由nullptr定义的：</p>
<pre><code>typedef decltype(nullptr) nullptr_t;
</code></pre>
<p>另外，c语言标准中的void *指针是可以隐式转换为任意指针的，c++不行。所以一般NULL在c里被定义为(void *)0，在c++里被定义为0。</p>
<h2><a id="_118"></a>统一的初始化列表</h2>
<p>在引入c++11之前，只有数组和结构体能使用初始化列表，而且初始化列表还得放在等号后边，其他容器想要使用初始化列表，只能用以下方法：</p>
<pre><code>int arr[3] = {1, 2, 3}  
vector&lt;int&gt; v(arr, arr + 3); 
</code></pre>
<p>在c++11中，可以使用以下语法来进行初始化：</p>
<pre><code>int arr[3]{1, 2, 3};  
vector&lt;int&gt; iv{1, 2, 3};  
map&lt;int, string&gt;{{1, "a"}, {2, "b"}};  
string str{"Hello World"}; 
</code></pre>
<h2><a id="lambda_130"></a>lambda</h2>
<p>[]内放的是变量捕获。变量捕获的魔法是如何运作的？其实lambda实现的方法是创建一个简略的类。这个类重载了operator()，所以表现的像个普通函数。一个lambda函数是这个类的实例。当这个类构造的时候，所有捕获的变量被传送到类中并保存为成员变量。c++11的优势是这一切都变得非常简单。你可以在任意时候使用它，而不仅仅是极少的特殊场合去写一个类。<br>
c++为性能计，实际上提供了好几种灵活的捕捉变量的方式。[]中什么也没有则不捕获变量，如果你创建了一个空[]的lambda函数，c++将创建一个普通的函数而不是类。这里有完整的捕获选项：</p>
<pre><code>[]  不捕获任何变量
[&amp;] 以引用方式捕获所有变量(包括this)
[=] 用值的方式捕获所有变量(包括this)
[=, &amp;foo] 以引用捕获foo, 但其余变量都靠值捕获
[bar] 以值方式捕获bar, 不捕获其它变量
[this] 捕获所在类的this指针
</code></pre>
<p>捕捉列表仅能捕捉父作用域的<strong>自动变量</strong>，而对超出这个范围的变量，是不能被捕捉的。全局变量不用捕获便能访问。<br>
忽略返回类型的话，编译器会自动推断出返回类型，如果需要指定，参考：</p>
<pre><code>auto add = [](int a, int b) -&gt; int { return a + b; };
</code></pre>
<p>如果参数为空<code>()</code>可以省略，所以最简单的lambda函数是<code>[]{}</code>。</p>
<p>默认情况下lambda函数是一个const函数，可以在参数列表后面添加mutable修饰符来取消其常量性，在使用mutable时，参数列表不可省略，即使参数为空。这里的const指的是捕获的变量是const的，和参数没关系。相当于对应的函数对象的operator()是const的，即函数对象本身是const的，所以它的成员变量都不可变。</p>
<p>新的std::function可用来传递lambda函数。<br>
维基百科说，闭包是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以我认为c++11的lambda函数并不是真正的闭包。</p>
<h2><a id="_150"></a>显式缺省函数/显式删除函数</h2>
<p>c++11标准称"=default"修饰的函数为显式缺省函数，而称"=delete"修饰的函数为显式删除函数。<br>
参考<a href="https://www.cnblogs.com/diegodu/p/6101798.html">《C++ default 和delete的新用法》</a>。</p>
<h2><a id="overridefinal_153"></a>override和final</h2>
<p>override确保在派生类中声明的重载函数跟基类的虚函数有相同的签名。<br>
final有两个用途。第一，它可以阻止从类派生；第二，它可以阻止一个虚函数的重载。</p>
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">TaskManager</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> final<span class="token punctuation">;</span> 
<span class="token keyword">class</span> <span class="token class-name">PrioritizedTaskManager</span><span class="token operator">:</span> <span class="token keyword">public</span> TaskManager <span class="token punctuation">{</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//compilation error: base class TaskManager is final</span>

<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
pulic<span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span>  <span class="token class-name">B</span><span class="token operator">:</span> A
<span class="token punctuation">{</span>
pulic<span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> override final<span class="token punctuation">;</span> <span class="token comment">//OK</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">:</span> B
<span class="token punctuation">{</span>
pulic<span class="token operator">:</span>
 <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment">//error, B::func is final</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>例子来自：<a href="https://www.kancloud.cn/wangshubo1989/new-characteristics/99708">https://www.kancloud.cn/wangshubo1989/new-characteristics/99708</a></p>
<h2><a id="_178"></a>委托构造</h2>
<p>一个类的构造函数可以调用这个类的其他构造函数了。<br>
还可以复用基类的构造函数，通过<code>using Base::Base;</code>来声明使用基类的构造函数，这样就避免了定义相同的构造函数来保持和基类一样的初始化行为。</p>
<h2><a id="noexcept_181"></a>noexcept</h2>
<p>noexcept 运算符<br>
noexcept( expression )<br>
noexcept 运算符进行编译时检查，若表达式声明为不抛出任何异常则返回 true。</p>
<p>noexcept 限定符<br>
noexcept( constant expression )<br>
在函数的后面加上 noexcept，指定函数是否抛出异常。noexcept 等价于 noexcept(true)，代表这个函数不会抛出异常，如果抛出异常程序就会终止。</p>
<h2><a id="alignofalignas_189"></a>alignof和alignas</h2>
<p>alignof 运算符<br>
alignof( 类型标识 )<br>
查询类型的对齐要求。返回 std::size_t 类型值。<br>
返回由类型标识所指示的类型的任何实例所要求的对齐字节数，该类型可以为完整类型、数组类型或者引用类型。<br>
若类型为引用类型，则运算符返回被引用类型的对齐；若类型为数组类型，则返回元素类型的对齐要求。</p>
<p>alignas 指定符<br>
指定类型或对象的对齐要求。<br>
alignas(int) 等价于 alignas(alignof(int))</p>
<pre><code>// 每个 sse_t 类型对象将对齐到 16 字节边界
struct alignas(16) sse_t
{
	float sse_data[4];
};
 
// 数组 "cacheline" 将对齐到 128字节边界
alignas(128) char cacheline[128];
</code></pre>
<p>简而言之，alignof和alignas分别用来获取和设置<a href="https://blog.csdn.net/liuyuan185442111/article/details/46038149">《结构体和类的大小问题》</a>中提到的对齐参数。</p>
<p>另外标准库还有与此相关的概念：<br>
max_align_t，定义于<code>&lt;cstddef&gt;</code>，是一个平凡的标准内存布局类型，它的对齐参数至少和所有标量类型一样严格，也就是说它的对齐参数大于等于所有标量类型的对齐参数。（标量类型：非数组、非class类型）<br>
内存分配函数返回的指针对齐至少和max_align_t一样严格，也就是说其对齐参数大于等于alignof(std::max_align_t)。<br>
max_align_t通常被实现为最大标量类型的同义词，一般是long double类型。所以一般malloc和new返回的指针至少是sizeof(long double)对齐的。<br>
align、aligned_storage、aligned_union，多数编译器并未实现align函数，后两者是类模板，不多介绍了。</p>
<h2><a id="constexpr_216"></a>constexpr</h2>
<p>constexpr 限定符声明可以在编译时求得函数或变量的值，前提是它所依赖的东西也是可以在编译期求得，但实际上它可能并不能在编译期算出来。<br>
若函数或函数模板的任何声明拥有 constexpr 限定符，则每个声明必须都含有该限定符。<br>
constexpr 修饰的函数，如果其返回值可以在编译时期计算出来，那么这个函数就会产生编译时期的值，否则就和普通函数一样。<br>
常量表达式函数的要求有：<br>
函数体只有单一的return返回语句<br>
函数必须有返回值<br>
在使用前必须已有定义<br>
return返回语句表达式中不能使用非常量表达式的函数、全局数据</p>
<h2><a id="_225"></a>用户自定义字面量</h2>
<p>可以通过指定一个后缀标识的操作符，将声明了该后缀标识的字面量转化为需要的类型，这里是一个简单的例子：</p>
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> Watt<span class="token punctuation">{</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> v<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
Watt <span class="token keyword">operator</span> <span class="token string">""</span> <span class="token function">_W</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>v<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token string">""</span> <span class="token function">_W</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	Watt capacity <span class="token operator">=</span> <span class="token number">1024</span>_W<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>C++11中具体规则如下：</p>
<ul>
<li>字面量操作符函数的参数只能接受4种：“unsigned long long”，“long double”，“const char *, size_t”，“char”。</li>
<li>如果字面量为整型数，那么字面量操作符函数只可接受unsigned long long或者<code>const char*</code>为参数。当unsigned long long无法容纳该字面量的时候，编译器会自动将该字面量转化为以\0为结束符的字符串，并调用以<code>const char*</code>为参数的版本进行处理。</li>
<li>如果字面量为浮点型数，则字面量操作符函数只可接受long double或者<code>const char*</code>为参数。<code>const char*</code>版本的规则同整型的一样（过长则使用<code>const char*</code>版本）。</li>
<li>如果字面量为字符串，则字面量操作符函数函数只可接受<code>const char*,size_t</code>为参数。</li>
<li>如果字面量为字符，则字面量操作符函数只可接受一个char为参数。</li>
</ul>
<p>另外还应注意以下几点：</p>
<ul>
<li>在字面量操作符函数的声明中，<code>operator""</code>与用户自定义后缀之间必须有空白。</li>
<li>后缀建议以下划线开始，但其实只要不以数字开头就是合法的，如果不以下划线开始，编译器会提醒“不以下划线开始的字面量操作符后缀保留给将来用”。</li>
</ul>
<p>以上主要参考自《深入了解c++11》3.8节。</p>
<h2><a id="move_250"></a>右值引用和move语义</h2>
<p>如果一个变量有名字，它就是左值，否则，它就是右值。右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。<br>
右值引用就是必须绑定到右值的引用。右值引用只能绑定到一个将要销毁的对象，那么使用右值引用的代码可以自由地接管所引用的对象的资源。<br>
考虑一个右值作为拷贝构造函数或赋值操作符函数的参数时，没有必要复制一份资源，直接将右值的资源转移给新对象多好，反正右值也将要销毁掉。右值引用使得拷贝构造函数和赋值操作符函数能识别出右值来，进行更高效的复制和赋值操作。<br>
参数为右值引用的拷贝构造函数和赋值操作符函数称为move构造函数和move赋值函数，所有的标准库容器和自定义容器都可以通过添加move赋值函数和move构造函数来避免使用临时对象所带来的性能损失。</p>
<p>有时候将一个左值在做为拷贝构造函数的参数被拷贝之后便不再使用，此时是可以直接转移资源所有权的，这里需要把这个左值转换为右值，std::move就用来将一个左值引用或右值引用转换为右值引用。</p>
<pre><code class="prism language-cpp"><span class="token comment">// g++: bits/move.h</span>
  <span class="token comment">/// remove_reference</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">&gt;</span>
    <span class="token keyword">struct</span> remove_reference
    <span class="token punctuation">{</span> <span class="token keyword">typedef</span> _Tp   type<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">&gt;</span>
    <span class="token keyword">struct</span> remove_reference<span class="token operator">&lt;</span>_Tp<span class="token operator">&amp;</span><span class="token operator">&gt;</span>
    <span class="token punctuation">{</span> <span class="token keyword">typedef</span> _Tp   type<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">&gt;</span>
    <span class="token keyword">struct</span> remove_reference<span class="token operator">&lt;</span>_Tp<span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span>
    <span class="token punctuation">{</span> <span class="token keyword">typedef</span> _Tp   type<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">/**
   *  @brief  Convert a value to an rvalue.
   *  @param  __t  A thing of arbitrary type.
   *  @return The parameter cast to an rvalue-reference to allow moving it.
  */</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">&gt;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>remove_reference<span class="token operator">&lt;</span>_Tp<span class="token operator">&gt;</span><span class="token operator">::</span>type<span class="token operator">&amp;&amp;</span>
    <span class="token function">move</span><span class="token punctuation">(</span>_Tp<span class="token operator">&amp;&amp;</span> __t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> std<span class="token operator">::</span>remove_reference<span class="token operator">&lt;</span>_Tp<span class="token operator">&gt;</span><span class="token operator">::</span>type<span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>__t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre>
<p>在参数类型推导上，c++11加入了两个原则，其一是：<br>
引用折叠原则 (reference collapsing rule)，注意，以下条目中的 T 为具体类型，不是推导类型。</p>
<ol>
<li>T&amp; &amp; (引用的引用) 被转化成 T&amp;</li>
<li>T&amp;&amp; &amp; (右值引用的引用）被传化成 T&amp;</li>
<li>T&amp; &amp;&amp; (引用的右值引用) 被转化成 T&amp;</li>
<li>T&amp;&amp; &amp;&amp; 被转化成 T&amp;&amp;</li>
</ol>
<p>另一个特殊的参数类型推导原则是，如果左值引用<code>T &amp;arg</code>做为move（这里以move模板函数为例）的实参，_Tp被推导为T &amp;。根据引用折叠原则，T&amp; &amp;&amp;被转化为T&amp;，所以move被推导为move(T &amp;arg)。返回值<code>typename std::remove_reference&lt;T &amp;&gt;::type&amp;&amp;</code>的类型是T&amp;&amp;，所以就实现了左值引用到右值引用的转换。</p>
<p>std::move在提高swap函数的性能上非常有帮助，有了std::move，swap函数的定义变为：</p>
<pre><code class="prism language-cpp"><span class="token comment">// g++: bits/move.h</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token function">swap</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	T <span class="token function">tmp</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// move a to tmp</span>
	a <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// move b to a</span>
	b <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// move tmp to b</span>
<span class="token punctuation">}</span>
</code></pre>
<p>当然，这得需要class T定义有move构造函数和move赋值函数才会有性能提升。</p>
<h2><a id="perfect_forwarding_302"></a>perfect forwarding</h2>
<p>我们来考虑下面的情景：</p>
<pre><code>void doWork(TYPE&amp;&amp; param) {
	// ops and expressions using std::move(param)
}
</code></pre>
<p>这个代码是从Scott Meyers的演讲当中摘取的。现在的问题是：param是右值吗？不，因为param有名字，所以它是左值。<br>
我们希望在</p>
<pre><code>template &lt;typename T&gt;
void relay(T&amp;&amp; t) {
	foo(t);
}
</code></pre>
<p>中，当实参是左值时，传给foo的是左值，当实参是右值时，传给foo的是右值，perfect forwarding。</p>
<pre><code class="prism language-cpp"><span class="token comment">// g++: bits/move.h</span>
  <span class="token comment">/**
   *  @brief  Forward an lvalue.
   *  @return The parameter cast to the specified type.
   *
   *  This function is used to implement "perfect forwarding".
   */</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">&gt;</span>
    <span class="token keyword">constexpr</span> _Tp<span class="token operator">&amp;&amp;</span>
    <span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">typename</span> std<span class="token operator">::</span>remove_reference<span class="token operator">&lt;</span>_Tp<span class="token operator">&gt;</span><span class="token operator">::</span>type<span class="token operator">&amp;</span> __t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Tp<span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>__t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

  <span class="token comment">/**
   *  @brief  Forward an rvalue.
   *  @return The parameter cast to the specified type.
   *
   *  This function is used to implement "perfect forwarding".
   */</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">&gt;</span>
    <span class="token keyword">constexpr</span> _Tp<span class="token operator">&amp;&amp;</span>
    <span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">typename</span> std<span class="token operator">::</span>remove_reference<span class="token operator">&lt;</span>_Tp<span class="token operator">&gt;</span><span class="token operator">::</span>type<span class="token operator">&amp;&amp;</span> __t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
    <span class="token punctuation">{</span>
      <span class="token keyword">static_assert</span><span class="token punctuation">(</span><span class="token operator">!</span>std<span class="token operator">::</span>is_lvalue_reference<span class="token operator">&lt;</span>_Tp<span class="token operator">&gt;</span><span class="token operator">::</span>value<span class="token punctuation">,</span> <span class="token string">"template argument"</span>
            <span class="token string">" substituting _Tp is an lvalue reference type"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Tp<span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>__t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>不能根据forward的实参推导出_Tp来，所以使用forward是要显式实例化，刚才的那段代码变为：</p>
<pre><code>template &lt;typename _T&gt;
void relay(_T&amp;&amp; t) {
	foo(std::forward&lt;_T&gt;(t));
}
</code></pre>
<p>就能实现perfect forwarding了：</p>
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int &amp; "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int &amp;&amp; "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">66</span><span class="token punctuation">;</span>
    <span class="token function">relay</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">relay</span><span class="token punctuation">(</span><span class="token number">88</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token operator">&amp;</span> <span class="token number">66</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span> <span class="token number">88</span>
</code></pre>
<p>我也没咋理解，瞎推断一下：<br>
relay的实参无论是左值引用还是右值引用，t都是左值引用，<strong>都会命中forward的第一个版本</strong>。（可以自己写一个forward，只保留第一个版本试试）<br>
当relay的实参为左值引用时，同上一节所说，_T被推导为T&amp;，std::forward&lt;T&amp;&gt;(t)，在forward内部T &amp; &amp;&amp;被折叠为T&amp;，t被转换为左值引用。<br>
当relay的实参为右值引用时，_T被推导为T，t被转换为右值引用。</p>
<p>如果将<code>foo(std::forward&lt;_T&gt;(t));</code>改为<code>foo(std::forward&lt;_T&amp;&gt;(t));</code>，当relay的实参为左值引用时，_T被推导为T&amp;，T&amp; &amp;被折叠为T&amp;，同上；当relay的实参为右值引用时，_T被推导为T，仍然是std::forward&lt;T&amp;&gt;(t)，t被转换为<strong>左值</strong>引用。</p>
<p>如果改为<code>foo(std::forward&lt;_T&amp;&amp;&gt;(t));</code>，当relay的实参为左值引用时，_T被推导为T&amp;，T&amp; &amp;&amp;被折叠为T&amp;，同上；当relay的实参为右值引用时，_T被推导为T，std::forward&lt;T&amp;&amp;&gt;(t)，在forward内部，T&amp;&amp; &amp;&amp;被折叠为T&amp;&amp;，t被转换为<strong>右值</strong>引用。</p>
<p>那forward的第二个版本干啥的，可以这样forward：<code>relay(std::forward&lt;int&gt;(88));</code>。再说只forward左值，不forward右值，也不perfect。</p>
<h2><a id="_374"></a>变长参数模板</h2>
<p>看一个典型的变长模版参数的定义：</p>
<pre><code>template &lt;typename ... Args&gt;
void f(Args ... args)
{
cout &lt;&lt; sizeof...(Args);
cout &lt;&lt; sizeof...(args);
}
</code></pre>
<p>这里涉及两个概念：<br>
1, 模板参数包（template parameter pack）：<br>
它指模板参数位置上的变长参数（可以是类型参数，也可以是非类型参数），例如上面的Args。<br>
2, 函数参数包（function parameter pack）：<br>
它指函数参数位置上的变长参数，例如上面的args。<br>
sizeof…(Args)可以用来获知参数包中打包了几个参数。</p>
<p>还有一个解包规则，解包是把参数包展开为它所表示的具体内容的动作，语法是包名加上…，如"Args…, args…"。<br>
参数包的展开不能无条件地在任何地方使用，标准规定可以进行参数包展开的有7种情况：1,表达式；2,初始化列表；3,基类描述列表；4,类成员初始化；5,模板参数列表；6,通用属性列表；7,lambda函数的捕获列表。</p>
<p>由以上概念和规则，与c++已有规则组合，就能演化出极其复杂多样的用法，下面举两个例子。</p>
<p>递归方式展开参数包</p>
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>T head<span class="token punctuation">,</span> Args <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> rest<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	cout <span class="token operator">&lt;&lt;</span> head <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token function">print</span><span class="token punctuation">(</span>rest<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">print</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>表达式方式展开参数包</p>
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	cout <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>Args <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> dummy<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token function">print</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">print</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>参考<br>
<a href="https://blog.csdn.net/yanxiangtianji/article/details/21045525">https://blog.csdn.net/yanxiangtianji/article/details/21045525</a><br>
<a href="https://www.cnblogs.com/qicosmos/p/4325949.html">https://www.cnblogs.com/qicosmos/p/4325949.html</a></p>
<h2><a id="_427"></a>其他</h2>
<p>类的非static成员变量可以在类定义的时候直接初始化。</p>
<p>sizeof运算符可以在类的数据成员上使用，无需明确对象，但该数据成员应是public的。</p>
<pre><code>class A {
public:
	int m = 5;
};
int main() {
	A a;
	cout &lt;&lt; sizeof(A::m) &lt;&lt; sizeof(a.m);
	return 0;
}
</code></pre>
<p>增强的定义别名的能力：</p>
<pre><code>using pf = void(*)();
template &lt;typename First, typename Seconde, typename Third&gt;
class Some
{
	//...
};
template &lt;typename Second&gt;
using Spec = Some&lt;int, Second, int&gt;;
</code></pre>
<p>通过thread_local修饰符声明的变量是线程局部变量。</p>
<p>quick_exit函数功能类似exit函数，它们都会正常结束程序，但quick_exit不会清理资源。类似at_exit函数，同样可以通过at_quick_exit函数注册quick_exit时需要调用的函数。</p>
<p>static_assert<br>
编译时期的断言。</p>
<p>可以try整个函数体，甚至可以包含构造函数初始化列表，这不是c++11的新内容，但我是现在才知道：</p>
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">entry</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> num<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">entry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token operator">:</span><span class="token function">num</span><span class="token punctuation">(</span><span class="token number">36</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
	<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<h2><a id="_476"></a>参考</h2>
<p><a href="https://blog.csdn.net/liuyuan185442111">行者</a><br>
<a href="http://towriting.com/blog/2013/08/01/what-is-cpp11/">C++11系列</a><br>
<a href="https://zh.cppreference.com/">cppreference</a><br>
<a href="https://www.cnblogs.com/qicosmos/p/4283455.html">从4行代码看右值引用</a><br>
<a href="https://www.cnblogs.com/catch/p/3507883.html">c++11 中的 move 与 forward</a><br>
<a href="http://blog.jobbole.com/44015/">C++开发者都应该使用的10个C++11特性</a><br>
<em>深入理解c++11</em></p>
</div>
</body>

</html>
