<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BSS段、数据段、代码段、堆、栈</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><p>BSS段：BSS段（bss segment）通常是指用来存放程序中<strong>未初始化的全局变量</strong>的一块内存区域。BSS是英文<strong>Block Started by Symbol</strong>的简称，程序执行之前BSS段会自动清0。BSS段属于静态内存分配。</p>

<p>数据段：数据段（data segment）通常是指用来存放程序中<strong>已初始化的全局变量</strong>的一块内存区域。数据段属于静态内存分配。</p>

<p>代码段：代码段（code segment/text segment）通常是指用来存放<strong>程序执行代码</strong>的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读，某些架构也允许代码段为可写，即允许修改程序。在代码段中，<strong>也有可能包含一些只读的常数变量</strong>，例如字符串常量等。</p>

<p>堆（heap）：堆是用于存放进程运行中<strong>被动态分配的内存段</strong>，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</p>

<p>栈(stack)：栈又称堆栈， 是用户存放程序<strong>临时创建的局部变量</strong>，也就是说我们函数体中定义的变量（但不包括static声明的变量，<strong>static局部变量在数据段中存放</strong>）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</p>

<p>BSS段的存在可以减少可执行程序的大小，看下面的例子。</p>

<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//a.c</span>
<span class="hljs-keyword">int</span> ar[<span class="hljs-number">800000</span>];
<span class="hljs-keyword">void</span> main()
{
}

<span class="hljs-comment">// b.c</span>
<span class="hljs-keyword">int</span> ar[<span class="hljs-number">800000</span>] =  {<span class="hljs-number">1</span>};
<span class="hljs-keyword">void</span> main()
{
}

<span class="hljs-comment">// c.c</span>
<span class="hljs-keyword">int</span> ar[<span class="hljs-number">800000</span>] =  {<span class="hljs-number">0</span>};
<span class="hljs-keyword">void</span> main()
{
}</code></pre>

<p><img src="http://img.blog.csdn.net/20150923130813392" alt="abc的大小" title=""> <br>
a和c编译后所得的可执行程序比b的要大得多，这里就是BSS段在发挥作用。 <br>
全局的未初始化变量存在于.bss段中，具体体现为一个占位符；全局的已初始化变量存于.data段中；而函数内的自动变量都在栈上分配空间。 <br>
.bss是不占用可执行文件空间的，其内容由操作系统初始化（清零）；而.data却需要占用，其内容由程序初始化，因此造成了上述情况。</p>

<p>每个变量的大小放在了符号表里。 <br>
bss段的大小，记录在段表里，记录的是所有未初始化变量总共的大小。</p>

<p>用readelf -s 或 objdump -t 查看符号表 <br>
用readelf -S 或 objdump -h 查看段表</p>

<p>多文件编译里，未初始化的全局变量<code>int init;</code>，在c里默认是有extern属性的，编译时候是不放到bss里的，链接时如果发现其他obj里都没有这个变量，才把它放到bss里。（参考[3]）</p>

<p>部分gcc命令选项（参考[4]）： <br>
预处理（-E）、编译(-S)、汇编(-c)、链接(默认) <br>
-o指定输出文件 <br>
-Wall，显示warning消息 <br>
编译阶段，gcc首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作，在检查无误后，gcc把代码翻译成汇编语言。 <br>
汇编阶段是把编译阶段生成的“.s”文件转成二进制目标代码。（参考[5]）</p>

<p>参考 <br>
[1] <a href="http://www.cppblog.com/prayer/archive/2009/08/17/93594.html">BSS段、数据段、代码段、堆与栈</a> <br>
[2] <a href="http://bbs.csdn.net/topics/390613528"> 面试官问我：bss段的大小记录在哪里？</a> <br>
[3] <a href="http://blog.chinaunix.net/uid-23629988-id-2888209.html">通过未初始化全局变量，研究BSS段和COMMON段的不同</a> <br>
[4] <a href="http://www.cnblogs.com/ggjucheng/archive/2011/12/14/2287738.html">Linux GCC常用命令</a> <br>
[5] <a href="http://blog.csdn.net/eastonwoo/article/details/8655243">gcc 编译的四大过程（预处理-编译-汇编-链接 ）</a></p></div></body>
</html>