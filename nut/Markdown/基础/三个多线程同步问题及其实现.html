<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>三个多线程同步问题及其实现</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><h2 id="1生产者消费者问题">1.生产者——消费者问题</h2>

<p>问题描述： <br>
生产者-消费者问题是一个经典的进程同步问题，该问题最早由Dijkstra提出，用以演示他提出的信号量机制。在同一个进程地址空间内执行的两个线程。生产者线程生产物品，然后将物品放置在一个空缓冲区中供消费者线程消费。消费者线程从缓冲区中获得物品，然后释放缓冲区。当生产者线程生产物品时，如果没有空缓冲区可用，那么生产者线程必须等待消费者线程释放出一个空缓冲区。当消费者线程消费物品时，如果没有满的缓冲区，那么消费者线程将被阻塞，直到新的物品被生产出来。 <br>
这里生产者和消费者是既同步又互斥的关系，首先只有生产者生产了，消费着才能消费，这里是同步的关系。但他们对于临界区的访问又是互斥的关系。因此需要两个信号量empty和full用于同步缓冲区，而互斥量mutex用于保证在访问缓冲区时是互斥的。 <br>
P操作首先减少信号量，表示有一个进程将占用或等待资源，然后检测S是否小于0，如果小于0则阻塞，否则占有资源进行执行。 <br>
V操作是和P操作相反的操作，首先增加信号量，表示占用或等待资源的进程减少了1个。然后检测S是否大于0，如果大于0则唤醒等待使用S资源的其它进程。</p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;pthread.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;semaphore.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;windows.h&gt;</span>

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
sem_t emptys;
sem_t resource;
<span class="hljs-keyword">int</span> cur_nums=<span class="hljs-number">0</span>;

<span class="hljs-keyword">void</span>* Producer(<span class="hljs-keyword">void</span>*)
{
begin:
    sem_wait(&amp;emptys);
    pthread_mutex_lock(&amp;mutex);
    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"producing..."</span>);
    Sleep(rand()%<span class="hljs-number">20</span>);
    ++cur_nums;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"there are %d available resources now.\n"</span>, cur_nums);
    pthread_mutex_unlock(&amp;mutex);
    sem_post(&amp;resource); <span class="hljs-comment">//将resource加1</span>
    Sleep(rand()%<span class="hljs-number">1000</span>);
    <span class="hljs-keyword">goto</span> begin;
}
<span class="hljs-keyword">void</span>* Customer(<span class="hljs-keyword">void</span>*)
{
begin:
    sem_wait(&amp;resource); <span class="hljs-comment">//将resource减一,如果小于0则等待</span>
    pthread_mutex_lock(&amp;mutex);
    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"customing......"</span>);
    Sleep(rand()%<span class="hljs-number">20</span>);
    --cur_nums;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"there are %d available resources now.\n"</span>, cur_nums);
    pthread_mutex_unlock(&amp;mutex);
    sem_post(&amp;emptys);
    Sleep(rand()%<span class="hljs-number">1000</span>+<span class="hljs-number">100</span>);
    <span class="hljs-keyword">goto</span> begin;
}

<span class="hljs-keyword">int</span> main()
{
    sem_init(&amp;emptys,<span class="hljs-number">0</span>,<span class="hljs-number">15</span>); <span class="hljs-comment">// 表示剩余空位数, 初值为15</span>
    sem_init(&amp;resource,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>); <span class="hljs-comment">// 表示已有资源数, 初值为0</span>
    pthread_t t1,t2;
    pthread_create(&amp;t1,NULL,Producer,NULL);
    pthread_create(&amp;t2,NULL,Customer,NULL);
    pthread_detach(t1);
    pthread_join(t2,NULL);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p>由于Customer进入Sleep的时间比Producer长，资源数量会趋向于变大。</p>



<h2 id="2读者写者问题">2.读者——写者问题</h2>

<p>问题描述: <br>
 一个数据文件或记录，统称数据对象，可被多个进程共享，其中有些进程只要求读称为“读者”，而另一些进程要求写或修改称为“写者”。 <br>
规定：允许多个读者同时读一个共享对象，但禁止读者、写者同时访问一个共享对象，也禁止多个写者访问一个共享对象，否则将违反Bernstein条件。 <br>
Bernstein条件：若两个程序P1和P2能满足下述条件，它们便能并发执行，否则不能： R(P1)∩W(P2)∪R(P2)∩W(P1)∪W(P1)∩W(P2)={}，P1的读集与P2写集的交集、P2的读集与P1的写集的交集、P1的写集与P2的写集的交集，三者同时为空集。 <br>
通过描述可以分析，这里的读者和写者是互斥的，而写者和写者也是互斥的，但读者之间并不互斥。 <br>
由此我们可以设置3个变量，一个用来统计读者的数量，另外两个分别用于对读者数量读写的互斥，写者和读者、其他写者的互斥。</p>

<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;pthread.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;semaphore.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;windows.h&gt;</span>

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t rw = PTHREAD_MUTEX_INITIALIZER;
<span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;

<span class="hljs-keyword">void</span>* reader(<span class="hljs-keyword">void</span> *)
{
    pthread_mutex_lock(&amp;mutex);
    <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>) <span class="hljs-comment">// 0个读者</span>
        pthread_mutex_lock(&amp;rw); <span class="hljs-comment">// 等待写者退出</span>
    ++count;
    pthread_mutex_unlock(&amp;mutex);
    Sleep(<span class="hljs-number">1000</span>);
    puts(<span class="hljs-string">"stop reading."</span>);
    pthread_mutex_lock(&amp;mutex);
    --count;
    pthread_mutex_unlock(&amp;mutex);
    <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>)
        pthread_mutex_unlock(&amp;rw);
}

<span class="hljs-keyword">void</span>* writer(<span class="hljs-keyword">void</span>*)
{
    pthread_mutex_lock(&amp;rw);
    Sleep(<span class="hljs-number">2000</span>);
    puts(<span class="hljs-string">"stop writing."</span>);
    pthread_mutex_unlock(&amp;rw);
}

<span class="hljs-keyword">int</span> main()
{
    pthread_t t[<span class="hljs-number">6</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)
        pthread_create(&amp;t[i],<span class="hljs-literal">NULL</span>,reader,<span class="hljs-literal">NULL</span>);
    pthread_t tt;
    pthread_create(&amp;tt,<span class="hljs-literal">NULL</span>,writer,<span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt; <span class="hljs-number">6</span>; i++)
        pthread_create(&amp;t[i],<span class="hljs-literal">NULL</span>,reader,<span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++)
        pthread_join(t[i],<span class="hljs-literal">NULL</span>);
    pthread_join(tt,<span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p>输出是 <br>
stop reading. <br>
stop reading. <br>
stop reading. <br>
stop reading. <br>
stop reading. <br>
stop reading. <br>
stop writing. <br>
因为前三个读者读的过程中，写无法进行，只好等到所有读都完成后才能写。</p>



<h2 id="3哲学家进餐问题">3.哲学家进餐问题</h2>

<p>问题描述: <br>
有五个哲学家，他们的生活方式是交替地进行思考和进餐。哲学家们公用一张圆桌，周围放有五把椅子，每人坐一把。在圆桌上有五个碗和五根筷子，当一个哲学家思考时，他不与其他人交谈，饥饿时便试图取用其左、右最靠近他的筷子，但他可能一根都拿不到。只有在他拿到两根筷子时，方能进餐，进餐完后，放下筷子又继续思考。 <br>
根据问题描述，五个哲学家分别可以看作是五个进程，五只筷子分别看作是五个资源，只有当哲学家分别拥有左右的资源时，才得以进餐。如果不指定规则，当每个哲学家手中只拿了一只筷子时会造成死锁，从而五个哲学家都因为吃不到饭而饿死。因此我们的策略是让哲学家同时拿起两只筷子，需要对每个资源设置一个互斥量。</p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;pthread.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;semaphore.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;windows.h&gt;</span>

<span class="hljs-preprocessor">#define PHILOSOPHER 5</span>
pthread_mutex_t mutex[PHILOSOPHER];
<span class="hljs-comment">// x号哲学家需要x和(x+1)%PHILOSOPHER号筷子</span>

<span class="hljs-keyword">void</span>* philosopher(<span class="hljs-keyword">void</span>* pnum)
{
    <span class="hljs-keyword">int</span> num = *(<span class="hljs-keyword">int</span>*)pnum;
begin:
    <span class="hljs-keyword">if</span>(pthread_mutex_trylock(mutex+num)==<span class="hljs-number">0</span>)
    {
        <span class="hljs-keyword">if</span>(pthread_mutex_trylock(mutex+(num+<span class="hljs-number">1</span>)%PHILOSOPHER)!=<span class="hljs-number">0</span>)
        {
            pthread_mutex_unlock(mutex+num);
            <span class="hljs-keyword">goto</span> begin;
        }
        <span class="hljs-comment">// 获得两只筷子</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"philosopher %d start eating.\n"</span>, num);
        Sleep(<span class="hljs-number">100</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"philosopher %d stop eating.\n"</span>, num);
        pthread_mutex_unlock(mutex+num);
        pthread_mutex_unlock(mutex+(num+<span class="hljs-number">1</span>)%PHILOSOPHER);
        Sleep(rand()%<span class="hljs-number">1000</span>+<span class="hljs-number">2000</span>); <span class="hljs-comment">// 思考2到3秒</span>
    }
    <span class="hljs-keyword">goto</span> begin;
}

<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">int</span> num[PHILOSOPHER];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;PHILOSOPHER; ++i)
    {
        mutex[i] = PTHREAD_MUTEX_INITIALIZER;
        num[i] = i;
    }
    pthread_t t[PHILOSOPHER];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;PHILOSOPHER; ++i)
        pthread_create(&amp;t[i],NULL,philosopher,&amp;num[i]);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;PHILOSOPHER; ++i)
        pthread_join(t[i],NULL);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p>以上代码均在Windows下CodeBlocks 16.01编译通过 <br>
参考<a href="http://www.cnblogs.com/CareySon/archive/2012/04/14/Process-SynAndmutex.html">浅谈进程同步和互斥的概念</a></p></div></body>
</html>