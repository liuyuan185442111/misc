BSS段：BSS段（bss segment）通常是指用来存放程序中**未初始化的全局变量**的一块内存区域。BSS是英文**Block Started by Symbol**的简称，程序执行之前BSS段会自动清0。BSS段属于静态内存分配。

数据段：数据段（data segment）通常是指用来存放程序中**已初始化的全局变量**的一块内存区域。数据段属于静态内存分配。

代码段：代码段（code segment/text segment）通常是指用来存放**程序执行代码**的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读，某些架构也允许代码段为可写，即允许修改程序。在代码段中，**也有可能包含一些只读的常数变量**，例如字符串常量等。

堆（heap）：堆是用于存放进程运行中**被动态分配的内存段**，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。

栈(stack)：栈又称堆栈， 是用户存放程序**临时创建的局部变量**，也就是说我们函数体中定义的变量（但不包括static声明的变量，**static局部变量在数据段中存放**）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。

BSS段的存在可以减少可执行程序的大小，看下面的例子。
```
//a.c
int ar[800000];
void main()
{
}

// b.c
int ar[800000] =  {1};
void main()
{
}

// c.c
int ar[800000] =  {0};
void main()
{
}
```
![abc的大小](http://img.blog.csdn.net/20150923130813392)
a和c编译后所得的可执行程序比b的要大得多，这里就是BSS段在发挥作用。
全局的未初始化变量存在于.bss段中，具体体现为一个占位符；全局的已初始化变量存于.data段中；而函数内的自动变量都在栈上分配空间。
.bss是不占用可执行文件空间的，其内容由操作系统初始化（清零）；而.data却需要占用，其内容由程序初始化，因此造成了上述情况。

每个变量的大小放在了符号表里。
bss段的大小，记录在段表里，记录的是所有未初始化变量总共的大小。

用readelf -s 或 objdump -t 查看符号表
用readelf -S 或 objdump -h 查看段表

多文件编译里，未初始化的全局变量`int init;`，在c里默认是有extern属性的，编译时候是不放到bss里的，链接时如果发现其他obj里都没有这个变量，才把它放到bss里。（参考[3]）

部分gcc命令选项（参考[4]）：
预处理（-E）、编译(-S)、汇编(-c)、链接(默认)
-o指定输出文件
-Wall，显示warning消息
编译阶段，gcc首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作，在检查无误后，gcc把代码翻译成汇编语言。
汇编阶段是把编译阶段生成的“.s”文件转成二进制目标代码。（参考[5]）

参考
[1] [BSS段、数据段、代码段、堆与栈](http://www.cppblog.com/prayer/archive/2009/08/17/93594.html)
[2] [ 面试官问我：bss段的大小记录在哪里？](http://bbs.csdn.net/topics/390613528)
[3] [通过未初始化全局变量，研究BSS段和COMMON段的不同](http://blog.chinaunix.net/uid-23629988-id-2888209.html)
[4] [Linux GCC常用命令](http://www.cnblogs.com/ggjucheng/archive/2011/12/14/2287738.html)
[5] [gcc 编译的四大过程（预处理-编译-汇编-链接 ）](http://blog.csdn.net/eastonwoo/article/details/8655243)