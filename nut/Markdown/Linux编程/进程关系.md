###进程组
进程组是一个或多个进程的集合，通常与作业相关联，每个进程组有一个唯一的进程组ID。
每个进程组都可以有一个组长进程，组长的pid等于进程组ID。组长进程可以提前终止，进程组中最后一个进程终止或转移到另一个进程组时，该进程组消失。
进程可以通过调用getpgrp或getpgid获得该进程的进程组ID。
进程可以通过调用setpgid加入一个现有的组或创建一个新进程组。
一个进程只能为它自己或它的子进程设置进程组ID，而且在它的子进程调用了exec函数之一后，它就不能再改变该子进程的进程组ID了。
###会话
会话是一个或多个进程组的集合。
进程调用setsid函数建立一个新会话。如果该进程已经是一个进程组的组长，此函数返回出错。如果该进程不是一个进程组的组长，此函数会创建一个新会话，该进程变成会话首进程，该进程成为一个新进程组的组长。该进程没有控制终端，如果在调用setsid之前该进程有一个控制终端，这种联系也会被切断（后面的例子也说明了这种情况，没有控制终端的进程无法打开/dev/tty）。
用户登录系统时会创建一个会话，通常将自动建立控制终端，shell进程是该会话的会话首进程。
如果一个会话有一个控制终端，则它有一个前台进程组，另外的是后台进程组。终端的中断信号SIGINT（Ctrl+C）、挂起信号SIGTSTP（Ctrl+Z）发送给前台进程组。
###函数说明
```
#include <unistd.h>
pid_t getpgrp(void);
返回调用进程的进程组ID
pid_t getpgid(pid_t pid);
若成功则返回进程组ID，若出错则返回-1
若pid为0，则返回调用进程的进程组ID
int setpgid(pid_t pid, pid_t gpid);
将pid进程的进程组ID设置为gpid
若成功则返回0，若出错则返回-1
If setpgid() is used move a process from one process group to another,
both process groups must be part of the same session.
如果这两个参数相等，则由pid指定的进程变成进程组组长
如果pid是0，则使用调用者的进程ID
如果pgid是0，则由pid指定的进程ID将用作进程组ID
pid_t setsid(void);
若成功则返回进程组ID，若出错则返回-1
pid_t getsid(pid_t pid);
若成功则返回会话首进程的进程组ID（也就是首进程的pid），若出错则返回-1
若pid是0，返回调用进程的会话首进程的进程组ID
pid_t tcgetpgrp(int fd);
int tcsetpgrp(int fd, pid_t pgrp);
get and set terminal foreground process group
tcsetpgrp将pgrp指定的进程组成为与fd相关联的终端的前台进程组
这两个函数通常由shell调用
```
进程创建子进程后，二者归属于同一进程组，子进程可以调用setpgid()设置子进程的进程组ID。比如在shell中执行命令时，shell先fork，然后在父子进程中分别调用setpgid()使子进程创建一个新的进程组。
###孤儿进程组
如果一个进程组中的每个成员的父进程都不属于会话的其他进程组，那么该组中的进程一旦停止，因为父进程不在同会话中，就没办法被同会话中的进程重新启动了。
在父进程终止后，进程组成为孤儿进程组。父进程转移进程组不会使进程组成为孤儿进程组，因为不能跨会话转移进程组。
新的孤儿进程组中处于停止状态（Ctrl+Z）的每一个进程会收到挂断信号SIGHUP，接着会收到继续信号SIGCONT。对挂断信号系统默认动作是终止该进程。
###终端关闭
如果终端接口检测到一个连接断开，则将SIGHUP信号发送给与该终端相关的控制进程（会话首进程）。接到此信号的会话首进程可能在后台。如果会话首进程终止，也会产生SIGHUP信号，此信号将被放送给前台进程组中的每一个进程。（摘自APUE 10.2节对SIGHUP的描述）
百度百科上SIGHUP词条的描述明显与之不符，应是百度百科错误。
我来整理一下思路：
连接断开时，会话首进程会收到SIGHUP，如果会话首进程终止，前台进程组也会收到SIGHUP，后台进程组则不会收到SIGHUP。所以用&符号提交的作业在终端关闭时可以继续运行，但由于其父进程，也就是会话首进程终止，它们被过继给init进程。
而通过Ctrl+Z被停止的后台进程组，由于父进程，也就是会话首进程的终止，变成了孤儿进程组，依照上文所说，它们也会收到SIGHUP。
设想这样一种情况：用&符号提交的作业，创建了一个子进程，并且给子进程发送了一个SIGSTP信号，然后关闭终端会发生什么？根据上面的分析，后台运行中的进程会被过继给init继续运行，其子进程所在进程组就不会变成孤儿进程组，也不会终止。下面是该情况的代码实现：
```
#include <unistd.h>
#include <signal.h>

int main()
{
    pid_t pid = fork();
    if(pid < 0) return -1;
    if(pid == 0)
    {
        setpgid(0,0);
        sleep(600);
        return 0;
    }
    sleep(5);
    kill(pid, SIGSTOP);
    sleep(600);
    return 0;
}
```
[root@centos ~]# ps -o pid,ppid,pgid,sid,comm
  PID  PPID  PGID   SID COMMAND
23440 23436 23440 23440 bash
23519 23440 23519 23440 a.out
23520 23519 23520 23440 a.out
23537 23440 23537 23440 ps
[root@centos ~]# ps -e -o pid,ppid,pgid,sid,comm | grep a.out
23519     1 23519 23440 a.out
23520 23519 23520 23440 a.out
结果和分析的一样，而且终端关了，会话首进程没了，但是会话还在！会话首进程终止时，第一个a.out的进程组成了孤儿进程组，但是人家在运行状态，所以不会收到SIGHUP，第二个a.out的父进程还在，所以不是孤儿进程组，也不会收到SIGHUP。
###如何让进程脱离终端在后台运行？
1 使进程忽略SIGHUP信号
nohup命令让提交的命令忽略SIGHUP信号，因为子进程的信号屏蔽字和父进程是一样的，nohup被执行后先屏蔽SIGHUP信号，然后exec成提交的命令。
2 使进程创建一个新session
setsid命令可以run a program in a new session。
`setsid ping 127.0.0.1`后`ps –utest o pid,ppid,pgid,sid,tpgid,comm`发现ping命令的ppid变成了1，而后面的例子中当前终端没有关闭/父进程没有返回/Ctrl+C的时候，子进程的ppid并不是1，所以setsid命令的操作可能是：setsid命令先fork一个子进程，然后在子进程中调用setssid()，再exec成最终要执行的命令，这样父进程终止的时候，子进程就被过继给了init。
3 (cmd&)
括号中的命令将会新开一个子shell顺序执行，括号中多个命令之间用分号隔开，最后一个命令可以没有分号，各命令和括号之间不必有空格。
子shell在命令扔后台之后终止，命令被过继给init。
###一个例子 习题9.2
```
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>

int main()
{
    pid_t pid;
    if((pid=fork())<0)
    {
        puts("error");
        return -1;
    }
    if(pid>0)
    {
        printf("parent pid=%d pgid=%d\n",getpid(),getpgid(0));
        printf("parent open tty=%d\n",open("/dev/tty", O_RDONLY));
        sleep(300);
    }
    else
    {
        setsid();
        printf("child pid=%d pgid=%d\n",getpid(),getpgid(0));
        printf("child open tty=%d\n",open("/dev/tty", O_RDONLY));
        sleep(600);
    }
    return 0;
}
```
###参考
APUE 第9章 进程关系
[让Linux进程脱离终端在后台运行](https://blog.csdn.net/iw1210/article/details/58709889)
man文档
APUE 10.2 信号概念