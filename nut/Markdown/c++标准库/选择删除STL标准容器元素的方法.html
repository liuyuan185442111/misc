<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>选择删除STL标准容器元素的方法</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><ul>
<li><p>删除容器中有特定值的所有元素： <br>
如果容器是vector、string、deque，则使用erase-remove用法 <br>
如果容器是list，则使用list::remove <br>
如果容器是一个标准关联容器，则使用它的erase成员函数</p></li>
<li><p>删除容器中满足特定条件的所有元素： <br>
如果容器是vector、string、deque，则使用erase-remove_if用法 <br>
如果容器是list，则使用list::remove_if <br>
如果容器是一个标准关联容器，写一个循环来遍历容器中的元素，在循环中使用erase方法删除元素，当把迭代器传给erase时，要对它进行后缀递增</p></li>
<li><p>如果要在循环内部做些操作，只能手写一个循环了。标准关联容器本来就需要一个循环；而对于vector、string、deque，每次调用erase时，要返回它的返回值以更新迭代；对于list，两种方式都可以。</p></li>
</ul>

<p><a href="http://blog.csdn.net/liuyuan185442111/article/details/46573515#t12" target="_blank">remove系列函数</a>，they cannot alter the size of an array or a container，所以需要使用erase来删掉后面无用的元素。</p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">//ex 1</span>
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> c;
c.erase(remove(c.begin(), c.end(), <span class="hljs-number">2017</span>), c.end();

<span class="hljs-comment">//ex 2</span>
<span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> c;
c.erase(<span class="hljs-number">2017</span>);

<span class="hljs-comment">//ex 3</span>
<span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> c;
c.remove(<span class="hljs-number">2017</span>);

<span class="hljs-comment">//ex 4</span>
<span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> c;
<span class="hljs-keyword">for</span>(<span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>::iterator iter = c.begin(); iter != c.end(); ) 
{
    <span class="hljs-comment">//erase(iter++):先创建一个临时变量,用iter的值初始化,然后iter自加,然后将临时变量传递给erase函数</span>
    <span class="hljs-keyword">if</span>(predict(*iter)) c.erase(iter++);
    <span class="hljs-keyword">else</span> ++iter;
}

<span class="hljs-comment">//ex 5</span>
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> c;
<span class="hljs-keyword">for</span>(<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>::iterator iter = c.begin(); iter != c.end(); )
{
    <span class="hljs-keyword">if</span>(predict(*iter)) iter = c.erase(iter);
    <span class="hljs-keyword">else</span> ++iter;
}</code></pre>

<p>iterator vector::erase (iterator pos); <br>
返回被删除序列之后的元素的位置，被删除位置及之后的原有迭代器将失效。 <br>
Invalidate iterators and references at or after the point of the erase, including the end() iterator.</p>

<p>void map::erase (iterator position); <br>
当容器中一个元素被删除时，指向该元素的所有迭代器都将失效。 <br>
References and iterators to the erased elements are invalidated. Other references and iterators are not affected.</p>

<p>reference： <br>
effective STL item 9 <br>
<a href="http://en.cppreference.com">cppreference</a> <br>
<img src="http://img.blog.csdn.net/20170322210331182?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1eXVhbjE4NTQ0MjExMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="vector" title=""> <br>
<img src="http://img.blog.csdn.net/20170322210344688?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1eXVhbjE4NTQ0MjExMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="map" title=""></p></div></body>
</html>