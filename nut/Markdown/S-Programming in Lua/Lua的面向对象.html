<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Lua的面向对象</title>
<link rel="stylesheet" href="https://csdn.net/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "all"},extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"] } });
</script>
</head>
<body><div class="container"><h2 id="table元素访问和更新三大法则">table元素访问和更新三大法则</h2>

<p>__index元方法用来对表访问，__newindex元方法用来对表更新 。</p>

<p>当通过键来访问table的时候，如果这个键没有值，那么Lua就会寻找该table的metatable（如果有metatable）中的__index键。如果__index指向一个表格，Lua会在表格中查找相应的键，如果__index指向一个函数，Lua会将以table和key作为参数调用该函数，并返回该函数的返回值。</p>

<p><strong>第一法则：访问表元素时的规则：</strong> <br>
1.在表中查找，如果找到，返回该元素，找不到则继续 <br>
2.判断该表是否有元表，如果没有元表，返回nil，有元表则继续 <br>
3.判断元表有没有__index键，如果__index为nil，则返回nil；如果__index指向一个表，则重复1、2、3；如果__index指向一个函数，调用该函数并返回该函数的返回值</p>

<p><strong>第二法则：更新表元素的规则：</strong> <br>
1.如果table有该元素，直接为该元素更新值； <br>
2.如果table无该元素，且table的元表为nil或元表不为nil但元表的__newindex为nil，则直接为table添加元素； <br>
3.如果table无该元素，且存在元表，元表的__newindex不为nil，则通过__newindex来操作，具体是：如果__newindex指向一个表，重复上述步骤；如果__newindex指向一个函数，以table，key，value作为参数调用该函数。</p>

<p><strong>第三法则：语法糖“:”</strong></p>

<pre class="prettyprint"><code class=" hljs actionscript">-- 定义函数时，相当于把:换成.并将self作为第一个形参；
-- 调用函数时，相当于把:换成.并将调用函数的table作为第一个实参。
t={}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">t</span><span class="hljs-type">:f</span><span class="hljs-params">()</span>
    <span class="hljs-title">print</span><span class="hljs-params">(self)</span>
<span class="hljs-title">end</span>
<span class="hljs-title">t</span><span class="hljs-type">:f</span><span class="hljs-params">()</span></span></code></pre>

<h2 id="基于对象">基于对象</h2>

<p>一个简单实例：</p>



<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-constant">Rectangle</span> = {area = <span class="hljs-number">0</span>, length = <span class="hljs-number">0</span>, breadth = <span class="hljs-number">0</span>}

function <span class="hljs-constant">Rectangle</span><span class="hljs-symbol">:new</span> (o,length,breadth)
    local o = o <span class="hljs-keyword">or</span> {}
    setmetatable(o, <span class="hljs-keyword">self</span>)
    <span class="hljs-keyword">self</span>.__index = <span class="hljs-keyword">self</span>
    <span class="hljs-keyword">self</span>.length = length <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">self</span>.breadth = breadth <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">self</span>.area = <span class="hljs-keyword">self</span>.length*<span class="hljs-keyword">self</span>.breadth
    <span class="hljs-keyword">return</span> o
<span class="hljs-keyword">end</span>

function <span class="hljs-constant">Rectangle</span><span class="hljs-symbol">:printArea</span> ()
    print(<span class="hljs-string">"矩形面积为"</span>, <span class="hljs-keyword">self</span>.area)
<span class="hljs-keyword">end</span>

myshape = <span class="hljs-constant">Rectangle</span><span class="hljs-symbol">:new</span>(<span class="hljs-keyword">nil</span>,<span class="hljs-number">2</span>,<span class="hljs-number">10</span>)
<span class="hljs-symbol">myshape:</span>printArea()</code></pre>

<p>在myshape.printArea(myshape)中： <br>
因为myshape里边没有printArea，去找元表Rectangle的__index，__index指向Rectangle，Rectangle里有printArea，所以就去调用Rectangle的printArea。在Rectangle的printArea里打印myshape.area，myshape里没有area，又去Rectangle的__index里找，找到并打印了出来。</p>

<p>但是在这里，数据不是保存在“new”出来的实例中的，而是保存在Rectangle中，这就像c++里类的静态成员变量和静态成员函数。比如这样用：</p>

<pre><code>myshape1 = Rectangle:new(nil,2,5)
myshape2 = Rectangle:new(nil,4,10)
myshape1:printArea()
myshape2:printArea()
</code></pre>

<p>打印出来的都是40。</p>

<p>我们换一种<strong>更好的方式</strong>：</p>

<pre class="prettyprint"><code class=" hljs livecodeserver">Rectangle = {}
Rectangle.__index = Rectangle

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rectangle</span>.<span class="hljs-title">new</span> (<span class="hljs-title">length</span>,<span class="hljs-title">breadth</span>)</span>
    <span class="hljs-built_in">local</span> o = {}
    setmetatable(o, Rectangle)
    o.<span class="hljs-built_in">length</span> = <span class="hljs-built_in">length</span> <span class="hljs-operator">or</span> <span class="hljs-number">0</span>
    o.breadth = breadth <span class="hljs-operator">or</span> <span class="hljs-number">0</span>
    o.area = o.<span class="hljs-built_in">length</span>*o.breadth
    <span class="hljs-constant">return</span> o
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rectangle</span>:<span class="hljs-title">printArea</span> ()</span>
    print(<span class="hljs-string">"矩形面积为"</span>, self.area)
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

myshape1 = Rectangle.<span class="hljs-built_in">new</span>(<span class="hljs-number">2</span>,<span class="hljs-number">10</span>)
myshape2 = Rectangle.<span class="hljs-built_in">new</span>(<span class="hljs-number">4</span>,<span class="hljs-number">10</span>)
myshape1:printArea()
myshape2:printArea()</code></pre>

<h2 id="面向对象">面向对象</h2>

<p>通过__index实现继承的例子如下：</p>



<pre class="prettyprint"><code class=" hljs lua">Rectangle = {}
Rectangle.__index = Rectangle

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rectangle.new</span><span class="hljs-params">(length, breadth)</span></span>
    <span class="hljs-keyword">local</span> o = {}
    o.length = length <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>
    o.breadth = breadth <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>
    <span class="hljs-built_in">setmetatable</span>(o, Rectangle)
    <span class="hljs-keyword">return</span> o
<span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rectangle:getArea</span><span class="hljs-params">()</span></span>
    <span class="hljs-keyword">return</span> self.length * self.breadth
<span class="hljs-keyword">end</span>

Cube = {}
<span class="hljs-built_in">setmetatable</span>(Cube, Rectangle)
Cube.__index = Cube

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cube.new</span><span class="hljs-params">(length, breadth, height)</span></span>
    <span class="hljs-keyword">local</span> o = Rectangle.new(length, breadth)
    o.height = height <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>
    <span class="hljs-built_in">setmetatable</span>(o, Cube)
    <span class="hljs-keyword">return</span> o
<span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cube:getVolume</span><span class="hljs-params">()</span></span>
    <span class="hljs-keyword">return</span> self.height * self:getArea()
<span class="hljs-keyword">end</span>

r1 = Rectangle.new(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
r2 = Rectangle.new(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"r1的长是"</span>, r1.length, <span class="hljs-string">"宽是"</span>, r1.breadth)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"r1的面积是"</span>, r1:getArea())
<span class="hljs-built_in">print</span>(<span class="hljs-string">"r2的面积是"</span>, r2:getArea())

c1 = Cube.new(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)
c2 = Cube.new(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"c1的面积是"</span>, c1:getArea())
<span class="hljs-built_in">print</span>(<span class="hljs-string">"c1的体积是"</span>, c1:getVolume())
<span class="hljs-built_in">print</span>(<span class="hljs-string">"c2的面积是"</span>, c2:getArea())
<span class="hljs-built_in">print</span>(<span class="hljs-string">"c2的体积是"</span>, c2:getVolume())

<span class="hljs-comment">--[[输出是:
r1的长是        2       宽是    3
r1的面积是      6
r2的面积是      12
c1的面积是      20
c1的体积是      120
c2的面积是      12
c2的体积是      60
]]</span><span class="hljs-comment">--</span></code></pre>

<p>关键在于<code>setmetatable(Cube, Rectangle)和setmetatable(o, Cube)</code>，在c1中查找getVolume时，会在c1的元表Cube的__index指向的Cube中查找，正好找得到；在c1中查找getArea时，却找不到，于是去Cube的元表Rectangle的__index指向的Rectangle中查找，就找到了。</p>



<h2 id="summary">summary</h2>

<p>虽然Lua也可以模拟实现封装、抽象、派生，但也有点太麻烦了，特意的OO可能反而得不偿失，要充分利用Lua本身的机制，灵活应用，再说OO应该交给宿主语言C++去做。</p></div></body>
</html>