<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>lua test</title>
<link rel="stylesheet" href="https://csdn.net/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "all"},extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"] } });
</script>
</head>
<body><div class="container"><p>lua-5.1.4.tar.gz里test目录下有一些测试用例，我看了一遍，令人印象深刻的地方有： <br>
string库的模式匹配，简化的正则，够用不复杂。 <br>
协程和闭包，有时可简化编程，但有时也不好理解。 <br>
table的__index和__newindex，可用来模拟面向对象，规则虽然简单，但用好真不那么容易。</p>



<h2 id="部分摘选">部分摘选：</h2>



<h3 id="斐波那契fibonacci数列">斐波那契(fibonacci)数列</h3>

<p>fibfor.lua <br>
这是正着算的</p>



<pre class="prettyprint"><code class=" hljs livecodeserver"><span class="hljs-comment">-- example of for with generator functions</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generatefib</span> (<span class="hljs-title">n</span>)</span>
  <span class="hljs-constant">return</span> coroutine.<span class="hljs-operator">wrap</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> ()</span>
    <span class="hljs-built_in">local</span> <span class="hljs-operator">a</span>,b = <span class="hljs-number">1</span>, <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> <span class="hljs-operator">a</span> &lt;= n <span class="hljs-built_in">do</span>
      coroutine.yield(<span class="hljs-operator">a</span>)
      <span class="hljs-operator">a</span>, b = b, <span class="hljs-operator">a</span>+b
    <span class="hljs-function"><span class="hljs-keyword">end</span></span>
  <span class="hljs-function"><span class="hljs-keyword">end</span>)</span>
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

<span class="hljs-keyword">for</span> i <span class="hljs-operator">in</span> generatefib(<span class="hljs-number">1000</span>) <span class="hljs-built_in">do</span> print(i) <span class="hljs-function"><span class="hljs-keyword">end</span></span></code></pre>

<p>fib.lua <br>
这是倒着算的</p>



<pre class="prettyprint"><code class=" hljs lua"><span class="hljs-comment">-- fibonacci function with cache</span>

<span class="hljs-comment">-- very inefficient fibonacci function</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fib</span><span class="hljs-params">(n)</span></span>
    N=N+<span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> n&lt;<span class="hljs-number">2</span> <span class="hljs-keyword">then</span>
        <span class="hljs-keyword">return</span> n
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> fib(n-<span class="hljs-number">1</span>)+fib(n-<span class="hljs-number">2</span>)
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment">-- a general-purpose value cache</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cache</span><span class="hljs-params">(f)</span></span>
    <span class="hljs-keyword">local</span> c={}
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x)</span></span>
        <span class="hljs-keyword">local</span> y=c[x]
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> y <span class="hljs-keyword">then</span>
            y=f(x)
            c[x]=y
        <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">return</span> y
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment">-- run and time it</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span><span class="hljs-params">(s,f)</span></span>
    N=<span class="hljs-number">0</span>
    <span class="hljs-keyword">local</span> c=<span class="hljs-built_in">os</span>.clock()
    <span class="hljs-keyword">local</span> v=f(n)
    <span class="hljs-keyword">local</span> t=<span class="hljs-built_in">os</span>.clock()-c
    <span class="hljs-built_in">print</span>(s,n,v,t,N)
<span class="hljs-keyword">end</span>

n=arg[<span class="hljs-number">1</span>] <span class="hljs-keyword">or</span> <span class="hljs-number">24</span>      <span class="hljs-comment">-- for other values, do lua fib.lua XX</span>
n=<span class="hljs-built_in">tonumber</span>(n)
<span class="hljs-built_in">print</span>(<span class="hljs-string">""</span>,<span class="hljs-string">"n"</span>,<span class="hljs-string">"value"</span>,<span class="hljs-string">"time"</span>,<span class="hljs-string">"evals"</span>)
test(<span class="hljs-string">"plain"</span>,fib)
fib=cache(fib)
test(<span class="hljs-string">"cached"</span>,fib)</code></pre>

<p>递归层数过多之后堆栈很快就会溢出，通过cache有效减少递归调用，关键是依赖解释执行这个特性，cache可以做成通用函数，在fib成为一个新函数之后，在原fib函数定义中对fib的调用使用的是新的fib。</p>



<h3 id="筛选法求质数">筛选法求质数</h3>

<p>sieve.lua</p>



<pre class="prettyprint"><code class=" hljs livecodeserver"><span class="hljs-comment">-- the sieve of of Eratosthenes programmed with coroutines</span>
<span class="hljs-comment">-- typical usage: lua -e N=1000 sieve.lua | column</span>

<span class="hljs-comment">-- generate all the numbers from 2 to n</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gen</span> (<span class="hljs-title">n</span>)</span>
  <span class="hljs-constant">return</span> coroutine.<span class="hljs-operator">wrap</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> ()</span>
    <span class="hljs-keyword">for</span> i=<span class="hljs-number">2</span>,n <span class="hljs-built_in">do</span> coroutine.yield(i) <span class="hljs-function"><span class="hljs-keyword">end</span></span>
  <span class="hljs-function"><span class="hljs-keyword">end</span>)</span>
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

<span class="hljs-comment">-- filter the numbers generated by `g', removing multiples of `p'</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filter</span> (<span class="hljs-title">p</span>, <span class="hljs-title">g</span>)</span>
  <span class="hljs-constant">return</span> coroutine.<span class="hljs-operator">wrap</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> ()</span>
    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span> <span class="hljs-built_in">do</span>
      <span class="hljs-built_in">local</span> n = g()
      <span class="hljs-keyword">if</span> n == nil <span class="hljs-keyword">then</span> <span class="hljs-constant">return</span> <span class="hljs-function"><span class="hljs-keyword">end</span></span>
      <span class="hljs-keyword">if</span> math.<span class="hljs-operator">mod</span>(n, p) ~= <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> coroutine.yield(n) <span class="hljs-function"><span class="hljs-keyword">end</span></span>
    <span class="hljs-function"><span class="hljs-keyword">end</span></span>
  <span class="hljs-function"><span class="hljs-keyword">end</span>)</span>
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

N=N <span class="hljs-operator">or</span> <span class="hljs-number">1000</span>     <span class="hljs-comment">-- from command line</span>
x = gen(N)      <span class="hljs-comment">-- generate primes up to N</span>
<span class="hljs-keyword">while</span> <span class="hljs-number">1</span> <span class="hljs-built_in">do</span>
  <span class="hljs-built_in">local</span> n = x()     <span class="hljs-comment">-- pick a number until done</span>
  <span class="hljs-keyword">if</span> n == nil <span class="hljs-keyword">then</span> break <span class="hljs-function"><span class="hljs-keyword">end</span></span>
  print(n)      <span class="hljs-comment">-- must be a prime number</span>
  x = <span class="hljs-built_in">filter</span>(n, x)  <span class="hljs-comment">-- now remove its multiples</span>
<span class="hljs-function"><span class="hljs-keyword">end</span></span></code></pre>

<p>每获得一个新质数n之后，会创建一个协程filter n，它resume filter m(m是n之前的质数)来获取下一个数，filter m resume filter s(s是m之前的质数)，…，直到resume gen产生下一个整数，filter 2判断这个数能否被2整除，如果能整除则继续取下一个数，不能被整除则yield给filter 3，filter 3再判断能否被3整除，如果能则resume filter 2获取下一个数，如果不能则yield给filter 5，……，直到最后交给filter n，最后获得这个数，不能被已获得的质数整除，所以它是新的质数。 <br>
这段程序首先不太好理解，其次在运算过程中嵌套层数会越来越多，堆栈很快就会溢出，也就是作为协程的例子看看就好了。</p>



<h3 id="看不懂的">看不懂的</h3>

<p>factorial.lua</p>



<pre class="prettyprint"><code class=" hljs livecodeserver"><span class="hljs-comment">-- function closures are powerful</span>

<span class="hljs-comment">-- traditional fixed-point operator from functional programming</span>
Y = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-title">g</span>)</span>
      <span class="hljs-built_in">local</span> <span class="hljs-operator">a</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-title">f</span>) <span class="hljs-title">return</span> <span class="hljs-title">f</span>(<span class="hljs-title">f</span>) <span class="hljs-title">end</span></span>
      <span class="hljs-constant">return</span> <span class="hljs-operator">a</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-title">f</span>)</span>
                 <span class="hljs-constant">return</span> g(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-title">x</span>)</span>
                             <span class="hljs-built_in">local</span> c=f(f)
                             <span class="hljs-constant">return</span> c(x)
                           <span class="hljs-function"><span class="hljs-keyword">end</span>)</span>
               <span class="hljs-function"><span class="hljs-keyword">end</span>)</span>
<span class="hljs-function"><span class="hljs-keyword">end</span></span>


<span class="hljs-comment">-- factorial without recursion</span>
F = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-title">f</span>)</span>
      <span class="hljs-constant">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-title">n</span>)</span>
               <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-constant">return</span> <span class="hljs-number">1</span>
               <span class="hljs-keyword">else</span> <span class="hljs-constant">return</span> n*f(n-<span class="hljs-number">1</span>) <span class="hljs-function"><span class="hljs-keyword">end</span></span>
             <span class="hljs-function"><span class="hljs-keyword">end</span></span>
    <span class="hljs-function"><span class="hljs-keyword">end</span></span>

factorial = Y(F)   <span class="hljs-comment">-- factorial is the fixed point of F</span>

<span class="hljs-comment">-- now test it</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-title">x</span>)</span>
    io.<span class="hljs-built_in">write</span>(x,<span class="hljs-string">"! = "</span>,factorial(x),<span class="hljs-string">"\n"</span>)
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

<span class="hljs-keyword">for</span> n=<span class="hljs-number">0</span>,<span class="hljs-number">16</span> <span class="hljs-built_in">do</span>
    test(n)
<span class="hljs-function"><span class="hljs-keyword">end</span></span></code></pre>

<p>虽然没看懂，但我试着修改成了下面的代码：</p>



<pre class="prettyprint"><code class=" hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span><span class="hljs-params">(f)</span></span>
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n)</span></span>
                <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> n*f(n-<span class="hljs-number">1</span>) <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

factorial = F(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(n)</span></span> <span class="hljs-keyword">return</span> factorial(n) <span class="hljs-keyword">end</span>)

<span class="hljs-built_in">print</span>(factorial(<span class="hljs-number">4</span>))</code></pre></div></body>
</html>