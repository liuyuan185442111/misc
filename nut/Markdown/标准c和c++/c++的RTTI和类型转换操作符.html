<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>c++的RTTI和类型转换操作符</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><h2 id="rtti">RTTI</h2>

<p>c++的RTTI（Run-Time Type Information）的相关内容包括typeid、dynamic_cast这两个关键字，和头文件&lt;typeinfo&gt;。</p>

<p>type_info在&lt;typeinfo&gt;中定义，必须在typeid运算符的使用之前包含此头文件。</p>

<p>type_info的public成员有：</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">virtual</span> ~type_info();
<span class="hljs-comment">/** 返回一个实现定义的字符串, 不可移植, 同种类型的type_info对象
的name()返回的字符串相同, 不同类型对应的字符串则不同 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* name() <span class="hljs-keyword">const</span>;
<span class="hljs-comment">/** 是否before参数标识的类型, 不同编译器实现可能不同,
不同程序之间返回值可能也不同, 同一程序不同时间运行结果可能也不一样 */</span>
<span class="hljs-keyword">bool</span> before(<span class="hljs-keyword">const</span> type_info&amp; arg) <span class="hljs-keyword">const</span>;
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> type_info&amp; arg) <span class="hljs-keyword">const</span>;
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> type_info&amp; arg) <span class="hljs-keyword">const</span></code></pre>

<p>type_info的默认构造函数，拷贝构造函数，赋值运算符都是private或protected的。这样，你就不能建立一个type_info类型的对象，只能通过typeid运算符来获得type_info对象。</p>

<p>typeid的作用是在程序运行时，返回对象的类型，主要用来在多态中判断一个基类指针或引用是否指向派生类对象，用起来像一个函数，返回值类型是const type_info &amp;。同sizeof类似，typeid可接受一个类型或变量。</p>

<p>typeid(t)中，当t是对象时，只有对象t是引用且t有虚指针时才会通过虚指针去寻找t的type_info，其他情况下，直接在编译时期确定类型。 typeid(*p)中，当p是指向对象的指针时，也是类似。</p>

<p>可以用typeid来简陋地模拟实现dynamic_cast的部分功能：</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
<span class="hljs-keyword">struct</span> my_dynamic_cast_t
{
    T* <span class="hljs-keyword">operator</span>()(U*p)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
<span class="hljs-keyword">struct</span> my_dynamic_cast_t&lt;T*, U&gt;
{
    T* <span class="hljs-keyword">operator</span>()(U*p)
    {
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeid</span>(*p) == <span class="hljs-keyword">typeid</span>(T))
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(p);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> NULL;
    }
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
T my_dynamic_cast(U* p)
{
    <span class="hljs-keyword">return</span> my_dynamic_cast_t&lt;T,U&gt;()(p);
}</code></pre>

<p>&lt;typeinfo&gt;中还定义了两个异常：</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">// 强制转换为引用类型失败, dynamic_cast运算符引发bad_cast异常</span>
<span class="hljs-keyword">class</span> bad_cast : <span class="hljs-keyword">public</span> exception
{
  <span class="hljs-keyword">public</span>:
    bad_cast() <span class="hljs-keyword">throw</span>() { }
    <span class="hljs-keyword">virtual</span> ~bad_cast() <span class="hljs-keyword">throw</span>();
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* what() <span class="hljs-keyword">const</span> <span class="hljs-keyword">throw</span>();
};

<span class="hljs-comment">// 如果交给typeid的参数是空指针, 抛出此异常</span>
<span class="hljs-keyword">class</span> bad_typeid : <span class="hljs-keyword">public</span> exception
{
  <span class="hljs-keyword">public</span>:
    bad_typeid () <span class="hljs-keyword">throw</span>() { }
    <span class="hljs-keyword">virtual</span> ~bad_typeid() <span class="hljs-keyword">throw</span>();
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* what() <span class="hljs-keyword">const</span> <span class="hljs-keyword">throw</span>();
};</code></pre>

<p>抛出bad_typeid的情形如下，注意必须有虚指针才会抛出异常，否则如上所说，在编译期就能决断出*p的类型来：</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">struct</span> b
{
    <span class="hljs-keyword">virtual</span> ~b(){}
};

<span class="hljs-keyword">int</span> main()
{
    b *p = NULL;
    <span class="hljs-keyword">typeid</span>(*p);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>



<h2 id="类型转换操作符">类型转换操作符</h2>

<p>c++里有4个强制类型转换操作符，分别是static_cast, dynamic_cast，const_cast，reinterpret_cast。</p>



<h3 id="reinterpretcast">reinterpret_cast</h3>

<p>reinterpret是重新解释的意思，reinterpret_cast仅用来对内存地址进行变换操作，reinterpret_cast会产生一个新的值，这个值会有与原始参数有完全相同的比特位。</p>

<p>reinterpret_cast可用作： <br>
任意指针类型到一个足够大的整数类型的转换 <br>
整数类型到任意指针类型的转换 <br>
任意指针类型之间的互相转换 <br>
任意类型左值到任意类型引用的转换，如：</p>

<pre><code>vector&lt;int&gt; v;
reinterpret_cast&lt;int&amp;&gt;(v);//虽然能通过编译，但没什么意义
</code></pre>



<h3 id="constcast">const_cast</h3>

<p><code>const_cast&lt;type-id&gt;(expression)</code> <br>
该运算符用来修改类型的const或volatile属性。 <br>
type-id必须是指针，引用，或指向数据成员的指针。</p>



<h3 id="staticcast">static_cast</h3>

<p>没有运行时类型检查来保证转换的安全性，用途有： <br>
①   用于类层次结构中基类和派生类之间指针或引用的转换。 <br>
    进行上行转换（把派生类的指针或引用转换成基类表示）是安全的； <br>
    进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。 <br>
    一般来说下行转换应使用dynamic_cast，但如果能保证转换是安全的，则可以使用static_cast，而且效率还高一些。 <br>
②用于基本数据类型之间的转换，如把int转换成char，把int转换成enum，把double转换成int，这种转换的安全性也要开发人员来保证。 <br>
③把空指针转换成目标类型的指针。 <br>
④把任何类型的表达式转换成void类型。 <br>
⑤如果一个类拥有只有一个参数的构造函数或类型转换运算符，则可以用static_cast来调用二者进行转换。</p>



<h3 id="dynamiccast">dynamic_cast</h3>

<p><code>dynamic_cast&lt;type-id&gt;(expression)</code> <br>
以上三个操作符在编译时进行转换，dynamic_cast则在运行时进行类型转换，该转换符主要用于将一个指向派生类的基类指针或引用转换为派生类的指针或引用。</p>

<p>dynamic_cast只能用于指针或引用，type-id必须是pointer or reference to class。dynamic_cast支持派生类指针/引用到基类指针/引用的转换，但会在编译时进行，<code>c *p;dynamic_cast&lt;c*&gt;(p);</code>这种无聊操作也能通过编译。除了这两种情况，expression的类必须是多态的，即必须有虚函数。对type-id的类却没有要求，可以和expression完全不相关。 <br>
用dynamic_cast对没有关系的两个类指针或引用进行转换，当然会转换失败，但能编译通过，static_cast则是直接编译失败。</p>

<p>dynamic_cast还可用来对多重继承中不同基类指针/引用进行转换（cross cast）（c++必知必会27 ）。</p>

<p>特别的，把一个指针dynamic_cast成void*类型，转换后的指针指向原来指针所指向对象的内存开始处。一个用处是来判断两个指针是不是从同一个类派生而来：</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Y&gt;
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> X* px, <span class="hljs-keyword">const</span> Y* py) {
     <span class="hljs-keyword">return</span> <span class="hljs-keyword">dynamic_cast</span>&lt;<span class="hljs-keyword">void</span>*&gt;(px) == <span class="hljs-keyword">dynamic_cast</span>&lt;<span class="hljs-keyword">void</span>*&gt;(py);
}</code></pre>

<p>More Effective C++ 条款27说明了另一种用法，实现了一个HeapTracked类，判断一个从该类派生而来的类是否分配在堆上。</p>

<p>如果dynamic_cast转换失败，如果是指针则反回一个0值，如果是转换的是引用，则抛出一个bad_cast异常。 <br>
如果对引用进行转换时不想抛出异常，可以用typeid和static_cast来代替。（深度探索C++对象模型第7章）</p>

<h2 id="reinterpretcast和staticcast的不同">reinterpret_cast和static_cast的不同</h2>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> A
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> m_a;
};

<span class="hljs-keyword">class</span> B
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> m_b;
};

<span class="hljs-keyword">class</span> C : <span class="hljs-keyword">public</span> A, <span class="hljs-keyword">public</span> B {};

<span class="hljs-keyword">int</span> main()
{
    C c;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%p, %p, %p"</span>, &amp;c, <span class="hljs-keyword">reinterpret_cast</span>&lt;B*&gt;(&amp;c), <span class="hljs-keyword">static_cast</span>&lt;B*&gt;(&amp;c));
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

输出：
<span class="hljs-number">0028F</span>F18, <span class="hljs-number">0028F</span>F18, <span class="hljs-number">0028F</span>F1C</code></pre>

<p>reinterpret_cast就是对地址强制重新解释而已，static_cast则进行了安全的转换。</p>

<h2 id="参考">参考</h2>

<p><a href="http://www.cnblogs.com/ider/archive/2011/08/05/cpp_cast_operator_part6.html" target="_blank">C++类型转换方式总结</a> <br>
c++必知必会 <br>
More Effective C++ 条款5 <br>
深度探索C++对象模型 第7章</p></div></body>
</html>