<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>确定类型和表达式在编译期信息的模板技术</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><p>《c++必知必会》“item 52 针对类型信息的特化”提供了通过类模板的部分特化获得一个类型是否为一个指针的方法：</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> IsPtr <span class="hljs-comment">// T不是一个指针</span>
{
    <span class="hljs-keyword">enum</span> { result=<span class="hljs-keyword">false</span> };
};
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> IsPtr&lt;T*&gt; <span class="hljs-comment">// 一个不带修饰符的指针</span>
{
    <span class="hljs-keyword">enum</span> { result=<span class="hljs-keyword">true</span> };
};
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> IsPtr&lt;T* <span class="hljs-keyword">const</span>&gt; <span class="hljs-comment">// const指针</span>
{
    <span class="hljs-keyword">enum</span> { result=<span class="hljs-keyword">true</span> };
};
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> IsPtr&lt;T* <span class="hljs-keyword">volatile</span>&gt; <span class="hljs-comment">// volatile指针</span>
{
    <span class="hljs-keyword">enum</span> { result=<span class="hljs-keyword">true</span> };
};
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> IsPtr&lt;T* <span class="hljs-keyword">const</span> <span class="hljs-keyword">volatile</span>&gt; <span class="hljs-comment">// const volatile指针</span>
{
    <span class="hljs-keyword">enum</span> { result=<span class="hljs-keyword">true</span> };
};</code></pre>

<p>为其设想一个使用实例：</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">struct</span> Key
{
    Key(<span class="hljs-keyword">int</span> k):key(k) {}
    <span class="hljs-keyword">int</span> key;
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> print_key(T t)
{
    <span class="hljs-keyword">if</span>(IsPtr&lt;T&gt;::result)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; t-&gt;key;
        <span class="hljs-keyword">delete</span> t;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; t.key;
    }
}

<span class="hljs-keyword">int</span> main()
{
    print_key(<span class="hljs-keyword">new</span> Key(<span class="hljs-number">11</span>));
    print_key(Key(<span class="hljs-number">13</span>));
}</code></pre>

<p>然而，上边的代码根本就不能通过编译，print_key(new Key(11));的展开是这样的：</p>



<pre class="prettyprint"><code class=" hljs coffeescript"><span class="hljs-reserved">void</span> print_key(Key *t)
{
    <span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>)
    {
        cout &lt;&lt; t-&gt;key;
        <span class="hljs-keyword">delete</span> t;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-regexp">//</span><span class="hljs-attribute">error</span>: request <span class="hljs-keyword">for</span> member <span class="hljs-string">'key'</span> <span class="hljs-keyword">in</span> <span class="hljs-string">'t'</span>, which <span class="hljs-keyword">is</span> <span class="hljs-keyword">of</span> pointer type <span class="hljs-string">'Key*'</span>
        cout &lt;&lt; t.key;
    }
}</code></pre>

<p>没有模板的时候，这明显就是错的，我们可以抱怨编译器不够智能，可规则就是这样的，还是和它斗智斗勇吧。 <br>
可以通过函数模板的重载来解决这个问题，完整实例如下：</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">struct</span> Yes {};
<span class="hljs-keyword">struct</span> No {};
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> IsPtr <span class="hljs-comment">// T不是一个指针</span>
{
    <span class="hljs-keyword">enum</span> { result=<span class="hljs-keyword">false</span> };
    <span class="hljs-keyword">typedef</span> No Result;
};
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> IsPtr&lt;T*&gt; <span class="hljs-comment">// 一个不带修饰符的指针</span>
{
    <span class="hljs-keyword">enum</span> { result=<span class="hljs-keyword">true</span> };
    <span class="hljs-keyword">typedef</span> Yes Result;
};
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> IsPtr&lt;T* <span class="hljs-keyword">const</span>&gt; <span class="hljs-comment">// const指针</span>
{
    <span class="hljs-keyword">enum</span> { result=<span class="hljs-keyword">true</span> };
    <span class="hljs-keyword">typedef</span> Yes Result;
};
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> IsPtr&lt;T*<span class="hljs-keyword">volatile</span>&gt; <span class="hljs-comment">// volatile指针</span>
{
    <span class="hljs-keyword">enum</span> { result=<span class="hljs-keyword">true</span> };
    <span class="hljs-keyword">typedef</span> Yes Result;
};
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> IsPtr&lt;T*<span class="hljs-keyword">const</span> <span class="hljs-keyword">volatile</span>&gt; <span class="hljs-comment">// const volatile指针</span>
{
    <span class="hljs-keyword">enum</span> { result=<span class="hljs-keyword">true</span> };
    <span class="hljs-keyword">typedef</span> Yes Result;
};

<span class="hljs-keyword">struct</span> Key
{
    Key(<span class="hljs-keyword">int</span> k):key(k) {}
    <span class="hljs-keyword">int</span> key;
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> print_key(T t)
{
    print_key(<span class="hljs-keyword">typename</span> IsPtr&lt;T&gt;::Result(), t);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> print_key(Yes, T t)
{
    <span class="hljs-built_in">cout</span> &lt;&lt; t-&gt;key;
    <span class="hljs-keyword">delete</span> t;
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> print_key(No, T t)
{
    <span class="hljs-built_in">cout</span> &lt;&lt; t.key;
};

<span class="hljs-keyword">int</span> main()
{
    print_key(<span class="hljs-keyword">new</span> Key(<span class="hljs-number">11</span>));
    print_key(Key(<span class="hljs-number">13</span>));
}</code></pre>

<hr>

<p>还可以利用SFINAE实现IsPtr。SFINAE: substitution failure is not an error，当试图使用函数模板实参推导机制在多个函数模板和非模板函数中进行选择时，只要发现了一个正确的替换，其他对函数模板尝试过的错误替换都不会导致报错。（c++必知必会 item 59） <br>
This rule applies during overload resolution of function templates: When substituting the deduced type for the template parameter fails, the specialization is discarded from the overload set instead of causing a compile error.（<a href="http://en.cppreference.com/w/cpp/language/sfinae">http://en.cppreference.com/w/cpp/language/sfinae</a>）</p>

<p>用SFINAE来重新实现IsPtr：</p>



<pre class="prettyprint"><code class=" hljs r">typedef struct {char a;} True;
typedef struct {char a[<span class="hljs-number">2</span>];} False;
template &lt;typename <span class="hljs-literal">T</span>&gt; True isPtr(<span class="hljs-literal">T</span>*);
False isPtr(<span class="hljs-keyword">...</span>);
<span class="hljs-comment">#define is_ptr(e) (sizeof(isPtr(e)) == sizeof(True))</span></code></pre>

<p>isPtr可以判断被const volatile限定的指针，作为函数模板实参推导的一个组成部分，编译期将会忽略cv修饰符，也会忽略引用修饰符。 <br>
而且isPtr不用有实现，sizeof操作符可以在编译时返回一个类型或表达式的大小，所以isPtr根本就没有被调用，也就是说在编译期就已经对is_ptr的值进行了计算。</p>

<p>然后怎么使用is_ptr呢，可以像上面那样，通过函数模板重载来解决，这里我们用类模板的偏特化（函数模板不支持偏特化）：</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">bool</span>,<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> print_t
{
    <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>()(T t);
};
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> print_t&lt;<span class="hljs-keyword">true</span>,T&gt;
{
    <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>()(T t)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; t-&gt;key;
        <span class="hljs-keyword">delete</span> t;
    }
};
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> print_t&lt;<span class="hljs-keyword">false</span>,T&gt;
{
    <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>()(T t)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; t.key;
    }
};

<span class="hljs-keyword">struct</span> Key
{
    Key(<span class="hljs-keyword">int</span> k):key(k) {}
    <span class="hljs-keyword">int</span> key;
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> print_key(T t)
{
    print_t&lt;is_ptr(t),T&gt;()(t);
}

<span class="hljs-keyword">int</span> main()
{
    print_key(<span class="hljs-keyword">new</span> Key(<span class="hljs-number">11</span>));
    print_key(Key(<span class="hljs-number">13</span>));
}</code></pre>

<hr>

<p>SFINAE可用于揭示关于类型和表达式在编译期的信息。 <br>
下面是一个判断对象中是否有特定类型的例子：</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {<span class="hljs-keyword">char</span> a;} True;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {<span class="hljs-keyword">char</span> a[<span class="hljs-number">2</span>];} False;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> C&gt;
True hasIterator(<span class="hljs-keyword">typename</span> C::iterator *);
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
False hasIterator(...);
<span class="hljs-preprocessor">#define has_iterator(C) (sizeof(hasIterator&lt;C&gt;(0))==sizeof(True))</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">bool</span> B&gt;
<span class="hljs-keyword">struct</span> enable_if {};

<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-keyword">struct</span> enable_if&lt;<span class="hljs-keyword">true</span>&gt; { <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span> type; };

<span class="hljs-comment">//对use的调用,会从两个候选use中选择一个</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">typename</span> enable_if&lt;has_iterator(T)&gt;::type use(T t)
{
    <span class="hljs-keyword">typename</span> T::iterator it;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"has iterator\n"</span>;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">typename</span> enable_if&lt;!has_iterator(T)&gt;::type use(T t)
{
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"has no iterator\n"</span>;
}

<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> v;
    use(v);
    use(<span class="hljs-number">5</span>);
}</code></pre>

<hr>

<p>以上，判断的结果都是一个bool的值，如何继续使用该值，三个例子提供了三种不同的方式： <br>
可以让模板不同的版本提供不同的类型定义，根据这些不同的类型利用函数的重载机制； <br>
可以用类模板的偏特化，对true和false分别定义不同的特化； <br>
第三种既用了类模板的完全特化，也让不同的特化提供不同的类型定义。</p>

<hr>

<p>判断一个变量是不是一个对象：</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">struct</span> isClass
{
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {<span class="hljs-keyword">char</span> a;} True;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {<span class="hljs-keyword">char</span> a[<span class="hljs-number">2</span>];} False;

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> C&gt;
    <span class="hljs-keyword">static</span> True&amp; test(<span class="hljs-keyword">void</span> (C::*)());
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-keyword">static</span> False test(...);

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> value(T){ <span class="hljs-keyword">return</span> <span class="hljs-keyword">sizeof</span>(True) == <span class="hljs-keyword">sizeof</span>(test&lt;T&gt;(<span class="hljs-number">0</span>));}
};
或
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> isClass
{
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {<span class="hljs-keyword">char</span> a;} True;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {<span class="hljs-keyword">char</span> a[<span class="hljs-number">2</span>];} False;

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> C&gt;
    <span class="hljs-keyword">static</span> True&amp; test(<span class="hljs-keyword">void</span> (C::*)());
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C&gt;
    <span class="hljs-keyword">static</span> False test(...);

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> value = <span class="hljs-keyword">sizeof</span>(True) == <span class="hljs-keyword">sizeof</span>(test&lt;T&gt;(<span class="hljs-number">0</span>));
};</code></pre>

<p>用法略有不同，我比较喜欢第一种。</p>

<hr>

<p>判断对象有没有特定成员函数：</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">/*判断对象是否有serialize方法的有些意义的实例*/</span>
<span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;vector&gt;</span>
<span class="hljs-preprocessor">#include &lt;list&gt;</span>
<span class="hljs-preprocessor">#include &lt;cstdio&gt;</span>
<span class="hljs-preprocessor">#include &lt;cstring&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-built_in">string</span> to_string(T)
{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">"has no specialization"</span>);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>,<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">class</span> T,<span class="hljs-keyword">typename</span> Alloc&gt;
<span class="hljs-built_in">string</span> to_string(T&lt;<span class="hljs-keyword">int</span>,Alloc&gt; &amp;u)
{
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">typename</span> T&lt;<span class="hljs-keyword">int</span>,Alloc&gt;::iterator it(u.begin());it!=u.end();++it)
    {
        <span class="hljs-keyword">char</span> buf[<span class="hljs-number">10</span>];
        <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">"%d,"</span>, *it);
        s += buf;
    }
    <span class="hljs-keyword">return</span> s;
}

<span class="hljs-keyword">class</span> Fraction
{
    <span class="hljs-keyword">int</span> numerator;
    <span class="hljs-keyword">int</span> denominator;
<span class="hljs-keyword">public</span>:
    Fraction(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> d):numerator(n),denominator(d){}
    <span class="hljs-built_in">string</span> serialize()
    {
        <span class="hljs-keyword">char</span> buff[<span class="hljs-number">60</span>];
        <span class="hljs-built_in">sprintf</span>(buff,<span class="hljs-string">"%d/%d"</span>,numerator,denominator);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>(buff,buff+<span class="hljs-built_in">strlen</span>(buff));
    }
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> hasSerialize
{
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {<span class="hljs-keyword">char</span> a;} yes;
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {<span class="hljs-keyword">char</span> a[<span class="hljs-number">2</span>];} no;
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U, U u&gt; <span class="hljs-keyword">struct</span> reallyHas;
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C&gt; <span class="hljs-keyword">static</span> no test(...);
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C&gt;
    <span class="hljs-keyword">static</span> yes test(reallyHas&lt;<span class="hljs-built_in">string</span> (C::*)(),&amp;C::serialize&gt; *);<span class="hljs-comment">//参数必然是一个指针</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C&gt;
    <span class="hljs-keyword">static</span> yes test(reallyHas&lt;<span class="hljs-built_in">string</span> (C::*)()<span class="hljs-keyword">const</span>,&amp;C::serialize&gt; *);
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> value = <span class="hljs-keyword">sizeof</span>(yes)==<span class="hljs-keyword">sizeof</span>(test&lt;T&gt;(<span class="hljs-number">0</span>));
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">bool</span> B&gt;
<span class="hljs-keyword">struct</span> enable_if {};

<span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-keyword">struct</span> enable_if&lt;<span class="hljs-keyword">true</span>&gt; { <span class="hljs-keyword">typedef</span> <span class="hljs-built_in">string</span> type; };

<span class="hljs-comment">//如果对象有serialize方法，则调用该方法；如果没有，则调用全局的to_string方法</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">typename</span> enable_if&lt;hasSerialize&lt;T&gt;::value&gt;::type serialize(T t)
{
    <span class="hljs-keyword">return</span> t.serialize();
}
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">typename</span> enable_if&lt;!hasSerialize&lt;T&gt;::value&gt;::type serialize(T t)
{
    <span class="hljs-keyword">return</span> to_string(t);
}

<span class="hljs-keyword">int</span> main()
{
    Fraction f(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; serialize(f) &lt;&lt; endl;

    <span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> cv;
    cv.push_back(<span class="hljs-number">1</span>);
    cv.push_back(<span class="hljs-number">2</span>);
    cv.push_back(<span class="hljs-number">3</span>);
    cv.push_back(<span class="hljs-number">4</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; serialize(cv) &lt;&lt; endl;

    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;</span> ci;
    ci.push_back(<span class="hljs-number">9</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; serialize(ci) &lt;&lt; endl;

    <span class="hljs-built_in">cout</span> &lt;&lt; serialize(<span class="hljs-number">4</span>) &lt;&lt; endl;
}</code></pre>

<hr>

<p>reference: <br>
c++必知必会 <br>
<a href="http://en.cppreference.com/w/cpp/language/sfinae">http://en.cppreference.com/w/cpp/language/sfinae</a> <br>
<a href="http://blog.csdn.net/godcupid/article/details/50420925">http://blog.csdn.net/godcupid/article/details/50420925</a> <br>
<a href="https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error</a></p></div></body>
</html>