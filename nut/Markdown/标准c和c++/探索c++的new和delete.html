<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>探索c++的new和delete</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><p>c++的new是语言自定义的操作符，这个操作符的行为包含两件事，而且用户不能改变： <br>
第一件事，调用operator new()分配内存。所以通常说的重载new其实重载的是operator new()这个函数，我们无法重载new操作符。 <br>
第二件事，调用要new的对象的所属类的构造函数初始化第一步中分配的内存。 <br>
delete操作符的行为也是类似，它先调用析构函数，然后调用operator delete()释放内存。</p>

<p><strong>操作符new和delete能且只能这样调用</strong>： <br>
new(可能的参数或空) 内置数据类型或类; <br>
delete 一个指针;</p>

<p>操作符delete之后的指针会作为参数传递给operator delete()，操作符new如果存在参数，也会传递给operator new()。</p>

<p>new[]、delete[]和new、delete是类似的，所以这里只说明new和delete。 <br>
下面是头文件<code>&lt;new&gt;</code>里operator new()和operator delete()的所有声明（除去一些旁枝末节），这些都是全局的，不包含在namespace std里，而且默认编译器会自动包含头文件<code>&lt;new&gt;</code>，并不需要显式include：</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::size_t) <span class="hljs-keyword">throw</span>(<span class="hljs-built_in">std</span>::bad_alloc);
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>(<span class="hljs-keyword">void</span>*) <span class="hljs-keyword">throw</span>();
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::size_t, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::nothrow_t&amp;) <span class="hljs-keyword">throw</span>();
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>(<span class="hljs-keyword">void</span>*, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::nothrow_t&amp;) <span class="hljs-keyword">throw</span>();
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::size_t, <span class="hljs-keyword">void</span> *p) <span class="hljs-keyword">throw</span>() {<span class="hljs-keyword">return</span> p;}
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>(<span class="hljs-keyword">void</span>*, <span class="hljs-keyword">void</span>*) <span class="hljs-keyword">throw</span>() { }</code></pre>

<p>最后两个称为placement版，是从p所指向的内存区域分配内存，p可以是一个char数组、int数组之类的。它们是内联的，由于内联函数只能有一个定义，所以无法在全局里重载它们。而且，由于无法给delete操作符传递第二个参数（delete操作符只有一种调用方式），所以placement operator delete()是无法通过delete操作符调用的，这意味着，我们只能显式的调用析构函数和placement operator delete()，而placement operator delete()也是空的，给它传递什么参数都无所谓。这两个函数并没有分配内存的操作，所以它们不会throw异常。</p>

<p>operator new()的第一个参数是编译器要分配内存的大小，是由编译器计算并且隐式传递的，并不需要我们插手。在编译器的内部实现中，传入new的尺寸值可能是所需内存的大小s加上一个delta，这个delta是编译器的内部实现定义的某种额外开销。为什么delete操作符不需要第二个尺寸参数呢？因为系统“记住”了分配内存的大小。</p>

<p>如果new操作符不能分配出内存，默认情况下会抛出一个bad_alloc异常对象，然而如果我们自定义了内存耗尽时的处理方法(new_handler)，则会执行这个方法。定义完处理方法后需要用set_new_handler()来登记，set_new_handler定义在namespace std里，它返回旧的handler：<code>new_handler set_new_handler(new_handler) throw();</code>。</p>

<p>还有一个不会抛出异常的operator new()，namespace std里定义了nothrow_t和一个nothrow_t类型的变量供它使用：</p>

<pre><code>struct nothrow_t { };
extern const nothrow_t nothrow;
</code></pre>

<h2 id="operator-new-和operator-delete-的重载">operator new( )和operator delete( )的重载</h2>

<p>我们可以将这两个函数重载为全局的，也可以<strong>重载为类的成员函数</strong>。 <br>
如果非要把它们重载为全局的，最好不要覆盖默认的operator new() 和operator delete()，可以多加一个参数来避免覆盖默认的版本，例如：</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size_t n, <span class="hljs-keyword">int</span> m)
{
    <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(n);
}</code></pre>

<p>是的，正如你看到一样，重载后的版本可以带多个参数。 <br>
如果覆盖了默认的operator new()，不要在里面调用::operator new()，而应调用malloc()，否则就会发生递归调用。 <br>
如果将它们重载为类的成员函数，它们默认成为static的，这很明显，调用它们的时候构造函数都没有调用，this指针还不存在，但我们不妨手动给它加上static关键字，其他方面，比如继承，则和成员函数一样。。</p>

<p>new操作符后面可以有一个括号，可以带很多参数，这些参数都会传递给operator new()，但operator new()的第一个参数必须是size_t类型。实际上，placement operator new()也不过是operator new()的一个重载版本。</p>

<p>operator delete()也可以进行重载，不过我们无法通过delete操作符来调用有多个参数的operator delete()，因为delete操作符的调用只能接受一个指针类型的参数，使用默认的new没问题，但是当对operator new()进行重载时，我们没有优美的方式来调用对应的operator delete()。Stroustrup的回答在此<a href="http://www.stroustrup.com/bs_faq2.html#placement-delete" target="_blank">Is there a “placement delete”?</a> （广义的placement new指的是operator new的重载版本，狭义的是头文件中定义好的<code>inline void* operator new(std::size_t, void* p) throw();</code>）。</p>

<p>但是对应的operator delete()有时却是必须的。当使用new操作符时，会发生两件事情，一是调用operator new()获取一些内存，二是调用对象的构造函数，如果在第二步时构造函数抛出异常，编译器必须负责回收掉operator new()获取的那些内存，编译器会寻找一个与operator new()的参数标对应的operator delete()来调用，如果找不到则什么也不做。operator delete()的第一个参数是void*类型，operator new()的第一个参数是size_t类型，二者对应是说它们的第一个参数以后的参数数目和类型相同。所以，如果没有定义对应的operator delete()，极有可能会发生内存泄漏。比如：</p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">class</span> ND
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size_t size, <span class="hljs-keyword">int</span>)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"in ND::operator new\n"</span>;
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);
    }
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>(<span class="hljs-keyword">void</span> *p, <span class="hljs-keyword">int</span>)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"in ND::operator delete\n"</span>;
        ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>(p);
    }
    ND()
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"in ND::ND construtor\n"</span>;
        <span class="hljs-keyword">throw</span>(<span class="hljs-number">9</span>);
    }
    ~ND()
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"in ND::ND destrutor\n"</span>;
    }
};

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)
{
    <span class="hljs-keyword">try</span>
    {
        ND *p = <span class="hljs-keyword">new</span>(<span class="hljs-number">2</span>) ND;
        p-&gt;~ND();
        ND::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>(p,<span class="hljs-number">3</span>);
    }
    <span class="hljs-keyword">catch</span>(...)
    {
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

输出是
in ND::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>
in ND::ND construtor
in ND::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span></code></pre>

<p>但如果上面的代码中没有定义<code>static void operator delete(void *p, int);</code>，则会造成内存泄漏。 <br>
在上面的代码中，我还显示的调用了ND的析构函数和ND::operator delete()，以完成原本delete操作符应完成的事。</p>

<p>所以系统头文件<code>&lt;new&gt;</code>中的operator new()和operator delete()都是成对的。当然，如果构造函数中确实不会抛出异常，不定义与operator new()对应的operator delete()也没问题，比如：</p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">class</span> ND
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size_t size, <span class="hljs-keyword">int</span>)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"in ND::operator new\n"</span>;
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);
    }
    <span class="hljs-comment">/*static void operator delete(void *p, int)
    {
        cout &lt;&lt; "in ND::operator delete\n";
        ::operator delete(p);
    }*/</span>
    ND() <span class="hljs-keyword">throw</span>()
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"in ND::ND construtor\n"</span>;
    }
    ~ND()
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"in ND::ND destrutor\n"</span>;
    }
};

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)
{
    ND *p = <span class="hljs-keyword">new</span>(<span class="hljs-number">1</span>) ND;
    <span class="hljs-keyword">delete</span> p;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

输出是
in ND::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>
in ND::ND construtor
in ND::ND destrutor</code></pre>

<p>注意这里必须把operator delete()注释掉，因为如果在class内声明任何operator new()，它就会掩盖全局空间里的那些operator new()，operator delete()也是如此。</p>

<h2 id="virtual-destructor和operator-delete">virtual destructor和operator delete</h2>

<p>《c++必知必会》item 36提供了一个例子：</p>



<pre class="prettyprint"><code class="language-#include <iostream> hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">struct</span> base
{
    <span class="hljs-comment">//virtual</span>
    ~base(){}
    <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>(<span class="hljs-keyword">void</span> *p)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"in base delete\n"</span>;
        ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>(p);
    }
};
<span class="hljs-keyword">struct</span> derive : <span class="hljs-keyword">public</span> base
{
    <span class="hljs-comment">//delete 1</span>
    <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>(<span class="hljs-keyword">void</span> *p)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"in derive delete\n"</span>;
        ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>(p);
    }
    <span class="hljs-comment">//delete 2</span>
    <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>(<span class="hljs-keyword">void</span> *p, size_t s)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"size is "</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">", in derive delete\n"</span>;
        ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>(p);
    }
};

<span class="hljs-comment">/**
输出为in base delete,然而如果base的析构被声明为virtual,输出变为in derive delete
注意,仅限于将析构函数声明为virtual才行!如果只是将普通成员函数声明为virtual,没有用!

如果将delete1删掉,则会调用delete2,二者是一样的,不过delete1优先级高一些.
delete2的第二个参数用于保存正被删除的对象大小,这种信息在实现自定义内存管理时往往很有用.
*/</span>

<span class="hljs-keyword">int</span> main()
{
    base *p = <span class="hljs-keyword">new</span> derive;
    <span class="hljs-keyword">delete</span> p;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p>《深度探索C++对象模型》6.2节也对此进行了讨论： <br>
new B[2]; <br>
开辟了一块内存，大小为2*sizeof(B)，并对每个B都执行了构造函数，然后返回该内存块的起始地址。 <br>
delete p; <br>
先对p指向的内存调用p指向类型的析构函数（如果该析构是virtual的，则会通过vptr调用派生类的析构函数，这是编译器在编译时扩充的操作），再free掉该内存块。 <br>
delete [] p; <br>
对于new []，（可能）编译器会维护一个map,放置指针及数组元素的个数；执行delete [] p;时，会找到p对应的数组元素的个数，然后对p指向的内存块，（以sizeof(*p)为跃度）依次调用p指向类型的析构函数。</p>



<h2 id="动态分配一个二维数组">动态分配一个二维数组</h2>

<p>这里提供了一种方式：</p>

<pre class="prettyprint"><code class=" hljs d"><span class="hljs-keyword">int</span> x = <span class="hljs-number">3</span>, y = <span class="hljs-number">4</span>;
<span class="hljs-keyword">int</span> **p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>*[x];<span class="hljs-comment">//创建一个动态 int* 型数组</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; x; ++i)
    p[i] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[y]; <span class="hljs-comment">//再创建一个动态 int 型数组</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; x; ++i)
{
    <span class="hljs-keyword">delete</span> [] p[i];<span class="hljs-comment">//由里至外，进行释放内存。</span>
    p[i] = NULL;<span class="hljs-comment">//不要忘记，释放空间后p[i]不会自动指向NULL值，还将守在原处，只是释放内存而已，仅此而已</span>
}
<span class="hljs-keyword">delete</span> [] p;
p = NULL;</code></pre>

<p>如果要使二维数组占用一块连续内存，可以这样：</p>

<pre class="prettyprint"><code class=" hljs perl"><span class="hljs-keyword">int</span> <span class="hljs-variable">*array1</span> = new <span class="hljs-keyword">int</span>[<span class="hljs-keyword">x</span><span class="hljs-variable">*y</span>];
<span class="hljs-keyword">int</span> <span class="hljs-variable">**</span>array2;
array2 = new <span class="hljs-keyword">int</span>* [<span class="hljs-keyword">x</span>];
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-keyword">x</span>; ++i)
    array2[i] = array1 + i<span class="hljs-variable">*y</span>;

array2[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">4</span>;

<span class="hljs-keyword">delete</span>[] array1;
<span class="hljs-keyword">delete</span>[] array2;</code></pre>

<h2 id="部分源代码">部分源代码</h2>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">//&lt;new&gt;</span>
<span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span> 
{
  <span class="hljs-keyword">class</span> bad_alloc : <span class="hljs-keyword">public</span> exception 
  {
  <span class="hljs-keyword">public</span>:
    bad_alloc() <span class="hljs-keyword">throw</span>() { }
    <span class="hljs-keyword">virtual</span> ~bad_alloc() <span class="hljs-keyword">throw</span>();
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* what() <span class="hljs-keyword">const</span> <span class="hljs-keyword">throw</span>();
  };

  <span class="hljs-keyword">struct</span> nothrow_t { };
  <span class="hljs-keyword">extern</span> <span class="hljs-keyword">const</span> nothrow_t nothrow;

  <span class="hljs-comment">/// If you write your own error handler, it must be of this type.</span>
  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span> (*new_handler)();

  <span class="hljs-comment">/// Takes a replacement handler as the argument, returns the</span>
  <span class="hljs-comment">/// previous handler.</span>
  new_handler set_new_handler(new_handler) <span class="hljs-keyword">throw</span>();
} <span class="hljs-comment">// namespace std</span>

<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::size_t) <span class="hljs-keyword">throw</span>(<span class="hljs-built_in">std</span>::bad_alloc);
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::size_t) <span class="hljs-keyword">throw</span>(<span class="hljs-built_in">std</span>::bad_alloc);
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>(<span class="hljs-keyword">void</span>*) <span class="hljs-keyword">throw</span>();
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>*) <span class="hljs-keyword">throw</span>();
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::size_t, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::nothrow_t&amp;) <span class="hljs-keyword">throw</span>();
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::size_t, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::nothrow_t&amp;) <span class="hljs-keyword">throw</span>();
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>(<span class="hljs-keyword">void</span>*, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::nothrow_t&amp;) <span class="hljs-keyword">throw</span>();
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>*, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::nothrow_t&amp;) <span class="hljs-keyword">throw</span>();

<span class="hljs-comment">// Default placement versions of operator new.</span>
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::size_t, <span class="hljs-keyword">void</span>* __p) <span class="hljs-keyword">throw</span>()
{ <span class="hljs-keyword">return</span> __p; }
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::size_t, <span class="hljs-keyword">void</span>* __p) <span class="hljs-keyword">throw</span>()
{ <span class="hljs-keyword">return</span> __p; }

<span class="hljs-comment">// Default placement versions of operator delete.</span>
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>  (<span class="hljs-keyword">void</span>*, <span class="hljs-keyword">void</span>*) <span class="hljs-keyword">throw</span>() { }
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>*, <span class="hljs-keyword">void</span>*) <span class="hljs-keyword">throw</span>() { }</code></pre>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">// new的主要工作就是调用malloc</span>
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size_t sz) <span class="hljs-keyword">throw</span>(<span class="hljs-built_in">std</span>::bad_alloc)
{
    <span class="hljs-keyword">void</span> *p;
    <span class="hljs-comment">/* malloc(0) is unpredictable; avoid it.  */</span>
    <span class="hljs-keyword">if</span>(sz == <span class="hljs-number">0</span>)
        sz = <span class="hljs-number">1</span>;
    p = (<span class="hljs-keyword">void</span> *)<span class="hljs-built_in">malloc</span>(sz);
    <span class="hljs-keyword">while</span>(p == <span class="hljs-number">0</span>)
    {
        new_handler handler = __new_handler;
        <span class="hljs-keyword">if</span>(!handler)
            <span class="hljs-keyword">throw</span> bad_alloc();
        handler();
        p = (<span class="hljs-keyword">void</span> *)<span class="hljs-built_in">malloc</span>(sz);
    }

    <span class="hljs-keyword">return</span> p;
}

<span class="hljs-comment">// new[]的内容就是调用new</span>
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[] (size_t sz) <span class="hljs-keyword">throw</span>(<span class="hljs-built_in">std</span>::bad_alloc)
{
    <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(sz);
}

<span class="hljs-comment">// delete的内容是调用free</span>
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span> (<span class="hljs-keyword">void</span> *ptr) <span class="hljs-keyword">throw</span>()
{
    <span class="hljs-keyword">if</span>(ptr) <span class="hljs-built_in">free</span>(ptr);
}

<span class="hljs-comment">// delete[]的内容和delete相同</span>
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[] (<span class="hljs-keyword">void</span> *ptr) <span class="hljs-keyword">throw</span>()
{
    <span class="hljs-keyword">if</span>(ptr) <span class="hljs-built_in">free</span>(ptr);
}</code></pre>



<h2 id="参考">参考</h2>

<p>《c++必知必会》 <br>
《深度探索C++对象模型》 <br>
c++的new和delete <br>
<a href="http://blog.csdn.net/liuyuan185442111/article/details/43027867" target="_blank">http://blog.csdn.net/liuyuan185442111/article/details/43027867</a> <br>
C与C++中的异常处理(new/delete) <br>
<a href="http://blog.csdn.net/guoxiaoqian8028/article/details/8211775" target="_blank">http://blog.csdn.net/guoxiaoqian8028/article/details/8211775</a></p></div></body>
</html>