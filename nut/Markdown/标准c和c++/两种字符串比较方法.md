c++中在将字符串做为map的key时，或对字符串进行排序时，需要提供比较方法，如果使用的是string，可以不用指定比较方法，因为标准库为basic_string定义了`bool operator<  (const string& lhs, const string& rhs);`，最终调用的是strcmp方法，然而有时候我们可能需要不一样的排序方式。下面提供了两种比较方法，compare_left和strcmp的比较方式是一样的，可以理解为将所有的字符串左对齐然后进行比较，compare_right则是先比较字符串长度，可以理解为将所有的字符串右对齐然后进行比较。
```cpp
#include <string>
#include <algorithm>
#include <iostream>
#include <iterator>
#include <string.h>
#include <stdio.h>

int compare_left(void *p1, size_t s1, void *p2, size_t s2)
{
	if(int cmp = memcmp(p1, p2, std::min(s1, s2)))
		return cmp;
	return s1 - s2;
}
int compare_right(void *p1, size_t s1, void *p2, size_t s2)
{
	if(int cmp = s1 - s2)
		return cmp;
	return memcmp(p1, p2, s1);
}

bool cmp_int(int k1, int k2)
{
	char buf1[12] = {0};
	char buf2[12] = {0};
	int s1 = sprintf(buf1, "%d", k1);
	int s2 = sprintf(buf2, "%d", k2);
	return compare_right(buf1, s1, buf2, s2) < 0;
}

int main()
{
	const int size = 100000;
	int t[size];
	for(int i=0;i<size;++i)
	{
		t[i] = i+1;
	}
	std::random_shuffle(t, t+size);
	std::sort(t, t+size, cmp_int);
	std::ostream_iterator<int> out_it(std::cout, "\n");
	std::copy(t, t+size, out_it);
	return 0;
}
```
